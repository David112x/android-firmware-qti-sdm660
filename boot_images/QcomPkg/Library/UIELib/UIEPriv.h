/*===========================================================================
              Unified Image Encryption (UIE) Internal Interface

GENERAL DESCRIPTION
  Private definitions and types for UIE (document 80-NP914-1 Rev A)

Copyright (c) 2014 QUALCOMM Technologies Incorporated.  All Rights Reserved.
===========================================================================*/
#ifndef UIE_PRIV_H
#define UIE_PRIV_H

/*===========================================================================
                      DEFINITIONS AND TYPE DECLARATIONS
===========================================================================*/
#define UIE_MAX_SEGMENT_ID       127
#define UIE_ENC_KEY_LADDER_CCM_n 13 // n from NIST 800-38C
#define UIE_ENC_KEY_LADDER_CCM_q 2  // q from NIST 800-38C
#define UIE_ENC_KEY_LADDER_CCM_Q 16 // Q from NIST 800-38C
#define UIE_ENC_KEY_LADDER_CCM_t 16 // t from NIST 800-38C
#define UIE_BASE_IV_LEN          16
#define UIE_DERIVED_IV_LEN       16
#define UIE_DERIVED_IV_OFFSET    16
#define UIE_KEY_LEN              16
#define UIE_SHA256_DIGEST_LEN    32

typedef struct __attribute__((__packed__)) 
{
  uint8 major;
  uint8 minor;
} uie_version_t;

typedef enum
{
  EPS1 = 1,
  EPS2 = 2
} uie_eps_t;

#define UIE_CCM_B0_FLAGS           0x79
#define UIE_CCM_PAYLOAD_LEN_BYTE_0 0x00
#define UIE_CCM_PAYLOAD_LEN_BYTE_1 0x10
typedef struct __attribute__((__packed__))
{
  uint8 flags;
  uint8 nonce[UIE_ENC_KEY_LADDER_CCM_n];
  uint8 payload_len[UIE_ENC_KEY_LADDER_CCM_q]; // Big endian uint16
} uie_ccm_b0_t;

#define UIE_ENC_PARAM_INFO_HDR_MAGIC_NUMBER 0x514d5349
typedef struct __attribute__((__packed__))
{
  uint32        magic_number;
  uint8         num_enc_param_sec;
  uint8         _reserved[3];
  uint16        eps1_offset;
  uie_version_t eps1_ver;
  uint16        eps2_offset;
  uie_version_t eps2_ver;
} uie_enc_param_info_hdr_t;

#define UIE_ENC_PARAM_SEC_HDR_MAGIC_NUMBER 0x51554945
#define UIE_ENC_PARAM_SEC_SIZE             192
#define UIE_ENC_KEY_LADDER_ALGO_AES        1
#define UIE_ENC_KEY_LADDER_MODE_CCM        1
#define UIE_ROOT_KEY_TYPE_RLT_QC           0
#define UIE_ROOT_KEY_TYPE_OTP_OEM          1
#define UIE_ROOT_KEY_TYPE_OTP_QC           2
typedef struct __attribute__((__packed__))
{
  uint32 magic_number;
  uint16 enc_param_sec_size;
  uint8  key_ladder_algo;
  uint8  key_ladder_mode;
  uint8  _reserved;
  uint8  root_key_type;
  uint16 root_key_info_id;
  uint32 _reserved2;
} uie_enc_param_sec_hdr_t;

#define UIE_L2_ADATA_LEN_BYTE_0 0x00
#define UIE_L2_ADATA_LEN_BYTE_1 0x20
#define UIE_KEY_LADDER_LEN      3
#define UIE_RESERVED_IMAGE_ID_BITMAP_MASK 0xff830040 // 1 in mask means ID reserved
typedef struct __attribute__((__packed__))
{
  uint8         adata_len[2]; // Big endian uint16
  uint8         _reserved[2];
  uie_version_t ver;
  uint8         key_ladder_len;
  uint8         _reserved2;
  uint32        image_id_bitmap;
  uint8         _reserved3[20];
} uie_l2_adata_t;

typedef struct __attribute__((__packed__))
{
  uie_ccm_b0_t   b0;
  uie_l2_adata_t adata;
  uint8          encrypted_l2_key[UIE_ENC_KEY_LADDER_CCM_Q];
  uint8          mac[UIE_ENC_KEY_LADDER_CCM_t];
} uie_wrapped_l2_t;

#define UIE_L3_ADATA_LEN_BYTE_0    0x00
#define UIE_L3_ADATA_LEN_BYTE_1    0x20
#define UIE_IMAGE_ENC_ALGO_AES     1
#define UIE_IMAGE_ENC_MODE_CBC_CS2 1
#define UIE_SEGMENT_BITMAP_BITS    128
#define UINT32_BITS                32
typedef struct __attribute__((__packed__))
{
  uint8  adata_len[2]; // Big endian uint16
  uint8  _reserved[2];
  uint8  image_enc_algo;
  uint8  image_enc_mode;
  uint8  _reserved2[6];
  uint8  all_seg_encrypted;
  uint8  num_seg;
  uint16 _reserved3;
  uint32 segment_bitmap[UIE_SEGMENT_BITMAP_BITS/UINT32_BITS];
} uie_l3_adata_t;

typedef struct __attribute__((__packed__))
{
  uie_ccm_b0_t   b0;
  uie_l3_adata_t adata;
  uint8          encrypted_l3_key[UIE_ENC_KEY_LADDER_CCM_Q];
  uint8          mac[UIE_ENC_KEY_LADDER_CCM_t];
} uie_wrapped_l3_t;

typedef struct __attribute__((__packed__)) 
{
  uie_enc_param_sec_hdr_t hdr;
  uie_wrapped_l2_t        wrapped_l2;
  uie_wrapped_l3_t        wrapped_l3;
  uint8                   base_iv[UIE_BASE_IV_LEN];
} uie_enc_param_sec_t;

typedef struct __attribute__((__packed__))
{
  uie_enc_param_info_hdr_t info_hdr;
  uie_enc_param_sec_t      eps1;
  uie_enc_param_sec_t      eps2;
} uie_header_t;

struct uie_ctx_priv // Internal implementation of uie_ctx
{
  uie_version_t library_version;          // Generated by the library
  uint8         l3_key_eps1[UIE_KEY_LEN]; // Derived by EPS1 key unwrap
  uint8         l3_key_eps2[UIE_KEY_LEN]; // Derived by EPS2 key unwrap
  uie_header_t  hdr;                      // Local copy of image header
};

/*===========================================================================
                             FUNCTION PROTOTYPES
===========================================================================*/

/**
 * @brief Runs the CBC-CS2 decryption algorithm using the
 *        AES128 or AES256 block cipher.
 *
 * @param[in]  key The key to decrypt with
 * @param[in]  key_len The length of the key (16=AES128, 32=AES256)
 * @param[in]  iv The initialization vector to decrypt with
 * @param[in]  iv_len The byte length of the initialization vector
 * @param[in]  ct The ciphertext to decrypt
 * @param[in]  ct_len The byte length of the ciphertext
 * @param[out] pt The decrypted plaintext
 * @param[in]  pt_len The byte length of the plaintext buffer
 * @param[out] digest The optional SHA256 hash digest; a non-NULL
 *                    input address will result in a digest output
 *
 * @note ct and pt can be the same address (i.e. decryption in place)
 *
 * @return - 0 on success, non-zero on failure.
 */
int uie_decrypt_cts(uint8 *key, uint32 key_len,
                    uint8 *iv,  uint32 iv_len,
                    uint8 *ct,  uint32 ct_len,
                    uint8 *pt,  uint32 pt_len,
                    uint8 *digest);

/**
 * @brief Runs the CCM algorithm using the AES128 or AES256
 *        block cipher to decrypt an encrypted payload
 *        and validate its MAC tag.
 *
 * @param[in] key_src The root encryption key type
 * @param[in] key The key to decrypt with
 * @param[in] key_len The length of the key (16=AES128, 32=AES256)
 * @param[in] nonce The nonce input
 * @param[in] nonce_len The byte length of the nonce
 * @param[in] ct The ciphertext to decrypt
 * @param[in] ct_len The byte length of the ciphertext
 * @param[in] adata The associated data
 * @param[in] adata_len The byte length of the associated data
 * @param[in] mac The MAC tag to validate
 * @param[in] mac_len The byte length of the MAC tag
 * @param[out] pt The decrypted plaintext
 * @param[in]  pt_len The byte length of the plaintext buffer
 *
 * @note ct and pt can be the same address (i.e. decryption in place)
 * @note If key_src is not set to UIE_KEY_SRC_PROVIDED then it is expected
 *          that key is NULL and key_len is 0 because those values will be
 *          determined by the root key source
 *
 * @return - 0 on success, non-zero on failure (e.g. authentication fails).
 */
int uie_decrypt_ccm(uie_key_src_t key_src,
                    uint8 *key,   uint32 key_len,
                    uint8 *nonce, uint32 nonce_len,
                    uint8 *ct,    uint32 ct_len,
                    uint8 *adata, uint32 adata_len,
                    uint8 *mac,   uint32 mac_len,
                    uint8 *pt,    uint32 pt_len);

/**
 * @brief Runs the SHA-256 hash algorithm.
 *
 * @param[in] msg The message to hash
 * @param[in] msg_len The length of the message to hash
 * @param[out] digest The resulting 256-bit hash digest
 *
 * @return - 0 on success, non-zero on failure.
 */
int uie_hash_sha256(uint8 *msg, uint32 msg_len,
                    uint8 *digest);

/**
 * @brief Checks if Security Control Encryption Enable fuse is set
 *
 * @return - true if set, false otherwise
 */
bool uie_is_image_encryption_fuse_enabled(void);

/**
 * @brief Retrieves the L1 key
 *
 * @param[in]  key_src The key source
 * @param[out] key     The resulting key
 * @param[in]  key_len The byte length of the key
 *
 * @return - 0 on success, non-zero on failure.
 */
int uie_get_l1_fuse_key(uie_key_src_t key_src, uint8 *key, uint32 key_len);

/**
 * @brief Verifies that fuse reads were not corrupted.
 *
 * @return - true if no fuse read error was detected, false otherwise.
 */
bool uie_fec_error_occurred(void);

/**
 * @brief Retrieves the FEC status value
 *
 * @return - the FEC status value
 */
uint16 uie_get_fec(void);

/**
 * @brief Clears the FEC status
 */
void uie_clear_fec(void);
#endif
