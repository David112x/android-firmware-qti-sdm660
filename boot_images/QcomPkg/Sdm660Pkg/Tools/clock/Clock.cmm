
;============================================================================
;
; *************** THIS SCRIPT WAS AUTOGENERATED ****************
;
; TARGET
;
;
; SCRIPT
;   CLOCK.CMM
;
; GENERAL DESCRIPTION
;    This script functions as the high level clock debug interface menu.
;    It redirects users to the appropriate target specific debug script.
;
; FUNCTIONS
;   N/A
;
;    Copyright (c) 2015 by QUALCOMM Technologies Inc.  All Rights Reserved.
;============================================================================



; User may specify a target.
entry &target

local &ARGS
&ARGS=os.ppd()
gosub __acquire_args_cmm &ARGS
entry &ARGS

local &AID
local &success
local &clk_err
local &clk_err
local &choice
local &choice_first_char
local &target
local &clock_dir
local &targ_dir
local &log_filename
local &opts

local &logging
&logging=0


; Generic top level error handler.
on ERROR gosub
(
  print %ERROR "ERROR: Caught error in 'Clock.cmm'."
  return
)

;-----------------------------------------------------------------------------
; Apply default target if none specified when executing this script
;-----------------------------------------------------------------------------

if ("&target"=="")
(
  ; Use default target.
  &target="v1"
)
else
(
  gosub wa_get_substr_ws "&target" 0.
  entry &target
)

;-----------------------------------------------------------------------------
; Define and display the window
;-----------------------------------------------------------------------------

; Clear any leftover history window.
winclear clock_script_hist_window

; Create the scipt areas.
gosub wa_area_create_list 2 CLOCK_MAIN_SCRIPT 180. 1000. CLOCK_MAIN_HIST , ,
entry &success
if (&success==0)
(
  area.select
  print %ERROR "ERROR: Failed to create areas for Clock.cmm."
  enddo
)

area.clear CLOCK_MAIN_SCRIPT

gosub Restore_Main_Clock_Window
gosub Display_Help

;-----------------------------------------------------------------------------
; Ensure that T32 can read the subscripts for this target.
;-----------------------------------------------------------------------------

&clock_dir=OS.PPD()
&targ_dir="&clock_dir\&target"

if (OS.DIR.ACCESS("&targ_dir", "R")==FALSE())
(
  print %ERROR "ERROR: Cannot read directory '&targ_dir'."
  print %ERROR "       Is '&target' the correct target?"
  print " "
  print "Exiting 'Clock.cmm'..."
  print " "

  gosub Exit_ClockScript NOCLEAR
)


;-----------------------------------------------------------------------------
; Main Loop
;-----------------------------------------------------------------------------

do &ARGS create_client clock_main_menu CLOCK_MAIN_SCRIPT
entry &AID
if ("&AID"=="ARGS_ERR")
(
  do &ARGS get_error
  entry &clk_err

  print %ERROR "ERROR: Failed to create an ARGS client:"
  print %ERROR "       '&clk_err'."
  enddo
)


&opts="print_errors=1 nonempty_cmds=1 help_cmd=? help_sub=Display_Help"
&opts="&opts hist_cmd=hist hist_sub=Display_Hist"
do &ARGS set_opts &AID &opts
entry &clk_err
if ("&clk_err"=="ARGS_ERR")
(
  do &ARGS get_error
  entry &clk_err

  print %ERROR "ERROR: Failed to set ARGS options:"
  print %ERROR "       '&clk_err'."

  enddo
)

Main_Loop:
(
  &clk_err=""

  ; If the history window is open, go ahead and update it.
  if (WIN.EXIST("clock_script_hist_window")==TRUE())
  (
    gosub Display_Hist SKIP_VIEW
  )

  print " "
  do &ARGS get_arg &AID [Clock.cmm] Enter command ('?' for help) >
  entry &choice
  print " "

  gosub wa_save_window_settings clock_script_main_window
  gosub wa_save_window_settings clock_script_hist_window

  &choice=string.lower("&choice")
  &choice_first_char=string.char("&choice", 0)

  if (&choice_first_char=='l')
  (
    gosub Open_Output_Log
  )
  else if ("&choice"=="x")
  (
    gosub Exit_ClockScript
  )
  else if ("&choice"=="wr")
  (
    gosub Reset_Window
  )
  else if ("&choice"=="1")
  (
    gosub Run_Subscript &clock_dir\ClockDriver.cmm
  )
  else if ("&choice"=="2")
  (
    gosub Run_Subscript &targ_dir\testclock.cmm
  )
  else if ("&choice"=="3")
  (
    gosub Run_Subscript &targ_dir\testpll.cmm
  )
  else
  (
    print %ERROR "ERROR: Invalid command '&choice'. Enter '?' for help."
  )

  goto Main_Loop
)

;-----------------------------------------------------------------------------
;
; Clock.cmm utility sub-routines:
;
;-----------------------------------------------------------------------------

Display_Clock_Main_Header:
(
  print " "
  print " "
  print "[-------------------------------- [&target] CLOCK MAIN MENU --------------------------------]"
  print " "

  return
)

Display_Help:
(
  ; If the history window is open, go ahead and update it.
  if (WIN.EXIST("clock_script_hist_window")==TRUE())
  (
    gosub Display_Hist SKIP_VIEW
  )

  print " "
  print "*** Commands ***"
  print " "
  print " 1             : Clock Driver Structures (ClockDriver.cmm)."
  print " 2             : Clocks (testclock.cmm)."
  print " 3             : PLLs (testpll.cmm)."
  print " "
  print " l, log [file] : Enable logging ('l' for short)."
  print " ?             : Display this help message."
  print " x             : Exit."
  print " wr [all]      : Reset [all] clock script window positions/sizes."
  print " "

  return
)

;
; Display history.
;
Display_Hist:
(
  local &skip_view
  entry &skip_view

  ; Display the help area if required.
  if ("&skip_view"=="")
  (
    if (win.exist("clock_script_hist_window")==FALSE())
    (
      local &x_start
      local &y_start
      local &x_len
      local &y_len

      winclear clock_script_hist_window

      ; Check if there are previously saved window settings.
      gosub wa_find_saved_window_settings clock_script_hist_window
      entry &x_start &y_start &x_len &y_len

      if (&x_start!=-1)
      (
        ; Use the previous window settings.
        winpos &x_start &y_start &x_len &y_len 0. 0. clock_script_hist_window
      )
      else
      (
        winpos 50% 0% 40% 50% 0. 0. clock_script_hist_window
      )
    )

    area.view CLOCK_MAIN_HIST
    wintop clock_script_hist_window
  )

  area.clear CLOCK_MAIN_HIST
  area.select CLOCK_MAIN_HIST

  ; Print the history entries.
  print " "
  print "[--- [&target] Clock.cmm history: ---]"
  print " "
  do &ARGS print_hist &AID

  ; Switch back to the main demo window.
  area.select CLOCK_MAIN_SCRIPT

  return
)

;
; Restores the main clock script window.
;
Restore_Main_Clock_Window:
(
  local &x_start
  local &y_start
  local &x_len
  local &y_len

  if (WIN.EXIST("clock_script_main_window")==FALSE())
  (
    ; Check if there are previously saved window settings.
    gosub wa_find_saved_window_settings clock_script_main_window
    entry &x_start &y_start &x_len &y_len

    if (&x_start!=-1)
    (
      ; Use the previous window settings.
      winpos &x_start &y_start &x_len &y_len 0. 0. clock_script_main_window
    )
    else
    (
      winpos 0. 0. 50% 95% 0. 0. clock_script_main_window
    )
  )

  ; Ensure the main window is viewed and selected for I/O.
  area.view CLOCK_MAIN_SCRIPT
  area.select CLOCK_MAIN_SCRIPT

  gosub Display_Clock_Main_Header

  return
)

;
; Exits the script.
;
Exit_ClockScript:
(
  local &noclear
  entry &noclear

  gosub wa_save_window_settings clock_script_hist_window
  gosub wa_save_window_settings clock_script_main_window

  winclear clock_script_hist_window
  if ("&noclear"=="")
  (
    winclear clock_script_main_window
  )

  area.close CLOCK_MAIN_SCRIPT  ; close any open log

  area.select ; select the default area
  print "Exited [&target] 'Clock.cmm'."
  enddo
)

;
; Runs a subscript and restores the main clock window upon its completion.
;
Run_Subscript:
(
  local &history_displayed_pre_subscript
  local &script
  local &cmd_line

  entry &script

  if (os.file(&script)==FALSE())
  (
    print %ERROR "ERROR: Missing '&script'."
    return
  )

  if (win.exist("clock_script_hist_window")==TRUE())
  (
    &history_displayed_pre_subscript=1
    winclear clock_script_hist_window
  )
  else
  (
    &history_displayed_pre_subscript=0
  )

  winclear clock_script_main_window

  ; Invoke script in subscript mode to avoid creating a new area window.
  (
    on ERROR gosub
    (
      &clk_err="Run_Subscript"
      print %ERROR "ERROR: Failed to launch '&script'."
      return
    )

    ; Forward the remainder of the command line.
    do &ARGS get_cmd_line &AID UNREAD
    entry %LINE &cmd_line
    do &ARGS reset_cmd_line &AID

    do &script super_script_area=CLOCK_MAIN_SCRIPT &cmd_line
  )

  if ("&clk_err"!="Run_Subscript")
  (
    if (&history_displayed_pre_subscript!=0)
    (
      gosub Display_Hist
    )

    gosub Restore_Main_Clock_Window
  )

  return
)

;
; Begins logging output to a file.
;
Open_Output_Log:
(
  ; Check if an output log is already open.
  if (&logging==0)
  (
    do &ARGS set_opts &AID nonempty_cmds=0
    do &ARGS get_arg &AID Enter log file [c:\temp\clock.log] >
    entry &log_filename
    do &ARGS set_opts &AID nonempty_cmds=1

    if ("&log_filename"=="")
    (
      &log_filename="c:\temp\clock.log"
    )
    print "Logging output to '&log_filename'."

    ; Open the output log.
    (
      ON ERROR gosub
      (
        print %ERROR "ERROR: Failed to open clock output log '&log_filename'."
        &clk_err="failed_to_open_output_log"
        return
      )
      &clk_err=""
      area.open CLOCK_MAIN_SCRIPT &log_filename
    )

    if ("&clk_err"!="failed_to_open_output_log")
    (
      &logging=1
    )
  )
  else
  (
    ; Does not currently support multiple output logs per single session.
    print "Already logging output to '&log_filename'. The log will close upon 'x' exit."
  )

  return
)

;
; Resets the clock script window(s).
;
Reset_Window:
(
  local &arg
  local &num_unread

  do &ARGS get_num_unread &AID
  entry &num_unread
  if (&num_unread!=0)
  (
    do &ARGS get_arg &AID
    entry &arg
    if ("&arg"=="all")
    (
      winclear clockdriver_hist_window
      winclear clockdriver_main_window
      winclear testclock_hist_window
      winclear testclock_main_window
      winclear testclock_help_window ; Clear window but don't need to delete settings.

      winclear testpll_main_window

      gosub wa_delete_saved_window_settings_ext clockdriver_hist_window ClockDriver.cmm
      gosub wa_delete_saved_window_settings_ext clockdriver_main_window ClockDriver.cmm
      gosub wa_delete_saved_window_settings_ext testclock_hist_window testclock.cmm
      gosub wa_delete_saved_window_settings_ext testclock_main_window testclock.cmm

      gosub wa_delete_saved_window_settings_ext testpll_main_window testpll.cmm
    )
  )

  winclear clock_script_hist_window
  winclear clock_script_main_window

  gosub wa_delete_saved_window_settings clock_script_main_window
  gosub wa_delete_saved_window_settings clock_script_hist_window

  gosub Restore_Main_Clock_Window RESET

  return
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Lauterbach T32 "Window/Area" Utility Subs:
;
;   bool    wa_does_area_exist ( string area )
;
;   bool    wa_try_area_create ( string area, [int cols, int rows] )
;
;   bool    wa_area_create_list (
;             int num, [string area, int cols, int rows], ... )
;
;   string  wa_get_substr_ws ( string src_str, int read_idx )
;
;   int[4]  wa_extract_stored_win_dim ( string file_name, string window_name )
;
;   bool    wa_save_window_settings ( string window_name, [flag print_error] )
;
;   int[4]  wa_find_saved_window_settings ( string window_name )
;
;   bool    wa_delete_saved_window_settings (
;             string window_name, [flag print_error] )
;
;   bool    wa_delete_saved_window_settings_ext (
;             string window, string script, [flag print_error] )
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; bool wa_does_area_exist ( string area )
;
; Returns non-zero if the given area currently exists.
;
; SIDE EFFECTS:  Selects the tested area if it exists, or the default area.
;
wa_does_area_exist:
(
  local &area_name
  entry &area_name

  ON ERROR gosub
  (
    ; Clear the error message.
    area.select
    print " "

    &clk_err="!"
    return
  )

  &clk_err=""
  area.select &area_name

  if ("&clk_err"=="")
  (
    return 1
  )
  else
  (
    return 0
  )
)

;
; bool wa_try_area_create ( string area, [int cols, int rows] )
;
; Attempts to create an area (see 'area.create'). Returns non-zero if the 
; area is successfully created. If the 'area.create' operation fails, the
; caller may run 'area.reset' then re-try creating the area. The 'rows' and
; 'cols' arguments can be bypassed by omitting both.
;
; T32 has a maximum number of concurrent areas (only 10 at the time of
; writing this sub). Unfortunately these areas can only be deleted in bulk
; with the highly destructive 'area.reset' (although some T32 documentation
; incorrectly states that 'area.close <area_name>' destroys the area, it
; doesn't--it only closes the area's output logging).
;
; Furthermore, areas aren't destroyed automatically upon script exit, so
; if a user were to run multiple scripts with multiple areas they could
; quickly exhaust the 10-area limit and then find that subsequent script
; launches always fail, potentially with confusing error messages. This
; utility sub is intended to mitigate this risk without having to immidiately
; resort to running a global 'area.reset' during script initialization.
;
wa_try_area_create:
(
  local &area_name
  local &cols
  local &rows

  entry &area_name &cols &rows

  ON ERROR gosub
  (
    &clk_err="!"
    return
  )

  &clk_err=""
  area.create &area_name &cols &rows

  if ("&clk_err"=="")
  (
    return 1
  )
  else
  (
    return 0
  )
)

;
; bool wa_area_create_list ( int num, [string area, int cols, int rows], ... )
;
; Attempts to create a list of areas. Will run the global 'area.reset' command
; upon the first failure, and return 0 upon the second failure. Otherwise
; returns non-zero upon success.
;
wa_area_create_list:
(
  local &success
  local &already_failed
  local &area_name
  local &cols
  local &rows
  local &area_idx
  local &num
  local &input_line
  local &line_idx
  local &area_list_line_idx

  entry %LINE &input_line

  ; Get the number of areas to create.
  gosub wa_get_substr_ws "&input_line" 0.
  entry &num &area_list_line_idx
  if ("&num"=="")
  (
    print %ERROR "ERROR: wa_area_create_list() detected invalid input: '&input_line'."
    return 0
  )

  &already_failed=0

wa_area_create_list_process_areas:

  ; Create each area.
  &area_idx=0
  &line_idx=&area_list_line_idx
  while (&area_idx<&num)
  (
    ; Read in the area information.
    gosub wa_get_substr_ws "&input_line" &line_idx
    entry &area_name &line_idx
    if ("&area_name"=="")
    (
      goto wa_area_create_list_too_few_args
    )
    gosub wa_get_substr_ws "&input_line" &line_idx
    entry &cols &line_idx
    if ("&cols"=="")
    (
      goto wa_area_create_list_too_few_args
    )
    gosub wa_get_substr_ws "&input_line" &line_idx
    entry &rows &line_idx
    if ("&rows"=="")
    (
      goto wa_area_create_list_too_few_args
    )

    ; Check if the row/col argument was bypassed.
    if (("&cols"==",")||("&rows"==","))
    (
      ; Apply a sanity check for row/col bypass.
      if (("&cols"!=",")||("&rows"!=","))
      (
        print %ERROR "ERROR: wa_area_create_list() detected invalid row/col settings for '&area_name'."
        print %ERROR "       Row/col must both be an integer or both be ',' (got row='&row', col='&col'). "
        return 0
      )

      &cols=""
      &rows=""
    )

    ; Attempt to create the area.
    gosub wa_try_area_create &area_name &cols &rows
    entry &success

    if (&success==0)
    (
      ; Already failed => infinite impending failures.
      if (&already_failed!=0)
      (
        print %ERROR %Decimal "ERROR: wa_area_create_list() failed to create &num areas."
        return 0
      )

      ; Delete all areas and try creating the area list once more.
      &already_failed=1
      area.reset
      winclear
      goto wa_area_create_list_process_areas
    )

    &area_idx=&area_idx+1
  )

  return 1

wa_area_create_list_too_few_args:

  print %ERROR "ERROR: wa_area_create_list() detected too few arguments (num_areas='&num')."
  return 0
)

;
; string wa_get_substr_ws ( string src_str, int read_idx )
;
; Returns the next sub-string word from a source string, or nothing if there
; is no such word. The words are split by spaces.
;
; Example: <gosub args_get_next_substr_ws "a  bc  de" 1.>
;          Returns "bc 5" (sans quotes).
;
wa_get_substr_ws:
(
  local &src_str
  local &src_len
  local &read_idx
  local &sub_str
  local &start_idx

  entry &src_str &read_idx

  if (&read_idx<0)
  (
    ; Negative read index--return empty string (and no index).
    return
  )

  &src_len=string.length(&src_str)

  ; Find the start of non-whitespace segment.
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)!=' ')
    (
      &start_idx=&read_idx
      goto wa_get_substr_ws_find_end_idx
    )

    &read_idx=&read_idx+1
  )

  ; No non-whitespace found--return empty string (and no index).
  return

wa_get_substr_ws_find_end_idx:

  ; Find the end of non-whitespace segment.
  &read_idx=&read_idx+1
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)==' ')
    (
      ; Cut out leading and trailing whitespace
      &sub_str=string.mid(&src_str, &start_idx, &read_idx-&start_idx)

      goto wa_get_substr_ws_return_substr
    )

    &read_idx=&read_idx+1
  )

  ; No trailing white-space found--cut out any leading whitespace.
  &sub_str=string.cut(&src_str, &start_idx)

wa_get_substr_ws_return_substr:

  return &sub_str &read_idx
)

;
; int[2] wa_extract_stored_win_dim ( string file_name,  string window_name )
;
; Returns the settings for the given window extracted from a previously
; stored file. Returns -1 if the window settings aren't found.
;
; Returns: {x_start, y_start, x_length, y_length}
;          (all values are in row or column units).
;
wa_extract_stored_win_dim:
(
  local &window_name
  local &file_name
  local &x_start
  local &y_start
  local &x_len
  local &y_len
  local &line_in
  local &idx

  entry &file_name &window_name

  &x_start=-1
  &y_start=-1
  &y_len=-1
  &x_start=-1

  ; Open the input file.
  (
    &clk_err=""
    ON ERROR gosub
    (
      print %ERROR "ERROR: wa_extract_stored_win_dim() failed to open '&file_name'."
      &clk_err="!"
      return
    )
    OPEN #1 &file_name /Read
  )

  if ("&clk_err"!="")
  (
    goto wa_extract_stored_win_dim_error
  )

  ; Scan the input file for "winpos ... window_name".
  WHILE TRUE()
  (
    READ #1 %line &line_in
    if (EOF()==TRUE())
    (
      goto wa_extract_stored_win_dim_error
    )
    &line_in=string.lower("&line_in")

    ; Search for 'winpos' line header and cut it out if found.
    &idx=string.scan("&line_in", "winpos", 0)
    if (&idx!=-1)
    (
      &line_in=string.cut("&line_in", &idx+6.)

      ; Search for the specified window name.
      if (string.scan("&line_in", "&window_name", 0)!=-1)
      (
        ; Extract the specified window's settings.
        gosub wa_get_substr_ws "&line_in" 0.
        entry &x_start &idx
        if ("&x_start"=="")
        (
          goto wa_extract_stored_win_dim_error
        )
        gosub wa_get_substr_ws "&line_in" &idx
        entry &y_start &idx
        if ("&y_start"=="")
        (
          goto wa_extract_stored_win_dim_error
        )
        gosub wa_get_substr_ws "&line_in" &idx
        entry &x_len &idx
        if ("&x_len"=="")
        (
          goto wa_extract_stored_win_dim_error
        )
        gosub wa_get_substr_ws "&line_in" &idx
        entry &y_len &idx
        if ("&y_len"=="")
        (
          goto wa_extract_stored_win_dim_error
        )

        CLOSE #1
        return &x_start &y_start &x_len &y_len
      )
    )
  )

wa_extract_stored_win_dim_error:

  CLOSE #1
  return -1 -1 -1 -1
)

;
; bool wa_save_window_settings ( string window_name, [flag print_error] )
;
; Saves a script's window configuration (position + size).
; See restore_window_settings() for the restore operation.
; Returns non-zero if the store operation succeeded.
;
; This is provided as a method to allow scripts to save/restore their window
; settings accross multiple script sessions. T32's "store <file> win" tool
; is insufficient to do this since it will only save/restore *all* T32 windows,
; not targeted windows.
;
wa_save_window_settings:
(
  local &file
  local &window_name
  local &script_name
  local &extn_less_dim_fname
  local &print_error

  &clk_err=""
  ON ERROR gosub
  (
    &clk_err="!"
    return
  )

  entry &window_name &print_error

  ; Store the full window configuration in a file under the temporary directory.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")
  &extn_less_dim_fname="__&(script_name)_&(window_name)_dim"
  &extn_less_dim_fname=string.replace("&extn_less_dim_fname", ".", "_", 0.)

  &file=os.ptd()
  &file="&(file)\&(extn_less_dim_fname).cmm"
  store &file win

  if ("&clk_err"=="")
  (
    return 1
  )
  else
  (
    if ("&print_error"!="")
    (
      print %ERROR "ERROR: wa_save_window_settings() failed to store settings for '&window_name'."
    )
    return 0
  )
)

;
; int[4] wa_find_saved_window_settings ( string window_name )
;
; Returns the settings for the given window extracted from a previously
; save. Returns -1 if the window settings aren't found.
;
; Returns: {x_start, y_start, x_length, y_length}
;          (all values are in row or column units).
;
; This is provided as a method to allow scripts to save/restore their window
; settings accross multiple script sessions. T32's "store <file> win" tool
; is insufficient to do this since it will only save/restore *all* T32 windows,
; not targeted windows.
;
wa_find_saved_window_settings:
(
  local &x_start
  local &y_start
  local &x_len
  local &y_len
  local &window_name
  local &file
  local &script_name
  local &extn_less_dim_fname
  local &first

  entry &window_name

  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")
  &extn_less_dim_fname="__&(script_name)_&(window_name)_dim"
  &extn_less_dim_fname=string.replace("&extn_less_dim_fname", ".", "_", 0.)

  &first=0.
  (
    ON ERROR gosub
    (
      var.newglobal char \&extn_less_dim_fname
      &first=1.
      return
    )

    var.assign \&extn_less_dim_fname = 0
  )

  &file=os.ptd()
  &file="&(file)\&(extn_less_dim_fname).cmm"

  if (&first!=0.)
  (
    ;
    ; Don't attempt to restore on the first time--instead delete the save.
    ; This prevents issues where a new T32 session is opened in a smaller
    ; window but the launched script maintains its old oversize dimensions.
    ;
    (
      ON ERROR continue
      del &file
    )
    return -1 -1 -1 -1
  )

  if (os.file.access("&file", "R")==FALSE())
  (
    return -1 -1 -1 -1
  )

  ; Search for previously saved settings for this window.
  gosub wa_extract_stored_win_dim &file &window_name
  entry &x_start &y_start &x_len &y_len

  return &x_start &y_start &x_len &y_len
)

;
; bool wa_delete_saved_window_settings ( string window_name, [flag print_error] )
;
; Deletes a window settings file.
;
wa_delete_saved_window_settings:
(
  local &success
  local &file
  local &script_name
  local &window_name
  local &extn_less_dim_fname
  local &print_error

  entry &window_name &print_error

  ; Check if the window's saved settings file exists.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")
  &extn_less_dim_fname="__&(script_name)_&(window_name)_dim"
  &extn_less_dim_fname=string.replace("&extn_less_dim_fname", ".", "_", 0.)

  &file=os.ptd()
  &file="&(file)\&(extn_less_dim_fname).cmm"
  if (os.file.access("&file", "W")==TRUE())
  (
    ; Delete the file.
    del &file
    &success=1
  )
  else
  (
    if ("&print_error"!="")
    (
      print %ERROR "ERROR: wa_delete_saved_window_settings() failed to delete window settings for '&window_name'."
    )
    &success=0
  )

  return &success
)

;
; bool wa_delete_saved_window_settings_ext ( string window, string script, [flag print_error] )
;
; Deletes a window settings file.
;
wa_delete_saved_window_settings_ext:
(
  local &success
  local &file
  local &script_name
  local &extn_less_dim_fname
  local &window_name
  local &print_error

  entry &window_name &script_name &print_error

  &extn_less_dim_fname="__&(script_name)_&(window_name)_dim"
  &extn_less_dim_fname=string.replace("&extn_less_dim_fname", ".", "_", 0.)

  &file=os.ptd()
  &file="&(file)\&(extn_less_dim_fname).cmm"
  if (os.file.access("&file", "W")==TRUE())
  (
    ; Delete the file.
    del &file
    &success=1
  )
  else
  (
    if ("&print_error"!="")
    (
      print %ERROR "ERROR: delete_saved_window_settings() failed to delete window settings for '&window_name'."
    )
    &success=0
  )

  return &success
)

;;;;;;;;;;;;; End of "Lauterbach T32 "Window/Area" Utility Subs" ;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Lauterbach T32 "ARGS Aquisition" Utility Subs:
;
;   string      __acquire_args_cmm ( string expected_args_dir )
;
;   int         __cmp_file_ts ( string path_a, string path_b )
;
;   int         __get_file_date_int ( string path, [flag ERR_FATAL] )
;
;   (int, int)  __str_get_next_dec_int ( int idx, string str_in)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; string __acquire_args_cmm ( string expected_args_dir )
;
; Returns a path to an 'args.cmm' script.
;
; Aborts the scripts upon any failure.
;
__acquire_args_cmm:
(
  local &args_path
  local &server_args_path
  local &expected_args_dir

  entry &expected_args_dir

  ON ERROR gosub
  (
    area.select
    area.view
    print " "
    print %ERROR "Caught error in '__acquire_args_cmm'. Failed to fulfill 'args.cmm' dependency."
    enddo
  )

  &args_path="&expected_args_dir\args.cmm"

  ; Check if the expected 'args.cmm' file exists.
  if (os.file(&args_path)==FALSE())
  (
    ; The expected 'args.cmm' is missing. Attempt to copy it from the server.
    &server_args_path="\\ben\corebsp_labdata_0001\sysdrv\args\args.cmm"

    &args_path=os.ptd()
    &args_path="&args_path\__temp_args.cmm"

    ; Check if a local temp server copy already exists.
    if (os.file(&args_path)==FALSE())
    (
      ; The local temp copy does not exist--attempt to create it.
      if (os.file(&server_args_path)==FALSE())
      (
        area.select
        area.view
        print " "
        print %ERROR "ERROR: '&expected_args_dir\args.cmm', '&args_path\__temp_args.cmm' and"
        print %ERROR "       '&server_args_path' do not exist. Missing required 'args.cmm' file."
        enddo
      )
      if (os.file.access("&server_args_path", "R")==FALSE())
      (
        area.select
        area.view
        print " "
        print %ERROR "ERROR: '&expected_args_dir\args.cmm' and '&args_path\__temp_args.cmm' do not exist and"
        print %ERROR "       '&server_args_path' is not readable. Missing required 'args.cmm' file."
        enddo
      )

      copy &server_args_path &args_path
      if (os.file(&args_path)==FALSE())
      (
        ; Just try to use the server version if for some reason the copy to the
        ; T32 temp directory failed.
        &args_path="&server_args_path"
      )
    )
    else
    (
      ; The local temp 'args.cmm' exists. Check if it matches the server version.
      ; If the server version isn't found, the temp copy is used.
      if ((os.file(&server_args_path)==TRUE())&&(os.file.access("&server_args_path", "R")==TRUE()))
      (
        local &args_cmp_ret

        gosub __cmp_file_ts &server_args_path &args_path
        entry &args_cmp_ret

        if (&args_cmp_ret>0.)
        (
          ; The server copy is newer than the local temp copy--attempt to refresh.
          del &args_path
          copy &server_args_path &args_path

          if (os.file(&args_path)==FALSE())
          (
            ; Just try to use the server version if for some reason the copy to the
            ; T32 temp directory failed.
            &args_path="&server_args_path"
          )
        )
      )
    )
  )

  return &args_path
)

;
; int __cmp_file_ts ( string path_a, string path_b )
;
; Returns positive number if the first file is newer than the second file,
; else returns zero if the two files have identical timestamps, else returns
; a negative number. Assumes that both files exist.
;
; Aborts the scripts upon any failure.
;
__cmp_file_ts:
(
  local &path_a
  local &path_b

  entry &path_a &path_b

  gosub __get_file_date_int &path_a ERR_FATAL
  entry &path_a

  gosub __get_file_date_int &path_b ERR_FATAL
  entry &path_b

  &path_a=(&path_a-&path_b)
  return &path_a
)

;
; int __get_file_date_int ( string path, [flag ERR_FATAL] )
;
; Returns an integer representation of the given file's timestamp data string
; (see 'os.file.date()').
;
; Upon failure, if the 'ERR_FATAL' flag is given an error message is printed
; and the script is aborted, else -1 is returned.
;
; NOTES:  This subroutine is greatly complicated by the fact that (at the time
;         of its authoring) Lauterbach does not provide a way to obtain a
;         1971-based file time-stamp integer, instead only providing methods
;         get various file date strings of various formats which are not even
;         consistant with the given Lauterbach documentation!
;
__get_file_date_int:
(
  local &year
  local &month
  local &day
  local &date_int
  local &date_str
  local &hour_min_sec_am_pm_str
  local &get_file_date_int_err

  local &path
  local &err_fatal

  entry &path &err_fatal

  &get_file_date_int_err=""
  ON ERROR gosub
  (
    if ("&err_fatal"=="")
    (
      &get_file_date_int_err="!"
      return
    )
    else
    (
      ; Abort if fatal error flag was given.
      area.select
      area.view
      print " "
      print %ERROR "Caught fatal error in __get_file_date_int(), file = '&path'."
      enddo
    )
  )

  ;
  ; Don't use raw 'os.file.date()' as it's format doesn't match Lauterbach's
  ; documentation which indicates that it might be regionalized. Instead use a
  ; combination of the two date string formats, in order to get the AM/PM
  ; included in the time string, but with a more reliable "year/month/day"
  ; format for the date string.
  ;
  &hour_min_sec_am_pm_str=os.file.date(&path)
  gosub __str_get_next_dec_int 0. "&hour_min_sec_am_pm_str"
  entry &year &date_idx
  gosub __str_get_next_dec_int &date_idx "&hour_min_sec_am_pm_str"
  entry &year &date_idx
  gosub __str_get_next_dec_int &date_idx "&hour_min_sec_am_pm_str"
  entry &year &date_idx
  &hour_min_sec_am_pm_str=string.cut("&hour_min_sec_am_pm_str", &date_idx)
  &hour_min_sec_am_pm_str=string.trim("&hour_min_sec_am_pm_str")

  &date_str=os.file.date2(&path)
  &date_str="&date_str &hour_min_sec_am_pm_str"
  &date_str=string.trim("&date_str")

  if ("&get_file_date_int_err"=="")
  (
    ; Determine the 1971 year second-offset (assumes each month is <= 31 days).
    gosub __str_get_next_dec_int 0. "&date_str"
    entry &year &date_idx
    &date_int=((&year-1971.)*32140800.)

    if ("&get_file_date_int_err"=="")
    (
      ; Read the month (assumes each month is <= 31 days).
      gosub __str_get_next_dec_int &date_idx "&date_str"
      entry &month &date_idx
      &date_int=(&date_int+(&month*2678400.))

      if ("&get_file_date_int_err"=="")
      (
        ; Read the day.
        gosub __str_get_next_dec_int &date_idx "&date_str"
        entry &day &date_idx
        &date_int=(&date_int+(&day*86400.))

        if ("&get_file_date_int_err"=="")
        (
          ; Read the hour/minute/second/AM-PM.
          local &hour
          local &min
          local &sec
          local &am_pm_str
          gosub __str_get_next_dec_int &date_idx "&date_str"
          entry &hour &date_idx

          if ("&get_file_date_int_err"=="")
          (
            gosub __str_get_next_dec_int &date_idx "&date_str"
            entry &min &date_idx

            if ("&get_file_date_int_err"=="")
            (
              gosub __str_get_next_dec_int &date_idx "&date_str"
              entry &sec &date_idx

              if ("&get_file_date_int_err"=="")
              (
                &am_pm_str=string.cut("&date_str", &date_idx)
                &am_pm_str=string.trim("&am_pm_str")
                &am_pm_str=string.lower("&am_pm_str")
                if ("&am_pm_str"=="pm")
                (
                  &hour=(&hour+12.)
                )

                ; Calculate the final date integer and return it.
                &date_int=(&date_int+(&hour*3600.)+(&min*60.)+&sec)
                if ("&get_file_date_int_err"=="")
                (
                  return &date_int
                )
              )
            )
          )
        )
      )
    )
  )

  ; Otherwise return an error code.
  return -1.
)

;
; (int, int) __str_get_next_dec_int ( int idx, string str_in )
;
; Returns the next integer value extracted from the given string and start
; index along with the next string read index. The integer value is derived
; from the string's first digit sequence which is treated as a decimal
; formatted number. Returns an empty string if no such digit section is found.
;
; NOTES: The 'str_in' input should be wrapped in double quotes.
;
__str_get_next_dec_int:
(
  local &int_val
  local &int_start_idx
  local &char
  local &len

  local &idx
  local &str_in

  entry &idx &str_in

  &int_start_idx=""
  &char=1.
  while (&char>0.)
  (
    &char=string.char(&str_in, &idx)

    if ("&int_start_idx"=="")
    (
      if ((&char>='0')&&(&char<='9'))
      (
        &int_start_idx=&idx
      )
    )
    else
    (
      if ((&char<'0')||(&char>'9'))
      (
        &len=(&idx-&int_start_idx)
        &int_val=string.mid(&str_in, &int_start_idx, &len)
        &int_val="&(int_val)."
        &idx=(&idx+1.)

        return &int_val &idx
      )
    )

    &idx=&idx+1.
  )

  return ""
)

;;;;;;;;;;; End of "Lauterbach T32 "ARGS Aquisition" Utility Subs" ;;;;;;;;;;;

