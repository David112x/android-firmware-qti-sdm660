/****************************************************************************
 QUALCOMM Proprietary Design Data
 Copyright (c) 2015, Qualcomm Technologies Incorporated. All rights reserved.
 ****************************************************************************/
/*==============================================================================
                                EDIT HISTORY

$Header: //components/rel/boot.xf/1.4/QcomPkg/Sdm660Pkg/Library/DSFTargetLib/boot/target/SDM630_660/sdi/ddrss_init_sdi.c#11 $
$DateTime: 2018/09/27 20:55:21 $
$Author: pwbldsvc $
================================================================================
when       who          what, where, why
--------   ---          --------------------------------------------------------
05/04/14   arindamm     First edit history header. Add new entries at top.
================================================================================*/

#include "ddrss_init_sdi.h"

//================================================================================================//
// DDR Initialization
//================================================================================================//
boolean HAL_DDR_Init_sdi (DDR_STRUCT *ddr,
                      DDR_CHANNEL channel, 
                      DDR_CHIPSELECT chip_select,
                      uint32 clk_freq_khz)
{
   DDR_CHANNEL ch_1hot = DDR_CH_NONE;
   uint32 reg_offset_shke;
   uint8 ch = 0;

   // Store our initial DDR frequency
   ddr->misc.current_clk_in_kHz = clk_freq_khz;
   ddr->misc.new_clk_in_kHz = clk_freq_khz;
   
   if (ddr->misc.target_silicon == 1)
   {
        //Enabling clocks for successful CSR access
        MCCC_Clk_CBCR_Enable_sdi(ddr, channel);
   }

   // BIMC one-time settings
   BIMC_Config_sdi(ddr);

   if (ddr->misc.target_silicon == 1)
   {
        // Only configure Phy & clock controller on silicon --- they are not included in the emulation build
        // DDR PHY and CC one-time settings
        DDR_PHY_CC_Config_sdi(ddr);
   }
   else
   {
        // Byte swizzling for Nazgul emulation is different than on silicon.
        //    Fix that config for emulation.
        HWIO_OUTX(REG_OFFSET_DPE(0), DPE_CONFIG_DQ_MAP, 0x00000000);
        HWIO_OUTX(REG_OFFSET_DPE(1), DPE_CONFIG_DQ_MAP, 0x00000000);
   }

   BIMC_Pre_Init_Setup_sdi (ddr, channel, chip_select);
    
   if (ddr->misc.target_silicon == 1)
   {
        // Don't configure MCCC or Phy & clock controller on emulation --- they are not included in the HW build
        // Initialize the MCCC
        MCCC_Init_sdi(ddr, channel);

        //Initialize the gasket
		DDR_CC_MCCC_Config_sdi(ddr);

        DDR_PHY_CC_init_sdi (ddr, channel);  //workaround 19.2MHz SW switching hang issue.
   }

   // For LPDDR4, deassert reset pin before initialization
   if (ddr->detected_ddr_device[0].device_type == DDR_TYPE_LPDDR4)
   {
      HWIO_OUTX (DDR_PHY_SS_BASE + SEQ_DDR_SS_DDR_REG_DDR_SS_REGS_OFFSET, DDR_SS_REGS_RESET_CMD, 1);
   }

   ddr_mpm_config_ebi1_freeze_io_sdi(FALSE);

   for (ch = 0; ch < NUM_CH; ch++)
   {
      ch_1hot = CH_1HOT(ch);
      reg_offset_shke = REG_OFFSET_SHKE(ch);

      if ((channel >> ch) & 0x1)
      {
         // If it is a watchdog reset we just need to do a warm-bootup . 
         // 'WDOG_SELF_RFSH' when set indicates that the memory controller is currently in self refresh due to a watchdog reset event
         // and requires a manual 'EXIT_SELF_REFRESH' trigger to exit from the forced self refresh state.
         if ( (HWIO_INXF (reg_offset_shke, SHKE_DRAM_STATUS, WDOG_SELF_RFSH) == 1) ) {
            // fix done for proper self refresh exit in STARLORD
            HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, RANK0_EN, 1);
            HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, RANK0_INITCOMPLETE, 1);
            if (ddr->detected_ddr_device[ch].populated_chipselect & DDR_CS1)
            {
              HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, RANK1_EN, 1);
              HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, RANK1_INITCOMPLETE, 1);
            }
            //ADDED FOR STARLORD 
            // Auto refresh and HW activity based self refresh
            if (chip_select & DDR_CS0) {
               HWIO_OUTXF (reg_offset_shke, SHKE_AUTO_REFRESH_CNTL, AUTO_RFSH_ENABLE_RANK0,    1);
            }
            if (chip_select & DDR_CS1) {
               HWIO_OUTXF (reg_offset_shke, SHKE_AUTO_REFRESH_CNTL, AUTO_RFSH_ENABLE_RANK1,    1);
            }

             // Exit from self-refresh on the rank
             BIMC_Exit_Self_Refresh_sdi (ddr, ch_1hot, (DDR_CHIPSELECT)ddr->detected_ddr_device[ch].populated_chipselect);
         }    
         else 
         {    
             // If not a watchdog reset, we need to do a cold boot style init     
             BIMC_Memory_Device_Init_sdi (ddr, ch_1hot, (DDR_CHIPSELECT)ddr->detected_ddr_device[ch].populated_chipselect);   
         }
         BIMC_ZQ_Calibration_sdi (ddr, ch_1hot, (DDR_CHIPSELECT)ddr->detected_ddr_device[ch].populated_chipselect);
         
         // Set up the DDR device latency and enable flags
         BIMC_DDR_Access_Enable_sdi (ddr, ch_1hot, (DDR_CHIPSELECT)ddr->detected_ddr_device[ch].populated_chipselect);
         
         // Set up the BIMC to operate with the known address range
         BIMC_Post_Init_Setup_Warm_sdi (ddr, ch_1hot, (DDR_CHIPSELECT)ddr->detected_ddr_device[ch].populated_chipselect);
      }
   }
   
   return TRUE;
}



/*==============================================================================
                                  DATA
==============================================================================*/
uint32 bimc_global0_config_sdi[][2] =
{
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_CAPHY_CLK_EXTEND, 0), 0x00000004},
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_CAPHY_CLK_EXTEND, 1), 0x00000004},
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_CLK_PERIOD, 0), 0x10000271},
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_CLK_PERIOD, 1), 0x10000271},
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_DDRCC_CLK_EXTEND, 0), 0x00000004},
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_DDRCC_CLK_EXTEND, 1), 0x00000004},
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_DQPHY_CLK_EXTEND, 0), 0x00000004},
  {HWIO_ADDRXI((SEQ_BIMC_GLOBAL0_OFFSET), BIMC_MISC_GLOBAL_CSR_DDR_CHn_DQPHY_CLK_EXTEND, 1), 0x00000004},
  {0x0, 0x0}
};

uint32 bimc_scmo_config_sdi[][2] =
{
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_CMD_OPT_CFG0), 0x07021110},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_CMD_OPT_CFG1), 0x010A0B1F},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_CMD_OPT_CFG2), 0x00000804},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_CMD_OPT_CFG3), 0x0004001F},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_CMD_OPT_CFG4), 0x00000011},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_FLUSH_CFG), 0x80320F08},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_GLOBAL_MON_CFG), 0x00000043},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_RCH_BKPR_CFG), 0x30307070},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_RCH_SELECT), 0x00000020},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SCMO_OFFSET), SCMO_CFG_WCH_BUF_CFG), 0x00000001},
  {0x0, 0x0}
};

uint32 bimc_dpe_config_sdi[][2] =
{
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CGC_CTRL), 0x0003FFFF},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_0), 0x23040510},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_10), 0x00021022},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_11), 0x0A000030},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_12), 0x0000FFFA},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_2), 0x82020000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_3), 0x00000011},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_5), 0x0FFFFFFF},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_6), 0x00000050},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_8), 0x03070307},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_9), 0x00101010},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_CONFIG_DQ_MAP), 0x00003100},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_0), 0x000031A4},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_1), 0x60B440B4},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_10), 0x27532753},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_11), 0x504B504B},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_12), 0x504B504B},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_13), 0x603B6000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_14), 0x01002030},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_15), 0x000049CC},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_16), 0x0008200E},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_2), 0x40644064},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_24), 0x00000020},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_25), 0x3500124B},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_26), 0x00001908},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_27), 0x00000008},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_29), 0x00020008},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_3), 0x07080000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_30), 0x0080012C},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_31), 0x000F0023},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_32), 0x00100000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_33), 0x0010000B},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_34), 0x000009C4},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_35), 0x00000008},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_4), 0x0000804B},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_5), 0x40D240B4},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_6), 0x0190404B},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_9), 0x00003096},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_LP4_ODTLON_CNTL), 0x00000004},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_LP4_ODT_OFF_CNTL), 0x0023000F},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_DRAM_TIMING_LP4_ODT_ON_CNTL), 0x0023000F},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_ELEVATE_PRI_RD), 0x40404000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_ELEVATE_PRI_WR), 0x80808000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_MASKED_WRITE_CNTL), 0x000000F8},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_ODT_1PS_THRESHOLD_CTL), 0x0010044C},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_OPT_CTRL_1), 0x00001100},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_PAD_PASSIVATION_1PS_THRESHOLD_CTL), 0x0010044C}, //was 0x00100000, turn on passivation > 1GHz: 0x0010044C
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_PHY_RDDATA_EN_1PS_THRESHOLD_CTL), 0x0010044C},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_PWR_CTRL_0), 0x00010060},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_RANKID_EARLY_OFFSET_CNTL), 0x00200723},//0x00260023
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_RANKID_OFFSET_CNTL), 0x14400008},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_RANK_ID_1PS_THRESHOLD_CTL), 0x00100320},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_RCW_CTRL), 0x00010100},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_RD_POSTAMBLE_1PS_THRESHOLD_CTL), 0x00100000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_RD_PREAMBLE_1PS_THRESHOLD_CTL), 0x00100320},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_TIMER_0), 0x03633063},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_TIMER_1), 0x00007104},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_TIMER_2), 0x00100078},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_TIMER_3), 0x0000046B},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_TIMER_5), 0x03300303},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_WR_POSTAMBLE_1PS_THRESHOLD_CTL), 0x00100271},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_DPE_OFFSET), DPE_WR_PREAMBLE_1PS_THRESHOLD_CTL), 0x00100000},

  {0x0, 0x0}
};

uint32 bimc_shke_config_sdi[][2] =
{
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_AUTO_REFRESH_CNTL), 0x00000049},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_AUTO_REFRESH_CNTL_1), 0x00000049},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_AUTO_REFRESH_CNTL_2), 0x00080000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_CONFIG), 0x00148001},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_PERIODIC_MRR), 0x00404000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_PERIODIC_ZQCAL), 0x00000800},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_SAFE_CTRL), 0x00000001},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_SELF_REFRESH_CNTL), 0x00032000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_MODE_CTRL), 0x00000000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK0_ZQL_END), 0x000001C2},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK0_ZQL_MASK), 0x000001FF},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK0_ZQL_START), 0x0000015E},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK0_ZQS_MASK), 0x000001FF},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK1_ZQL_END), 0x000001C2},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK1_ZQL_MASK), 0x000001FF},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK1_ZQL_START), 0x0000015E},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK1_ZQS_MASK), 0x000001FF},
  {0x0, 0x0}
};

uint32 bimc_shke_config_ch_diff_sdi[][2] =
{
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_PERIODIC_ZQCAL_1), 0x00030034},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK0_ZQS_END), 0x0000003C},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK0_ZQS_START), 0x00000000},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK1_ZQS_END), 0x0000008C},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR0_SHKE_OFFSET), SHKE_ZQ_SYNCED_RANK1_ZQS_START), 0x00000050},
  {HWIO_ADDRX((SEQ_BIMC_BIMC_S_DDR1_SHKE_OFFSET), SHKE_PERIODIC_ZQCAL_1), 0x00020034},
  {0x0, 0x0}
};

uint32 ddr_cc_mccc_regs_config_sdi[][2] =
{
  //{HWIO_ADDRX((SEQ_DDR_CC_MCCC_DDRCC_MCCC_OFFSET), DDR_CC_MCCC_DDRCC_MCCC_TOP_CFG), 0xF8336619},
  {0x0, 0x0}
};

uint32 ddr_phy_dq_config_sdi[][2] =
{
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_TOP_CTRL_0_CFG), 0x0001C290}, 
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_0_CFG), 0x00000001}, // old value:  0x00131001 0x00000001.  I think this should be DQS Pull down should also be turned on [bit 9:8]

   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_1_CFG), 0x00007700},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_2_CFG), 0x00000011},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_3_CFG), 0x026008FE},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_4_CFG), 0x026008FE},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_VREF_CFG), 0x1F1F0007},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CAL_CFG), 0x00000200},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCS_DQ_CFG), 0x80000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCS_DQS_CFG), 0x80000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_COMP_AUTO_OFF_CFG), 0x00000033},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_TIMERS_CFG), 0x10000013},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_PNCNT_INIT_CFG), 0x00001010},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_CTRL_CFG), 0xCE038080},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWRLVL_MODE_CFG), 0x00000001},    
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWRLVL_TOP_CFG), 0x00200004},     
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWR_MODE_CFG), 0x00000031},       
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWR_TOP_CFG), 0x04200004},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRD_TOP_CFG), 0x00200004},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRDT2_I0_MODE_CFG), 0x00000071},   
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRDT2_I0_TOP_CFG), 0x00200004},
	//{HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRCW_TOP_CFG), 0x02A00004},
		{HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRCW_TOP_CFG), 0x02200004}, // Set LOAD = 0 
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCMSTR_CTL_CFG), 0x0000022D},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMLDO_TOP_CFG), 0x00000068},
 //  {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMIO_PAD_OE_CFG), 0x00090000},         //
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMIO_PAD_MODE_CFG), 0x003FF800},       //
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_LUT0_CFG), 0x714157D0 }, //0x714294D0 
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_LUT1_CFG),0x0B384DDC }, //0x083850D5
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_HI_LUT0_CFG), 0x02030407}, //0x02030507
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_HI_LUT1_CFG), 0x01010101},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMRX_USER_CFG), 0x09100191},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMRX_TEST_CFG), 0x0000000C},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_LO_CFG), 0x0000A522}, // old value : 0x0000B6DA
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI_CFG), 0x011EC080},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI2_CFG), 0x00000009},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_UPDATE_INTF_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CDCEXT_WR_0_CTL_CFG), 0x0003E1F8 }, 
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CDCEXT_RD_0_CTL_CFG), 0x0000000A}, //old value 0x0002E0B8
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CDCEXT_RDT2_0_CTL_CFG), 0x6018},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_WRLVLEXT_CTL_0_CFG), 0x43424342 },   
   {0x0, 0x0} 
};

uint32 ddr_phy_ca_config_sdi[][2] =
{

   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_TOP_CTRL_0_CFG), 0x0001C290}, // old value : 0x0001C290
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_0_CFG), 0x00000001},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CAL_CFG), 0x00000200},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_1_CFG), 0x00007700},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_2_CFG), 0x00000011},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_3_CFG), 0x0020087E},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_4_CFG), 0x0020087E},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCS_DQ_CFG), 0x80000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCS_DQS_CFG), 0x80000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_COMP_AUTO_OFF_CFG), 0x00000032},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_TIMERS_CFG), 0x10000013},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_PNCNT_INIT_CFG), 0x00001010},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_IOCTLR_CTRL_CFG), 0xCE038080},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWRLVL_MODE_CFG), 0x00000001},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWRLVL_TOP_CFG), 0x00200004},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWR_CTL_CFG), 0x1EF4E138},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCWR_TOP_CFG), 0x00200004},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRD_CTL_CFG), 0x1EF4E138},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRD_TOP_CFG), 0x00200004},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRDT2_I0_CTL_CFG), 0x31866198},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRDT2_I0_TOP_CFG), 0x00200004},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRCW_CTL_CFG), 0x31866198},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCRCW_TOP_CFG), 0x02A00004},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMCDCMSTR_CTL_CFG), 0x0000022D},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE0_PBIT_CTL_DQ_0_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE1_PBIT_CTL_DQ_1_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE2_PBIT_CTL_DQ_2_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE3_PBIT_CTL_DQ_3_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE4_PBIT_CTL_DQ_4_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE5_PBIT_CTL_DQ_5_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE6_PBIT_CTL_DQ_6_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE7_PBIT_CTL_DQ_7_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE8_PBIT_CTL_DQ_8_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE9_PBIT_CTL_DQ_9_RXTX_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMSLICE10_PBIT_CTL_DQS_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMLDO_TOP_CFG), 0x00000068},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMIO_PAD_OE_CFG), 0x00090000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMIO_PAD_MODE_CFG), 0x003FF800},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMHUB_TOP_1_CFG), 0x02020202},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_LUT0_CFG), 0x714157D0 }, //0x714294D0 
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_LUT1_CFG),0x0B384DDC }, //0x083850D5
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_HI_LUT0_CFG), 0x02030407}, //0x02030507
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_HI_LUT1_CFG), 0x01010101}, 
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMRX_USER_CFG), 0x09100191},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CMRX_TEST_CFG), 0x0000000C},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CDCEXT_WR_0_CTL_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CDCEXT_RD_0_CTL_CFG), 0x0002E0B8},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CDCEXT_RCW_0_CTL_CFG), 0x31866198},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_CDCEXT_RDT2_0_CTL_CFG), 0x31866198},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_WRLVLEXT_CTL_0_CFG), 0x43024302},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_UPDATE_INTF_CFG), 0x00000000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_LO_CFG), 0x000A522},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI_CFG), 0x011EC000},
   {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI2_CFG), 0x00000009},
   {0x0, 0x0} 
};

uint32 ddr_cc_config_sdi[][2] =
{
   {HWIO_ADDRX(0, DDR_CC_DDRCC_TOP_CTRL_CFG), 0x00A04C00},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_PLLCTRL_CLK_SWITCH_CTRL), 0x49BE68A4},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_DLLCTRL_CTRL), 0x0009F900},
   //{HWIO_ADDRX(0, DDR_CC_DDRCC_PLLCTRL_CLK_SWITCH_CTRL), 0x499E68A4},
   //{HWIO_ADDRX(0, DDR_CC_DDRCC_DLLCTRL_CTRL), 0x00090900},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_TXPHYCTRL_CTRL), 0x4518CC64},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_TX0_USER_CTRL), 0x00000000},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_TX1_USER_CTRL), 0x00000000},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_IE_TRIM), 0x00000004},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_IP_TRIM), 0x00000004},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_IPTAT_TRIM), 0x00000007},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_CLKBUFLR_EN), 0x00000001},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_RESETSM_CNTRL), 0x00000030},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_RESETSM_CNTRL2), 0x00000020},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_KVCO_DIV_REF1), 0x0000005E},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_VCO_DIV_REF1), 0x0000005E},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_PLLLOCK_CMP_EN), 0x00000002},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_PLL_TXCLK_EN), 0x00000001},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_PLL_CRCTRL), 0x00000012},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_CP_SET_CUR), 0x00000009},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_PLL_ICP_SET), 0x00000024},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_PLL_LPF1), 0x0000001B},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL0_PLL_BANDGAP), 0x00000003},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_IE_TRIM), 0x00000004},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_IP_TRIM), 0x00000004},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_IPTAT_TRIM), 0x00000007},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_CLKBUFLR_EN), 0x00000001},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_RESETSM_CNTRL), 0x00000030},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_RESETSM_CNTRL2), 0x00000020},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_KVCO_DIV_REF1), 0x0000005E},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_VCO_DIV_REF1), 0x0000005E},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_PLLLOCK_CMP_EN), 0x00000002},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_PLL_TXCLK_EN), 0x00000001},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_PLL_CRCTRL), 0x00000012},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_CP_SET_CUR), 0x00000009},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_PLL_ICP_SET), 0x00000024},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_PLL_LPF1), 0x0000001B},
   {HWIO_ADDRX(0, DDR_CC_DDRCC_SDPLL1_PLL_BANDGAP), 0x00000003},
   {0x0, 0x0} 
/*
	{HWIO_ADDRX(0, DDR_CC_DDRCC_TOP_CTRL_CFG), 0x01202510},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLLCTRL_GCC_CTRL), 0x00001088},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLLCTRL_CLK_SWITCH_CTRL), 0x499E69A4},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLLCTRL_CTRL), 0x7C001183},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_DLLCTRL_CTRL), 0x00090900},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_TXPHYCTRL_CTRL), 0x4518CC64},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_TX0_USER_CTRL), 0x00000000},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_TX1_USER_CTRL), 0x00000000},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PHYDLL0_COARSE_CFG1), 0x00000100},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PHYDLL0_ANALOG_CFG1), 0x00000201},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PHYDLL1_COARSE_CFG1), 0x00000100},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PHYDLL1_ANALOG_CFG1), 0x00000201},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_QLINKPLL0_DEC_FRAC_MUXES), 0x0000000F},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_QLINKPLL0_PLL_LOCK_DELAY), 0x00000006},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_QLINKPLL1_DEC_FRAC_MUXES), 0x0000000F},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_QLINKPLL1_PLL_LOCK_DELAY), 0x00000006},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_FPM_PRFS_0_PWRS_1_LO_CFG), 0x00002492},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_FPM_PRFS_0_PWRS_1_HI_CFG), 0x001EC080},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_FPM_PRFS_LUT0_CFG), 0xE283D391},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_FPM_PRFS_LUT1_CFG), 0xEC0C4181},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_FPM_PRFS_HI_LUT0_CFG), 0x01020203},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_FPM_PRFS_HI_LUT1_CFG), 0x00010101},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_0_CFG), 0x0000000E},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_1_CFG), 0x0000003F},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_2_CFG), 0x0000000A},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_3_CFG), 0x0000000A},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_4_CFG), 0x0000000A},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_5_CFG), 0x00000040},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_6_CFG), 0x00000040},
	{HWIO_ADDRX(0, DDR_CC_DDRCC_PLL0EXT_PERF0_CTL_7_CFG), 0x00000039},

   {0x0, 0x0}
   */
};

/*DDR_PHY SAFE mode settings*/
uint32 ddr_phy_dq_delta_config_sdi[][2] =
{
    {0x0, 0x0}
};

uint32 ddr_phy_ca_delta_config_sdi[][2] = 
{
    {0x0, 0x0}
};
uint32 ddr_cc_delta_config_sdi[][2] =
{
    {0x0, 0x0}
};

/*DDR_PHY LPDDR4x setting*/
uint32 ddr_phy_dq_lp4x_config_sdi[][2]  = 
{
    {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_0_CFG), 0x00131001}, // bit 20 selects LPDDR4x
	{HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_VREF_CFG), 0x18180005},
	{HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_LO_CFG), 0x4920A492},
    {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI_CFG), 0x011EC080},
	{HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI2_CFG), 0x00000000},
    {0x0, 0x0}
};
uint32 ddr_phy_dq_starlord_config_sdi[][2]  = 
{
    {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_0_CFG), 0x00131001}, // bit 20 selects LPDDR4x
    {0x0, 0x0}
};
uint32 ddr_phy_ca_lp4x_config_sdi[][2]  = 
{
    {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_0_CFG), 0x00131001}, // bit 20 selects LPDDR4x
	{HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_LO_CFG), 0x000A492},
    {HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI_CFG), 0x011EC080},
	{HWIO_ADDRX(0, DDR_PHY_DDRPHY_FPM_PRFS_0_PWRS_1_HI2_CFG), 0x00000000},
    {0x0, 0x0}
};
uint32 ddr_phy_ca_starlord_config_sdi[][2]  = 
{
    {HWIO_ADDRX(0, DDR_PHY_DDRPHY_PAD_CNTL_0_CFG), 0x00131001}, // bit 20 selects LPDDR4x
    {0x0, 0x0}
};

uint32 mccc_regs_config_sdi[][2] =
{
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND0_CFG0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND0_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND0_UPPER_FREQ_THRESHOLD), 0x0000CB70},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND1_CFG0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND1_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND1_UPPER_FREQ_THRESHOLD), 0x00000724},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND2_CFG0), 0x00001111},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND2_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND2_UPPER_FREQ_THRESHOLD), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND3_CFG0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND3_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND3_UPPER_FREQ_THRESHOLD), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND4_CFG0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND4_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND4_UPPER_FREQ_THRESHOLD), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND5_CFG0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_BAND5_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_CLK_PERIOD), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_CLOCK_GATE_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_DEBUG_BUS_SELECT), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_FREQ_SWITCH_DISABLE), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_FREQ_SWITCH_FSM_CFG), 0x0000000F},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_FREQ_SWITCH_STATE_EXIT_COND), 0x3000FFFE},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_FREQ_SWITCH_UPDATE), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_FSC_STATE_APPEND_TIMER_SEL), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_FSC_STATE_PREPEND_TIMER_SEL), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_FSC_STATE_TIMER_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_MISC_FEATURE_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK0_RX_ENABLE_CFG), 0x40000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK1_RX_CLKON_CFG), 0x40000011},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK2_GFCM_SWITCH_CFG), 0x70000088},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK3_SSP_CFG), 0x70000020},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK4_RX_DISABLE_CFG), 0x70000033},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK_DEP_VEC_CFG0), 0x08040100},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK_DEP_VEC_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK_DEP_VEC_CFG2), 0x00000008},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK_MASK_CFG0), 0x00010117},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TASK_MASK_CFG1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_MCCC_REGS_OFFSET), MCCC_REGS_TEST_CLOCK_SELECT), 0x00000000},
  {0x0, 0x0}
};

uint32 mccc_ch_regs_config_sdi[][2] =
{
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_CLK_CBCR), 0x80000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_CLK_RST_CTL), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_CONFIG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_GCC_SRC0_BYP_CLK_CGCR), 0x80000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_GCC_SRC1_BYP_CLK_CGCR), 0x80000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_MC_CLK_CBCR), 0x80004220},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_PDM_FSC_TIMER0_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_PDM_FSC_TIMER1_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_PDM_FSC_TIMER2_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_PDM_FSC_TIMER3_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_PDM_FSC_TIMER_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_PDM_FSC_TIMER_ENABLE), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_PDM_STM_CFG), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_RX0_CONFIG_CTL), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_RX0_TEST_CTL), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_RX0_USER_CTL), 0x0000001A},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_RX1_CONFIG_CTL), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_RX1_TEST_CTL), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_RX1_USER_CTL), 0x0000001A},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SPARE0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SPARE1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SW_CTL0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SW_CTL1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SW_OVERRIDE0), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SW_OVERRIDE1), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SW_OVERRIDE2), 0x00000000},
  {HWIO_ADDRX((SEQ_MCCC_MCCC_CH0_MCCC_CH_REGS_OFFSET), MCCC_CH_REGS_SW_OVERRIDE_UPDATE), 0x00000000},
  {0x0, 0x0}
};


void Set_config_sdi (uint32 offset, uint32 config_base[][2] )
{
  uint32 reg = 0;
  uint8  ch = 0;
  uint32 ch_offset = offset;

  /* Populate base config */
  if (config_base != NULL)
  {
     if     ((config_base != bimc_global0_config_sdi) && (config_base != bimc_shke_config_ch_diff_sdi)
        && (config_base != mccc_regs_config_sdi) && (config_base != mccc_ch_regs_config_sdi))
     {
        for (ch=0; ch < NUM_CH; ch++)
        {
           ch_offset += BIMC_CH_OFFSET*ch;

           for (reg = 0; config_base[reg][0] != 0; reg++)
           {
             out_dword(config_base[reg][0] + ch_offset, config_base[reg][1]);
           }
        }
        ch_offset = offset;
     }
     else {
        for (reg = 0; config_base[reg][0] != 0; reg++)
        {
          out_dword(config_base[reg][0] + offset, config_base[reg][1]);
        }
     }
  }
}

uint8   lpddr_byte_mode_timing_table_sdi[][2] = {
  /* tWR, tWTR in 100ps*/
  /* Device_Width x16 | Device_Width x8  */
    {180,               200},  //tWR  
    {  6,                 4},  //tWR_MIN_CYC  
    {100,               120},  //tWTR  
    {  8,                 8}   //tWTR_MIN_CYC  
};

//================================================================================================//
// BIMC One-Time Settings
//================================================================================================//
void BIMC_Config_sdi(DDR_STRUCT *ddr)
{
   Set_config_sdi(BIMC_BASE, bimc_global0_config_sdi);
   Set_config_sdi(BIMC_BASE, bimc_scmo_config_sdi);
   Set_config_sdi(BIMC_BASE, bimc_dpe_config_sdi);
   Set_config_sdi(BIMC_BASE, bimc_shke_config_sdi);
   Set_config_sdi(BIMC_BASE, bimc_shke_config_ch_diff_sdi);   
}


//================================================================================================//
// DDR PHY and CC one-time settings
//================================================================================================//
void DDR_PHY_CC_Config_sdi(DDR_STRUCT *ddr)
{
   // Enable broadcast mode for all DQ PHYs on both channels
   HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET),
             AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 0x1E3C);
   Set_config_sdi(BROADCAST_BASE, ddr_phy_dq_config_sdi);
   if (ddr->detected_ddr_device[0].device_type == DDR_TYPE_LPDDR4X)
   {
      Set_config_sdi(BROADCAST_BASE, ddr_phy_dq_lp4x_config_sdi);
   }
   if(ddr->misc.chip_version >= 0x0200)
   {
      Set_config_sdi(BROADCAST_BASE, ddr_phy_dq_delta_config_sdi);
   }
   //01/15/18	//Reverted back SL specific weak pulls change. 
	/*if(ddr->misc.platform_id == STARLORD_PLATFORM_ID)
   {
	 Set_config_sdi(BROADCAST_BASE, ddr_phy_dq_starlord_config_sdi);
   }*/
   // Enable broadcast mode for all CA PHYs on both channels
   HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET),
             AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 0x0183);
   Set_config_sdi(BROADCAST_BASE, ddr_phy_ca_config_sdi);
   if (ddr->detected_ddr_device[0].device_type == DDR_TYPE_LPDDR4X)
   {
      Set_config_sdi(BROADCAST_BASE, ddr_phy_ca_lp4x_config_sdi);
   }
   if(ddr->misc.chip_version >= 0x0200)
   {
      Set_config_sdi(BROADCAST_BASE, ddr_phy_ca_delta_config_sdi);
   }
	//01/15/18	//Reverted back SL specific weak pulls change. 
	/*if(ddr->misc.platform_id == STARLORD_PLATFORM_ID)
   {
	 Set_config_sdi(BROADCAST_BASE, ddr_phy_ca_starlord_config_sdi);
   }*/
   // Enable broadcast mode for all CCs on both channels
   HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET),
             AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 0x2040);
   Set_config_sdi(BROADCAST_BASE, ddr_cc_config_sdi);
   if(ddr->misc.chip_version >= 0x0200)
   {
      Set_config_sdi(BROADCAST_BASE, ddr_cc_delta_config_sdi);
   }

   // Disable broadcast mode 
   HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET),
             AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 0x0);
}

// DDR_CC_MCCC_Config --- one time settings through new DDR_CC_MCCC calculator, Need to have a parser for this new calculator
void DDR_CC_MCCC_Config_sdi(DDR_STRUCT *ddr)
{
   Set_config_sdi(DDR_PHY_SS_BASE, ddr_cc_mccc_regs_config_sdi);
}


void busywait_sdi(uint32 us_delay)
{
    uint32 i, j;
    
    for (i = 0; i < us_delay; i++)
    {
        for (j = 0; j < 10; j++)
  {
  }
    }
}



void seq_wait_sdi(uint32 time_value, SEQ_TimeUnit time_unit)
{
    if(time_unit == SEC)
    {
       busywait_sdi(1000000*time_value);
    }
    else if(time_unit == MS)
    {
       busywait_sdi(1000*time_value);
    }
    else if(time_unit == US)
    {
       busywait_sdi(time_value);
    }
    else
    {
       /* time_unit == NS */
       busywait_sdi(time_value/1000);
    }
}

//================================================================================================//
// Set up init clk period.
// Update AC timing parameters from CDT, recalculate and load DPE timing actual registers
//================================================================================================//
void BIMC_Pre_Init_Setup_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint32 tREFI_in_XO     = 0;
   uint32 period          = 0;
   uint8  ch              = 0;
   uint32 reg_offset_dpe  = 0;
   uint32 reg_offset_shke = 0;
   uint8  new_RL_WL_idx   = 0;
   uint32 tXP_adjusted    = 0;
   uint32 clk_freq_khz;
   uint8  device_io_width = 0;

   clk_freq_khz = ddr->misc.current_clk_in_kHz;
   period = CONVERT_CYC_TO_PS / clk_freq_khz; //unit in ps

   new_RL_WL_idx  = BIMC_RL_WL_Freq_Index_sdi (ddr, clk_freq_khz);

   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_dpe  = REG_OFFSET_DPE(ch);
      reg_offset_shke = REG_OFFSET_SHKE(ch);

      if ((channel >> ch) & 0x1)
      {
         // Program the new period
         HWIO_OUTXFI (REG_OFFSET_GLOBAL0, BIMC_MISC_GLOBAL_CSR_DDR_CHn_CLK_PERIOD, ch, PERIOD, period);

         // Common AC Timing parameters between LP3 and LP4
         HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_0, TRASMIN, ddr->cdt_params.lpddr.tRAS_Min);
         HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_1, TRCD, ddr->cdt_params.lpddr.tRCD);
         HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_2, TRRD, ddr->cdt_params.lpddr.tRRD);
         HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_4, TRTP, ddr->cdt_params.lpddr.tRTP);
         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_5, TRPAB, TRPPB,
                      ddr->cdt_params.lpddr.tRP_AB, ddr->cdt_params.lpddr.tRP_PB);
         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_6, TFAW, TCKE,
                      ddr->cdt_params.lpddr.tFAW, ddr->cdt_params.lpddr.tCKE);
         HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_9, MIN_SR_DURATION, ddr->cdt_params.lpddr.tCKESR);

         // Add CKE rise slew rate (1.2ns) into tXP.
         tXP_adjusted = ddr->cdt_params.lpddr.tXP + 12;
         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_11, TXPNR_ACT_PWR_DN, TXPR_ACT_PWR_DN,
                      tXP_adjusted, tXP_adjusted);
         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_12, TXPNR_PCHG_PWR_DN, TXPR_PCHG_PWR_DN,
                      tXP_adjusted, tXP_adjusted);

         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_16, RD_LATENCY, WR_LATENCY,
                      ddr->extended_cdt_runtime.dram_latency[new_RL_WL_idx].RL_DBI_Off_x16, ddr->extended_cdt_runtime.dram_latency[new_RL_WL_idx].WL);
           
         HWIO_OUTXF  (reg_offset_dpe, DPE_TIMER_2, TMRR, ddr->cdt_params.lpddr.tMRR);

         if (15 < ddr->cdt_params.lpddr.tMRW) {
            HWIO_OUTXF (reg_offset_dpe, DPE_TIMER_2, TMRW, ddr->cdt_params.lpddr.tMRW);
         }
         else
         {
            HWIO_OUTXF (reg_offset_dpe, DPE_TIMER_2, TMRW, 15);
         }

         //load page_close_timer from eCDT
         HWIO_OUTXF (reg_offset_dpe, DPE_OPT_CTRL_1, PG_OPEN_TIMER, ddr->extended_cdt_runtime.page_close_timer);

         // cdt_params has resolution of 100ps, multiplied by 100 to convert to 1ps
         tREFI_in_XO = (ddr->cdt_params.lpddr.tREFI * 100) / XO_PERIOD_IN_PS - 1;

         HWIO_OUTXF (reg_offset_shke, SHKE_AUTO_REFRESH_CNTL,   TREFI, tREFI_in_XO);
         HWIO_OUTXF (reg_offset_shke, SHKE_AUTO_REFRESH_CNTL_1, TREFI, tREFI_in_XO);

          // AC Timing parameters
         BIMC_Program_Lpddr_AC_Parameters_sdi( ddr, (DDR_CHANNEL)ch);

         //Fetch device IO width from DDR struct [STARLORD UPDATE]
         device_io_width = ddr->ddr_size_info.ddr0_cs0_io_width; 

         //Update tRFC and tXSNR from CDT
         //Update tWR and tWTR from CDT
         HWIO_OUTXF (reg_offset_dpe, DPE_DRAM_TIMING_3, TRFCAB, ddr->cdt_params.lpddr.tRFC);
         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_10, TXSRD, TXSNR,
                     ddr->cdt_params.lpddr.tXSR, ddr->cdt_params.lpddr.tXSR);
         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_1, TWR, TWR_MIN_CYC, ddr->cdt_params.lpddr.tWR, lpddr_byte_mode_timing_table_sdi[1][device_io_width]);
         HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_2, TWTR, TWTR_MIN_CYC, ddr->cdt_params.lpddr.tWTR, lpddr_byte_mode_timing_table_sdi[3][device_io_width]);
    

         // Kick off timing parameter calculation and wait until done
         HWIO_OUTXF (reg_offset_dpe, DPE_CONFIG_4, RECALC_PS_PARAMS, 0x1);
         while (HWIO_INXF (reg_offset_dpe, DPE_MEMC_STATUS_1, CYC_CALC_VALID));

         // Load all the calculated settings into DPE actual registers
         HWIO_OUTXF (reg_offset_dpe, DPE_CONFIG_4, LOAD_ALL_CONFIG, 0x1);
      }
   }
}


//================================================================================================//
// Device Initialization
// Select LPDDR3 or LPDDR4 initialization routines for enabling CK and CKE.
// Does ZQ calibration and RL/WL programming
//================================================================================================//
void BIMC_Memory_Device_Init_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint8 ch = 0x0;
   uint32 reg_offset_shke = 0;
   uint8  RL_WL_idx  = 0;
   uint32 clk_freq_khz;

   clk_freq_khz = ddr->misc.current_clk_in_kHz;
   BIMC_Memory_Device_Init_Lpddr_sdi (ddr, channel, chip_select);
   BIMC_ZQ_Calibration_sdi (ddr, channel, chip_select);

   // RL and WL MR write
   RL_WL_idx  = BIMC_RL_WL_Freq_Index_sdi (ddr, clk_freq_khz);
   BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_2, ddr->extended_cdt_runtime.dram_latency[RL_WL_idx].MR2 );

   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_shke = REG_OFFSET_SHKE(ch);

      if ((channel >> ch) & 0x1)
      {
         // Set rank init complete signal
         if (chip_select & DDR_CS0) {
            HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, RANK0_INITCOMPLETE, 1);
         }
         if (chip_select & DDR_CS1) {
            HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, RANK1_INITCOMPLETE, 1);
         }
      }
   }
}


//================================================================================================//
// BIMC DRAM Address Setup for warm boot -- based on DDR information stored in DDR_STRUCT during Pass 0 initialization
// channel=DDR_CH_BOTH is not supported in this function
// cs=DDR_CS_BOTH is not supported in this function
//================================================================================================//

void BIMC_DDR_Addr_Setup_Warm_sdi (DDR_STRUCT *ddr, uint8 ch, uint8 cs)
{
    uint32 addr_base_9_2   = 0;
    uint32 size_in_mb      = 0;
    uint32 addr_mask       = 0;
    uint32 num_rows        = 0;
    uint32 num_cols        = 0;
    uint32 num_banks       = 0;
    uint32 reg_offset_scmo = 0;
    
    uint64 base_addr    = 0xFFFFFFFFFFFFFFFF;

   // Instead of calculating it, just pull the needed DDR info from the DDR_STRUCT
   if (ch == 0)
   {
      if (cs == 0)
      {
         base_addr = ddr->ddr_size_info.ddr0_cs0_addr;
         size_in_mb = ddr->ddr_size_info.ddr0_cs0_mb;
         num_banks = ddr->detected_ddr_device[ch].num_banks_cs0;
         num_rows = ddr->detected_ddr_device[ch].num_rows_cs0;
         num_cols = ddr->detected_ddr_device[ch].num_cols_cs0;
      }
      else
      {
         base_addr = ddr->ddr_size_info.ddr0_cs1_addr;
         size_in_mb = ddr->ddr_size_info.ddr0_cs1_mb;
         num_banks = ddr->detected_ddr_device[ch].num_banks_cs1;
         num_rows = ddr->detected_ddr_device[ch].num_rows_cs1;
         num_cols = ddr->detected_ddr_device[ch].num_cols_cs1;
      }
   }
   else
   {
      if (cs == 0)
      {
         base_addr = ddr->ddr_size_info.ddr1_cs0_addr;
         size_in_mb = ddr->ddr_size_info.ddr1_cs0_mb;
         num_banks = ddr->detected_ddr_device[ch].num_banks_cs0;
         num_rows = ddr->detected_ddr_device[ch].num_rows_cs0;
         num_cols = ddr->detected_ddr_device[ch].num_cols_cs0;
      }
      else
      {
         base_addr = ddr->ddr_size_info.ddr1_cs1_addr;
         size_in_mb = ddr->ddr_size_info.ddr1_cs1_mb;
         num_banks = ddr->detected_ddr_device[ch].num_banks_cs1;
         num_rows = ddr->detected_ddr_device[ch].num_rows_cs1;
         num_cols = ddr->detected_ddr_device[ch].num_cols_cs1;
      }
   }

    switch(size_in_mb){
        case 8192 : addr_mask = 0x80;
            break;
        case 4096 : addr_mask = 0xc0;
            break;
        case 2048 : addr_mask = 0xe0;
            break;
        case 1536 : addr_mask = 0xe0;
            break;  
        case 1024 : addr_mask = 0xf0;
            break;
        case 768  : addr_mask = 0xf0;
            break;
        case 512  : addr_mask = 0xf8;
            break;
        case 256  : addr_mask = 0xfc;
            break;
        case 128  : addr_mask = 0xfe;
            break;
        case 64   : addr_mask = 0xff;
            break;
        default   : addr_mask = 0x00;
            break;
    }

    reg_offset_scmo = REG_OFFSET_SCMO(ch);
    
    HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn,  cs, BANK_SIZE, num_banks >> 3);// 0x0:BANKS_4
                                                                                     // 0x1:BANKS_8
    HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn,  cs, ROW_SIZE,  num_rows - 13); // 0x0:ROWS_13
                                                                                     // 0x1:ROWS_14
                                                                                     // 0x2:ROWS_15
                                                                                     // 0x3:ROWS_16
    HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn,  cs, COL_SIZE,  num_cols - 8);  // 0x0:COLS_8
                                                                                     // 0x1:COLS_9
                                                                                     // 0x2:COLS_10
                                                                                     // 0x3:COLS_11
    
    // Convert base addr to [9:2] for SCMO base CSR. Divide base address by 64MB which is the
    // minimum supported density (right shift by 26)
   addr_base_9_2 = (base_addr >> 26);
   HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_BASE_CSn, cs, ADDR_BASE, addr_base_9_2);
   HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MASK_CSn, cs, ADDR_MASK, addr_mask);
   
   if (num_banks != 0) 
   {
        HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn, cs, RANK_EN, 1);
   }
    
}



//================================================================================================//
// void BIMC_DDR_Access_Enable_sdi(ddr, channel, chip_select)
// This function sets up the DDR read/write latency, and makes sure that missing ranks have CK and CKE disabled, allowing
//    communication to the external DDR devices.
// Channel=DDR_CH_BOTH is not supported in this function
//================================================================================================//
DDR_CHIPSELECT BIMC_DDR_Access_Enable_sdi(DDR_STRUCT *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint8  cs = 0;
   uint8  ch_inx           = 0;
   DDR_CHIPSELECT  cs_1hot = DDR_CS0;
   uint32 reg_offset_shke  = 0;

   ch_inx = CH_INX(channel);
   reg_offset_shke = REG_OFFSET_SHKE(ch_inx);
    
   // Flag that initialization is complete on the populated ranks.  If the ranks are not populated, these bits will
   //    be left at 0.
   if ((((DDR_CHIPSELECT)ddr->detected_ddr_device[ch_inx].populated_chipselect) & DDR_CS0) == DDR_CS0)
   {
      HWIO_OUTXF2(reg_offset_shke, SHKE_CONFIG, RANK0_INITCOMPLETE, RANK0_EN, 1, 1);
   }
   else
   {
      // Disable CKE to the unpopulated rank
      HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, CKE_OFF, DDR_CS0, 0x1);
      while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, CKE_OFF));

      // Disable CK to the unpopulated rank
      HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, CK_OFF, DDR_CS0, 0x1);
      while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, CK_OFF));
   }
   
   if ((((DDR_CHIPSELECT)ddr->detected_ddr_device[ch_inx].populated_chipselect) & DDR_CS1) == DDR_CS1)
   {
      HWIO_OUTXF2(reg_offset_shke, SHKE_CONFIG, RANK1_INITCOMPLETE, RANK1_EN, 1, 1);
   }
   else
   {
      // Disable CKE to the unpopulated rank
      HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, CKE_OFF, DDR_CS1, 0x1);
      while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, CKE_OFF));

      // Disable CK to the unpopulated rank
      HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, CK_OFF, DDR_CS1, 0x1);
      while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, CK_OFF));
   }
   
   // Set up read/write latencies for mode reg reads and writes to the DDR
   for (cs = 0; cs < 2; cs++)
   {
      cs_1hot = CS_1HOT(cs);

      if ((chip_select >> cs) & 0x1)
      {

         // Set up the DDR device latencies so that we can read and write to it.
         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_2, 0);  //read write latency
         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_13, 0x80); //set FSP_OP=1, FSP_WR=0
         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_2, 0);  //read write latency                       
         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_13, 0);
     BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_2, 0);  //read write latency                       
         seq_wait_sdi(1, MS);
         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_1, 0x06);   

         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_3, 0xB0); //10  < F <= 400MHz, set MR3[0],PU-CAL=VDDQ/2.5 for fsp0, it was 0xB1(VDDQ/3)       
         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_11, 0x0);
         BIMC_MR_Write_sdi (channel, cs_1hot, JEDEC_MR_22, 0x0);

      }
   }

   return ((DDR_CHIPSELECT)ddr->detected_ddr_device[ch_inx].populated_chipselect);
}




//================================================================================================//
// BIMC Post Initialization sequence  //
// Channel=DDR_CH_BOTH is not supported in this function
//================================================================================================//
void BIMC_Post_Init_Setup_Warm_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint8 interface_width_index_cs0 = 0;
   uint8 interface_width_index_cs1 = 0;
   uint8 ch_inx                    = 0;
   uint32 reg_offset_dpe           = 0;
   uint32 reg_offset_scmo          = 0;
   uint32 reg_offset_shke          = 0;


   ch_inx          = CH_INX(channel);
   reg_offset_dpe  = REG_OFFSET_DPE(ch_inx);
   reg_offset_scmo = REG_OFFSET_SCMO(ch_inx);
   reg_offset_shke = REG_OFFSET_SHKE(ch_inx);


   if (chip_select & DDR_CS0)
   {
      if (ddr->detected_ddr_device[ch_inx].interleave_en & DDR_CS0_INTERLEAVE)
      {
         HWIO_OUTXF (reg_offset_scmo, SCMO_CFG_SLV_INTERLEAVE_CFG , INTERLEAVE_CS0, 1);
      }

      switch(ddr->detected_ddr_device[ch_inx].interface_width_cs0)
      {
         case 64 : interface_width_index_cs0 = 0x3;
            break;
         case 32 : interface_width_index_cs0 = 0x2;
            break;
         case 16 : interface_width_index_cs0 = 0x1;
            break;
         case  8 : interface_width_index_cs0 = 0x0;
            break;   
         default : interface_width_index_cs0 = 0x0;
            break;
      }

      HWIO_OUTXF (reg_offset_dpe, DPE_CONFIG_0, DEVICE_CFG_RANK0, interface_width_index_cs0);

      BIMC_DDR_Addr_Setup_Warm_sdi (ddr, ch_inx, CS_INX(DDR_CS0));

      // Bank number 4: 0x00; Bank number 8: 0x01
      HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, NUM_BANKS, (ddr->detected_ddr_device[ch_inx].num_banks_cs0) >> 3 );

   }

   if (chip_select & DDR_CS1)
   {
      if (ddr->detected_ddr_device[ch_inx].interleave_en & DDR_CS1_INTERLEAVE)
      {
         HWIO_OUTXF (reg_offset_scmo, SCMO_CFG_SLV_INTERLEAVE_CFG , INTERLEAVE_CS1, 1);
      }

      switch(ddr->detected_ddr_device[ch_inx].interface_width_cs1)
      {
         case 64 : interface_width_index_cs1 = 0x3;
            break;
         case 32 : interface_width_index_cs1 = 0x2;
            break;
         case 16 : interface_width_index_cs1 = 0x1;
            break;
         case  8 : interface_width_index_cs1 = 0x0;
            break;   
         default : interface_width_index_cs1 = 0x0;
            break;
      }

      HWIO_OUTXF (reg_offset_dpe, DPE_CONFIG_0, DEVICE_CFG_RANK1, interface_width_index_cs1);

      BIMC_DDR_Addr_Setup_Warm_sdi (ddr, ch_inx, CS_INX(DDR_CS1));

      //Bank number 4: 0x00; Bank number 8: 0x01
      HWIO_OUTXF (reg_offset_shke, SHKE_CONFIG, NUM_BANKS, (ddr->detected_ddr_device[ch_inx].num_banks_cs1) >> 3 );
   }

   // bank count for both ranks
   HWIO_OUTXF2 (reg_offset_dpe, DPE_CONFIG_1, NUM_BANKS_RANK0, NUM_BANKS_RANK1,
                ddr->detected_ddr_device[ch_inx].num_banks_cs0, ddr->detected_ddr_device[ch_inx].num_banks_cs1);

   // Enable activity based channel clock gating after init. This clock gating was disable in one-time
   // settings so that PHY will recieve clock during PHY init.
   HWIO_OUTXF2 (reg_offset_dpe, DPE_CONFIG_6, IOSTAGE_WR_DEBUG_MODE, IOSTAGE_CA_DEBUG_MODE, 0x0, 0x0);

   // Enable Power Down
   HWIO_OUTXF2 (reg_offset_dpe, DPE_PWR_CTRL_0, PWR_DN_EN, CLK_STOP_PWR_DN_EN, 0x1, 0x1);
   HWIO_OUTXF  (reg_offset_dpe, DPE_CONFIG_4, LOAD_ALL_CONFIG, 0x1);

   // Enable all periodic functions: auto refresh, hw self refresh, periodic ZQCAL, periodic SRR,
   BIMC_All_Periodic_Ctrl_sdi (ddr, channel, chip_select, 0x01/*0x01 for enable*/);
}


void BIMC_Enter_Self_Refresh_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint8 ch = 0;
   uint32 reg_offset_shke = 0;
   uint32 reg_offset_scmo = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_shke = REG_OFFSET_SHKE(ch);
      reg_offset_scmo = REG_OFFSET_SCMO(ch);

      if ((channel >> ch) & 0x1)
      {
         // Disable rank and disable HW self refresh
         if (chip_select & DDR_CS0)  {
            HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn,  0/*rank index 0*/, RANK_EN, 0);
            BIMC_HW_Self_Refresh_Ctrl_sdi (ddr, ch, 0, 0);
         }
         if (chip_select & DDR_CS1)  {
            HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn,  1/*rank index 1*/, RANK_EN, 0);
            BIMC_HW_Self_Refresh_Ctrl_sdi (ddr, ch, 1, 0);
         }

         // Enter SW self refresh
         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, ENTER_SELF_REFRESH_IDLE, chip_select, 1);
         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, ENTER_SELF_REFRESH_IDLE));

         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_STATUS, SW_SELF_RFSH) == 0);
      }
   }
}



//================================================================================================//
// BIMC_Exit_Self_Refresh_sdi
// exit SW self refresh and enable HW self refresh
//================================================================================================//
void BIMC_Exit_Self_Refresh_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint8 ch = 0;
   uint32 reg_offset_shke = 0;
   uint32 reg_offset_scmo = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_shke = REG_OFFSET_SHKE(ch);
      reg_offset_scmo = REG_OFFSET_SCMO(ch);

      if ((channel >> ch) & 0x1)
      {
         // Enable rank
         if (chip_select & DDR_CS0) {
            HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn,  0/*rank0*/, RANK_EN, 1);
         }
         if (chip_select & DDR_CS1) {
            HWIO_OUTXFI (reg_offset_scmo, SCMO_CFG_ADDR_MAP_CSn,  1/*rank1*/, RANK_EN, 1);
         }


         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, EXIT_SELF_REFRESH, chip_select, 1);
         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, EXIT_SELF_REFRESH));

         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_STATUS, SW_SELF_RFSH));

         // Enable HW self refresh
         if (chip_select & DDR_CS0) {
            BIMC_HW_Self_Refresh_Ctrl_sdi (ddr, ch, 0, 1);
         }
         if (chip_select & DDR_CS1) {
            BIMC_HW_Self_Refresh_Ctrl_sdi (ddr, ch, 1, 1);
         }
      }
   }
}




//================================================================================================//
//ZQ Cal function that can either choose lpddr3 or lpddr4
//================================================================================================//
void BIMC_ZQ_Calibration_sdi (DDR_STRUCT  *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint8 ch      = 0;
   uint8 ch_1hot = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      ch_1hot = CH_1HOT(ch);

      if ((channel >> ch) & 0x1)
      {
         if (chip_select & DDR_CS0) {
             BIMC_ZQ_Calibration_Lpddr_sdi (ddr, (DDR_CHANNEL)ch_1hot, DDR_CS0);
         }
         if (chip_select & DDR_CS1) {
             BIMC_ZQ_Calibration_Lpddr_sdi (ddr, (DDR_CHANNEL)ch_1hot, DDR_CS1);
         }
      }
   }
}


//================================================================================================//
// Read and Write Latency Tables
// RL, WL and corresponding MR2 values
// LPDDR4 RL value below is for DBI enabled case
//================================================================================================//
struct ecdt_dram_latency_runtime_struct RL_WL_lpddr_struct_sdi[] =
{
    /*RL,      RL         RL         RL 
   DBI_OFF_x16 DBI_ON_x16 DBI_OFF_x8 DBI_ON_x8  WL,  MR2,  freq */
   { 6 ,        6 ,         6 ,         6 ,     4 ,  0x00, 266000},  /*   10 < F <= 266MHz  */
   { 10,        12,         10,         12,     6 ,  0x09, 533000},  /*  266 < F <= 533MHz  */
   { 14,        16,         16,         18,     8 ,  0x12, 800000},  /*  533 < F <= 800MHz  */
   { 20,        22,         22,         24,     10,  0x1B, 1066000}, /*  800 < F <= 1066MHz */
   { 24,        28,         26,         30,     12,  0x24, 1333000}, /* 1066 < F <= 1333MHz */
   { 28,        32,         32,         36,     14,  0x2D, 1600000}, /* 1333 < F <= 1600MHz */
   { 32,        36,         36,         40,     16,  0x36, 1866000}, /* 1600 < F <= 1866MHz */
   { 36,        40,         40,         44,     18,  0x3F, 2133000}, /* 1866 < F <= 2133MHz */
   {  0,         0,          0,          0,      0,     0,       0}, /* reserved */
   {  0,         0,          0,          0,      0,     0,       0}, /* reserved */
   {  0,         0,          0,          0,      0,     0,       0}, /* reserved */
   {  0,         0,          0,          0,      0,     0,       0}, /* reserved */
   {  0,         0,          0,          0,      0,     0,       0}, /* reserved */
   {  0,         0,          0,          0,      0,     0,       0}, /* reserved */
   {  0,         0,          0,          0,      0,     0,       0}, /* reserved */
   {  0,         0,          0,          0,      0,     0,       0}  /* reserved */

};

uint32 RL_WL_freq_range_table_sdi[]                 = {266000, 533000, 800000, 1066000, 1333000, 1600000, 1866000, 2133000};
uint8  RL_WL_freq_range_table_size_sdi              = sizeof(RL_WL_freq_range_table_sdi)/sizeof(uint32);



//================================================================================================//
//Timer function is called before triggering DRAM_MANUAL_0 command
//WAIT_TIMER_DOMAIN has 2 options: XO clock(19.2MHz) and Timer clock(32KHz), enum defined in ddr_common.h
//================================================================================================//
void BIMC_Wait_Timer_Setup_sdi (DDR_CHANNEL channel, BIMC_Wait_Timer_Domain one_xo_zero_timer_clk, uint32 timer_value)
{
   uint8  ch = 0;
   uint32 reg_offset_shke = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_shke = REG_OFFSET_SHKE(ch);
      if ((channel >> ch) & 0x1)
      {
         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_1, WAIT_TIMER_DOMAIN, WAIT_TIMER_BEFORE_HW_CLEAR, one_xo_zero_timer_clk, timer_value);
      }
   }

}
//================================================================================================//
//Mode Register write can use for both channels and both ranks
//================================================================================================//
void BIMC_MR_Write_sdi (DDR_CHANNEL channel, DDR_CHIPSELECT chip_select, uint32 MR_addr, uint32 MR_data)
{
   uint8 ch = 0;
   uint32 reg_offset_shke = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_shke = REG_OFFSET_SHKE(ch);
      if ((channel >> ch) & 0x1)
      {
         HWIO_OUTXF2 (reg_offset_shke, SHKE_MREG_ADDR_WDATA_CNTL, MREG_ADDR, MREG_WDATA, MR_addr, MR_data);
         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, MODE_REGISTER_WRITE, chip_select, 1);
         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, MODE_REGISTER_WRITE));
      }
   }

}

//================================================================================================//
//Mode register read function only returns a single MR value, it reads on per channel per rank basis
//Both-channel option is not supported for DDR_CHANNEL
//================================================================================================//
uint32 BIMC_MR_Read_sdi (DDR_CHANNEL channel, DDR_CHIPSELECT chip_select, uint32 MR_addr)
{
   uint32  read_value = 0;
   uint32 reg_offset_shke = 0;

   reg_offset_shke = REG_OFFSET_SHKE(CH_INX(channel));

   HWIO_OUTXF (reg_offset_shke, SHKE_MREG_ADDR_WDATA_CNTL, MREG_ADDR, MR_addr);

   HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, MODE_REGISTER_READ, chip_select, 1);
   while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, MODE_REGISTER_READ));

   if(chip_select == DDR_CS0) {
      read_value = HWIO_INX (reg_offset_shke, SHKE_MREG_RDATA_RANK0_L);
   }
   if(chip_select == DDR_CS1) {
      read_value = HWIO_INX (reg_offset_shke, SHKE_MREG_RDATA_RANK1_L);
   }


   return read_value;
}

//================================================================================================//
// Enable/Disable HW activity based self refresh
//================================================================================================//
void BIMC_HW_Self_Refresh_Ctrl_sdi (DDR_STRUCT *ddr, uint8 ch, uint8 cs, uint8 enable)
{

   // Check if this feature is enabled in the DDR_STRUCT
   if (ddr->extended_cdt_runtime.hw_self_refresh_enable[ch] == 1) {
      if (cs == 0) {
         HWIO_OUTXF (REG_OFFSET_SHKE(ch), SHKE_SELF_REFRESH_CNTL, HW_SELF_RFSH_ENABLE_RANK0, enable);
      }
      if (cs == 1) {
         HWIO_OUTXF (REG_OFFSET_SHKE(ch), SHKE_SELF_REFRESH_CNTL, HW_SELF_RFSH_ENABLE_RANK1, enable);
      }
   }
}




//================================================================================================//
// Periodic events controlled through this function are
// 1. Auto refresh
// 2. HW self refresh (activity based)
// 3. ZQ calibration
// 4. Temperature status read
//================================================================================================//
void BIMC_All_Periodic_Ctrl_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select, uint8 enable)
{
   uint8  rank_ctrl = 0;
   uint8  ch        = 0;
   uint32 reg_offset_shke = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_shke = REG_OFFSET_SHKE(ch);

      if ((channel >> ch) & 0x1)
      {
        // Auto refresh and HW activity based self refresh
        if (chip_select & DDR_CS0) {
           HWIO_OUTXF (reg_offset_shke, SHKE_AUTO_REFRESH_CNTL, AUTO_RFSH_ENABLE_RANK0,    enable);
           BIMC_HW_Self_Refresh_Ctrl_sdi (ddr, ch, 0, enable);
        }
        if (chip_select & DDR_CS1) {
           HWIO_OUTXF (reg_offset_shke, SHKE_AUTO_REFRESH_CNTL, AUTO_RFSH_ENABLE_RANK1,    enable);
           BIMC_HW_Self_Refresh_Ctrl_sdi (ddr, ch, 1, enable);
        }

        // Periodic ZQ calibration

        //wait for 1us
        seq_wait_sdi(1, US);
        rank_ctrl = HWIO_INXF (reg_offset_shke, SHKE_PERIODIC_ZQCAL, RANK_SEL);
        rank_ctrl = enable ? (rank_ctrl | chip_select) : (rank_ctrl & ~chip_select);
        HWIO_OUTXF  (reg_offset_shke, SHKE_PERIODIC_ZQCAL, RANK_SEL, rank_ctrl);

        // Periodic temperature status read (SRR)
        if (ddr->extended_cdt_runtime.MR4_polling_enable == 1) 
        {
           rank_ctrl = HWIO_INXF  (reg_offset_shke, SHKE_PERIODIC_MRR, MRR_RANK_SEL);
           rank_ctrl = enable ? (rank_ctrl | chip_select) : (rank_ctrl & ~chip_select);
           HWIO_OUTXF  (reg_offset_shke, SHKE_PERIODIC_MRR, MRR_RANK_SEL, rank_ctrl);
        }
      }
   }
}




//================================================================================================//
// Based on device RL/WL/ODTLon frequency band, get an index for selecting in RL/WL/ODTLon table
//================================================================================================//
uint8 BIMC_RL_WL_Freq_Index_sdi (DDR_STRUCT *ddr, uint32 clk_freq_khz)
{
   uint8 clk_idx;

   for (clk_idx = 0; (clk_idx < RL_WL_freq_range_table_size_sdi); clk_idx++)
    {
      if (clk_freq_khz <= RL_WL_freq_range_table_sdi[clk_idx])
            break;
    }
     
   return clk_idx;
}






//================================================================================================//
// Programs the AC Parameters for LPDDR4, during BIMC Pre Init
//================================================================================================//
void BIMC_Program_Lpddr_AC_Parameters_sdi(DDR_STRUCT *ddr, DDR_CHANNEL channel)
{
   uint32 reg_offset_dpe  = 0;
   reg_offset_dpe  = REG_OFFSET_DPE(channel);
 
   HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_24, TCCDMW, ddr->cdt_params.lpddr.tCCDMW);
   HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_25, TCKEHCMD, ddr->cdt_params.lpddr.tCKEHCMD);
   HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_29, TDQS2DQMIN, TDQS2DQMAX,
                 ddr->cdt_params.lpddr.tDQS2DQMIN, ddr->cdt_params.lpddr.tDQS2DQMAX);
   HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_30, TZQL, ddr->cdt_params.lpddr.tZQLAT);
   HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_31, TDQSCKMIN, TDQSCKMAX,
                 ddr->cdt_params.lpddr.tDQSCK_min, ddr->cdt_params.lpddr.tDQSCK_max);
   HWIO_OUTXF  (reg_offset_dpe, DPE_DRAM_TIMING_34, TFC, ddr->cdt_params.lpddr.tFC);
   HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_LP4_ODT_ON_CNTL, LP4_ODT_ONMAX, LP4_ODT_ONMIN,
                 ddr->cdt_params.lpddr.tODTonmax, ddr->cdt_params.lpddr.tODTonmin);
   HWIO_OUTXF2 (reg_offset_dpe, DPE_DRAM_TIMING_LP4_ODT_OFF_CNTL, LP4_ODT_OFFMAX, LP4_ODT_OFFMIN,
                 ddr->cdt_params.lpddr.tODToffmax, ddr->cdt_params.lpddr.tODToffmin);
}


//================================================================================================//
// LPDDR4 Device Initialization
// Does device initialization steps of enabling CK and CKE sequentially
//================================================================================================//
void BIMC_Memory_Device_Init_Lpddr_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel , DDR_CHIPSELECT chip_select)
{
   uint8  ch                     = 0;
   uint8  ch_1hot                = 0;
   uint32 reg_offset_shke        = 0;
   

   for (ch = 0; ch < NUM_CH; ch++)
   {
      ch_1hot = CH_1HOT(ch);
      reg_offset_shke = REG_OFFSET_SHKE(ch);

      if ((channel >> ch) & 0x1)
      {
         // After RESET_n is deasserted, wait at least tINIT3 before activating CKE.
         // BIMC keeps CKE off at power up. Set CKE off again to trigger DPE timer to satisfy tINIT3
         // Convert tINIT3=2ms to Timer clock cycle (32KHz): 2ms/ 0.03125ms = 64 = 0x40
         BIMC_Wait_Timer_Setup_sdi ((DDR_CHANNEL)ch_1hot, WAIT_TIMER_CLOCK, 0x40);

         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, CKE_OFF, chip_select, 1);
         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, CKE_OFF));

         //Turn CK on and wait tINIT4=5tck
         BIMC_Wait_Timer_Setup_sdi ((DDR_CHANNEL)ch_1hot, WAIT_XO_CLOCK, 0x05);

         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, CK_ON, chip_select, 1);
         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, CK_ON));

         // Turn CKE on and then wait tINIT5
         // Convert tINIT5=2us to XO clock cycle (0.052us): 2us/0.052us = 39 (after roundup) = 0x27
         BIMC_Wait_Timer_Setup_sdi ((DDR_CHANNEL)ch_1hot, WAIT_XO_CLOCK, 0x27);

         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, CKE_ON, chip_select, 1);
         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, CKE_ON));

         // Reset manual_1 timer
         BIMC_Wait_Timer_Setup_sdi ((DDR_CHANNEL)ch_1hot, WAIT_XO_CLOCK, 0x00);
      }
   }

   if (ddr->misc.target_silicon == 1)
   {
      // Enable DBI-WR, DBI-RD/PDDS/PU-CAL/WR_PST are set to default
      //FSP = Settings
      if (ddr->detected_ddr_device[0].device_type == DDR_TYPE_LPDDR4X) // For LP4x apply these settings
      {
         BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_3, 0xB0); //10  < F <= 400MHz, set MR3[0],PU-CAL=VDDQ/2.5 for fsp0, it was 0xB1(VDDQ/3)
      }
      else // for lp4 device apply these settings
      {
         BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_3, 0xB0); //10  < F <= 400MHz, set MR3[0],PU-CAL=VDDQ/2.5 for fsp0, it was 0xB1(VDDQ/3)
      }

      BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_22, 0x0); //set SOC_ODT to disable for fsp0. it was SOC_ODT=40ohm for FSP=0
    
    
      // Enable 16 or 32 sequential (on-the-fly) burst length
      BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_1, 0x06);
    
   }
   else
   {
      // ddr->misc.target_silicon != 1

      // Use these values to initialize the DDR mode regs for emulation    

      // Comment out the below lines for bringup. DBI-WR will be enabled post
      // bringup. Uncomment it then. Also needs bimc_config.c update to enable DBI-WR
      //// Enable DBI-WR, DBI-RD/PDDS/PU-CAL/WR_PST are set to default
      BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_3, 0xB1);
      BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_22, 0x6); //SOC_ODT=40ohm for FSP=0

      // Enable 16 or 32 sequential (on-the-fly) burst length
      BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_1, 0x02);

   }
    
    // Reset FSP-WR=0
    BIMC_MR_Write_sdi (channel, chip_select, JEDEC_MR_13, 0x00);
}



//================================================================================================//
// Manual ZQ calibration for LPDDR4
// This function supports ZQ Cal per rank and both ranks. While using for both ranks, ZQCAL_START
// is issued for one rank followed by next rank. ZQCAL_LATCH for both ranks are issued together.
//================================================================================================//
void BIMC_ZQ_Calibration_Lpddr_sdi (DDR_STRUCT  *ddr, DDR_CHANNEL channel, DDR_CHIPSELECT chip_select)
{
   uint8  ch = 0;
   uint8  cs = 0;
   uint8  ch_1hot = 0;
   uint32 reg_offset_shke = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      ch_1hot = CH_1HOT(ch);
      reg_offset_shke = REG_OFFSET_SHKE(ch);

      if ((channel >> ch) & 0x1)
      {
         // tZQCAL has 100ps resolution, first multiply by 100 to convert resolution to 1ps,
         // then convert to XO_PERIOD. Rounding up using div_ceil function which rounds up
         // any decimal value to the next integer.
         BIMC_Wait_Timer_Setup_sdi ((DDR_CHANNEL)ch_1hot, WAIT_XO_CLOCK,
                                  (div_ceil((ddr->cdt_params.lpddr.tZQCAL * 100), XO_PERIOD_IN_PS)));

         for (cs = 0; cs < 2; cs++)
         {
            if ((chip_select >> cs) & 0x1)
            {
            HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, ZQCAL_START, CS_1HOT(cs), 1);
            while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, ZQCAL_START));
            }
         }

         // ZQCAL_LATCH doesnot need wait timer. tZQLAT timing is already taken care while
         // executing ZQCAL_LATCH. Hence set the wait timer to 0.
         BIMC_Wait_Timer_Setup_sdi ((DDR_CHANNEL)ch_1hot, WAIT_XO_CLOCK, 0);

         HWIO_OUTXF2 (reg_offset_shke, SHKE_DRAM_MANUAL_0, RANK_SEL, ZQCAL_LATCH, chip_select, 1);
         while (HWIO_INXF (reg_offset_shke, SHKE_DRAM_MANUAL_0, ZQCAL_LATCH));
      }
   }
}



void DDRSS_ddr_phy_sw_freq_switch_sdi (DDR_STRUCT *ddr, uint8 ch)
{

    uint32   reg_offset_ddr_phy = 0;
    uint8 sw_handshake_complete = 1;

    // Configure the DDR PHY address offset
    reg_offset_ddr_phy = REG_OFFSET_DDR_PHY_CH(ch);

    // Enable broadcast mode for 4 DQ PHYs and 2 CA PHYs
    HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET), AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 0x3F << (ch * 7));

    /// set FPM_INIT_START to 1 to start frequency switch
    DDR_PHY_hal_cfg_sw_handshake_start_sdi (ddr, BROADCAST_BASE);

    /// Poll for DDRPHY_FPM_TOP_STA[FPM_SW_INIT_COMP]
    while (sw_handshake_complete == 0x1) {
      sw_handshake_complete = ((0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + CA0_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_FPM_TOP_STA))>>1)) |
                               (0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + DQ0_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_FPM_TOP_STA))>>1)) |
                               (0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + DQ1_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_FPM_TOP_STA))>>1)));// |
    }

    /// set FPM_INIT_START to 0 to stop frequency switch
    DDR_PHY_hal_cfg_sw_handshake_stop_sdi (ddr, BROADCAST_BASE);

    // Poll for handshake complete
    while (sw_handshake_complete == 0x0) {
      sw_handshake_complete = ((0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + CA0_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_FPM_TOP_STA))>>1)) &
                               (0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + DQ0_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_FPM_TOP_STA))>>1)) &
                               (0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + DQ1_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_FPM_TOP_STA))>>1)));// &
    }

    /// disable software trigger handshake, and enable hardware FPM
    DDR_PHY_hal_cfg_sw_handshake_complete_sdi (BROADCAST_BASE);

    // Disable broadcast mode
    HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET), AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 0x0);
}


//================================================================================================//
// DDR PHY and CC Initialization
//================================================================================================//
void DDR_PHY_CC_init_sdi (DDR_STRUCT *ddr, DDR_CHANNEL channel)
{
   uint8    ch = 0;
   uint32   reg_offset_ddr_phy;
   uint8    ca0_master;
//   uint8    ca1_master;
   uint32   iocal_done = 0x0;
//   uint32   sw_handshake_complete = 0x1;
   
   for (ch = 0; ch < NUM_CH; ch++)
   {
      reg_offset_ddr_phy = REG_OFFSET_DDR_PHY_CH(ch);

      if ((channel >> ch) & 0x1)
      {

          //turn on LVDS terminiation for DQ0 and DQ3 PHY         
         // Initialize polling variables
         iocal_done            = 0x0;
         ca0_master = 1;
        
         // Initiate IO Calibration for the DDR PHY CA Master 
         DDR_PHY_hal_cfg_sw_iocal_sdi (reg_offset_ddr_phy + CA0_DDR_PHY_OFFSET, ca0_master ); 

         // Enable broadcast mode for 4 DQ and 2 CA PHYs 
         HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET), 
                    AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 
                    0x3f << (ch * 7));

         // Initiate DQ Calibration with PHY DQ broadcast
         DDR_PHY_hal_cfg_sw_iocal_sdi (BROADCAST_BASE, 0x0 );

         /// poll for IOCAL_DONE to be asserted for all PHYs
         while (iocal_done == 0x0) {
           iocal_done = ((0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + CA0_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_IOCTLR_TOP_1_STA))>>12)) & 
                         (0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + DQ0_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_IOCTLR_TOP_1_STA))>>12)) & 
                         (0x00000001 & ((HWIO_INX (reg_offset_ddr_phy + DQ1_DDR_PHY_OFFSET, DDR_PHY_DDRPHY_IOCTLR_TOP_1_STA))>>12)));// & 
         }

        // Disable broadcast mask
        HWIO_OUTX((DDR_PHY_SS_BASE + SEQ_DDR_SS_DDRSS_AHB2PHY_SWMAN_OFFSET),
                  AHB2PHY_SWMAN_AHB2PHY_BROADCAST_EN_CFG_LOWER, 0x0);

        // Load the register settings by doing a SW freq switch
        DDRSS_ddr_phy_sw_freq_switch_sdi(ddr, ch);

     }
   }
}
 


void DDR_PHY_hal_cfg_sw_handshake_complete_sdi( uint32 _inst_ )
{
    uint8 FPM_BYPASS_EN_0 = 0;
    ///  FPM bypass only handshake signals generated by FPM
    uint8 FPM_SW_HDSHAKE_EN_0 = 0;
    ///  FPM SW handshake mode
    uint8 BYPASS_COMPLETE_1 = 1;
    
    uint32 tmp;
    
    ///  COMPLETE signal in BYPASS mode for debug purposes
    ///  Enable the PHY FPM HW mode
    tmp = (0x600003 & 0xFF9F00F9)    | 
          (0x0 << 8)                 | 
          (FPM_SW_HDSHAKE_EN_0 << 2) | 
          (BYPASS_COMPLETE_1 << 21)  | 
          (FPM_BYPASS_EN_0 << 1)     | 
          (FPM_BYPASS_EN_0 << 22);
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_FPM_CNTRL_CFG, tmp);
    
    tmp = (0x600003 & 0xFF1F00F9)    | 
          (0x0 << 23)                | 
          (0x0 << 8)                 | 
          (FPM_SW_HDSHAKE_EN_0 << 2) | 
          (BYPASS_COMPLETE_1 << 21)  | 
          (FPM_BYPASS_EN_0 << 1)     | 
          (FPM_BYPASS_EN_0 << 22);
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_FPM_CNTRL_CFG, tmp);
}


void DDR_PHY_hal_cfg_sw_handshake_stop_sdi( DDR_STRUCT *ddr, uint32 _inst_ )
{
    uint32 fpm_period  = 0;
    uint8 fpm_period_1 = 0;
    uint8 fpm_period_2 = 0;
    uint8 fpm_period_3 = 0;
    ///  FPM Period derived from clk_freq_khz
    uint8 FPM_EN_1 = 1;
    uint8 FPM_SW_HDSHAKE_EN_1 = 1;
    ///  Enable FPM SW handshake mode
    uint8 FPM_BYPASS_EN_0 = 0;
    ///  disable FPM bypass only handshake signals generated by FPM
    uint8 FPM_INIT_START_0 = 0;  
    uint32 tmp;
  uint32 clk_freq_khz;
    
  clk_freq_khz = ddr->misc.new_clk_in_kHz;
    ///  set FPM_INIT_START to 0
    ///  Calculate the fpm period
    fpm_period = (CONVERT_CYC_TO_PS / clk_freq_khz);  
    fpm_period_1 = fpm_period & 0xFF;
    fpm_period_2 = fpm_period >>8 & 0xF;
    fpm_period_3 = fpm_period >>12 & 0x1F;

    ///  de-assert init_start
    tmp = (0x080 & 0xFFFFFFEF) | 
            (FPM_EN_1 << 4);
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_TOP_CTRL_0_CFG, tmp);
    
    tmp = (0x600003 & 0xFF3F00F1) | 
          (FPM_INIT_START_0 << 3) | 
          (0x1 << 23)             | 
          (fpm_period_1 << 8)     | 
          (fpm_period_2 << 4)     |
          (fpm_period_3 << 25)    | 
          (FPM_BYPASS_EN_0 << 1)  | 
          (FPM_BYPASS_EN_0 << 22) | 
          (FPM_SW_HDSHAKE_EN_1 << 2);

    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_FPM_CNTRL_CFG, tmp);
    ///  1 = selects period from CSR source, 0 = select from primary input
}


void DDR_PHY_hal_cfg_sw_handshake_start_sdi( DDR_STRUCT *ddr, uint32 _inst_ )
{
    uint8 FPM_EN_1 = 1;
    uint32 fpm_period  = 0;
    uint8 fpm_period_1 = 0;
    uint8 fpm_period_2 = 0;
    uint8 fpm_period_3 = 0;
    ///  Enable FPM. Set 0 to disable/clock gate FPM. If set frequency switch can be done only through SW
    uint8 FPM_SW_HDSHAKE_EN_1 = 1;
    ///  Enable FPM SW handshake mode
    uint8 FPM_INIT_START_1 = 1;
    ///  set FPM_INIT_START to 1
    uint8 FPM_BYPASS_EN_0 = 0;
    ///  disable FPM bypass only handshake signals generated by FPM      
    uint32 tmp;
  uint32 clk_freq_khz;
  
    clk_freq_khz = ddr->misc.new_clk_in_kHz;
    ///  FPM Period derived from clk_freq_khz
    ///  Do a SW frequency switch to load the FPM period into the PHY
    ///  Calculate the fpm period 
    fpm_period = (CONVERT_CYC_TO_PS / clk_freq_khz);
    fpm_period_1 = fpm_period & 0xFF;
    fpm_period_2 = fpm_period >>8 & 0xF;
    fpm_period_3 = fpm_period >>12 & 0x1F;      

    ///  Assert init_start
    tmp = (0x080 & 0xFFFFFFEF) | (FPM_EN_1 << 4);
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_TOP_CTRL_0_CFG, tmp);
    
    tmp = (0x600003 & 0xFF3F00F9) | 
          (0x1 << 23)             | 
          (fpm_period_1 << 8)     | 
          (fpm_period_2 << 4)     |
          (fpm_period_3 << 25)    | 
          (FPM_BYPASS_EN_0 << 1)  | 
          (FPM_BYPASS_EN_0 << 22) | 
          (FPM_SW_HDSHAKE_EN_1 << 2);    

    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_FPM_CNTRL_CFG, tmp);
    
    ///  1 = selects period from CSR source, 0 = select from primary input
    tmp = (0x600003 & 0xFF3F00F1) | 
          (FPM_INIT_START_1 << 3) | 
          (0x1 << 23)             | 
          (fpm_period_1 << 8)     | 
          (fpm_period_2 << 4)     |
          (fpm_period_3 << 25)    |  
          (FPM_BYPASS_EN_0 << 1)  | 
          (FPM_BYPASS_EN_0 << 22) | 
          (FPM_SW_HDSHAKE_EN_1 << 2);    

    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_FPM_CNTRL_CFG, tmp);
    ///  1 = selects period from CSR source, 0 = select from primary input
}


void DDR_PHY_hal_cfg_sw_iocal_sdi( uint32 _inst_, uint8 master_phy )
{

    ///  To minimize power consumption due to unnecessary toggling of the 'o_spdm_clk', set DDRPHY_TOP_TEST_CFG.SPDM_EN to 0x0
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_TOP_TEST_CFG, 0xC30000);
    ///  set master phy bit
    if (master_phy) {
        HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_UPDATE_INTF_CFG, 0x3000);
    }
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_IOCTLR_CTRL_CFG, 0x4E038080);
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_IOCTLR_CTRL_CFG, 0xCE038080);
    HWIO_OUTX (_inst_, DDR_PHY_DDRPHY_IOCTLR_CTRL_CFG, 0x4E038080);
}




// MCCC_Config --- one time settings through new MCCC calculator, Need to have a parser for this new calculator
void MCCC_Config_sdi(DDR_STRUCT *ddr)
{
   Set_config_sdi(MCCC_BASE, mccc_regs_config_sdi);   // MCCC general registers
   Set_config_sdi(REG_OFFSET_MCCC_CH(0), mccc_ch_regs_config_sdi);    // MCCC Ch0 registers
   Set_config_sdi(REG_OFFSET_MCCC_CH(1), mccc_ch_regs_config_sdi);    // MCCC Ch1 registers
}

 

 
// Cold Boot Initialization
boolean MCCC_Init_sdi(DDR_STRUCT *ddr, DDR_CHANNEL channel)
{

   uint32 new_period_ps   = 0;
   uint8  ch              = 0;
   uint32 init_clk_khz, ddrcc_gcc_boundary_freq;
   uint32 ddrcc_clk_index;

   // One-time settings
   MCCC_Config_sdi(ddr);

   init_clk_khz = ddr->misc.current_clk_in_kHz;
   new_period_ps = CONVERT_CYC_TO_PS / init_clk_khz; //unit in ps
   
   // Calculate and program the Band 1 threshold in psec (at the GCC/DDRCC freq threshold).
   // Walk through the table to figure out where the boundary between GCC and DDRCC clock modes
   //    (clk_mode 0 and clk_mode 1) is.
   for (ddrcc_clk_index = 0; ddrcc_clk_index < MAX_NUM_CLOCK_PLAN; ddrcc_clk_index++)
   { 
      if (ddr->misc.clock_plan[ddrcc_clk_index].clk_mode == 1)
      {
         break;
      }
   }
   
   if (ddrcc_clk_index == MAX_NUM_CLOCK_PLAN)
   {
      // If we went past the end of the table (ie, everything is GCC, then set the boundary freq just above 
      //    the last freq.
      ddrcc_gcc_boundary_freq = ddr->misc.clock_plan[MAX_NUM_CLOCK_PLAN-1].clk_freq_in_khz + 50;
   }
   else
   {
     // The GCC/DDRCC boundary point is within the table.  It is just halfway between the first DDRCC freq 
     //    and the last GCC freq
     ddrcc_gcc_boundary_freq = (ddr->misc.clock_plan[ddrcc_clk_index].clk_freq_in_khz 
                                          + ddr->misc.clock_plan[ddrcc_clk_index-1].clk_freq_in_khz ) / 2;
   }

  // Program the GCC/DDRCC boundary freq in psec.
  // Overwrites the definition from mccc_config.c.
   HWIO_OUTXF (REG_OFFSET_MCCC, MCCC_REGS_BAND1_UPPER_FREQ_THRESHOLD, THRESHOLD_PERIOD, 
                                CONVERT_CYC_TO_PS / ddrcc_gcc_boundary_freq);

   // Program the init period
   HWIO_OUTX (REG_OFFSET_MCCC, MCCC_REGS_CLK_PERIOD, new_period_ps);

   // Channel CSR config
   for (ch = 0; ch < NUM_CH; ch++)
   {
      if (channel>>ch & 0x1)
      {
         // Enable mccc_clk
         HWIO_OUTXF (REG_OFFSET_MCCC_CH(ch), MCCC_CH_REGS_CLK_CBCR, CLK_ENABLE, 1);

         // Enable mc_clk
         HWIO_OUTXF (REG_OFFSET_MCCC_CH(ch), MCCC_CH_REGS_MC_CLK_CBCR, CLK_ENABLE, 1);

      }
   }

  return TRUE;
}


// MCCC clk and MC clk CBCR enable for successful CSR writes
void MCCC_Clk_CBCR_Enable_sdi(DDR_STRUCT *ddr, DDR_CHANNEL channel)
{
   uint8 ch = 0;

   for (ch = 0; ch < NUM_CH; ch++)
   {
      if (channel>>ch & 0x1)
      {
         // Enable mccc_clk
         HWIO_OUTXF (REG_OFFSET_MCCC_CH(ch), MCCC_CH_REGS_CLK_CBCR, CLK_ENABLE, 1);

         // Enable mc_clk
         HWIO_OUTXF (REG_OFFSET_MCCC_CH(ch), MCCC_CH_REGS_MC_CLK_CBCR, CLK_ENABLE, 1);
      }
   }
}

