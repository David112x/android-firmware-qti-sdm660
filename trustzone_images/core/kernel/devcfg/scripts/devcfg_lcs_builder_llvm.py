#===============================================================================
# Device Config Linker Script Builder, LLVM
#
# GENERAL DESCRIPTION
#    Contains builder(s) definitions
#
# Copyright (c) 2014-16 by QUALCOMM, Technologies Inc.
# All Rights Reserved.
# QUALCOMM Proprietary/GTDR
#===============================================================================

import os
import subprocess
import string
from SCons.Script import *

#------------------------------------------------------------------------------
# Globals
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Hooks for Scons
#------------------------------------------------------------------------------
def exists(env):
   return True

def generate(env):
   """
   Generate function for devcfg lcs builder. 
   Generates devcfg linker script
   """
   
   rootenv = env.get('IMAGE_ENV')
   # Devcfg linker script generator
   devcfg_lcs_act = env.GetBuilderAction(devcfg_lcs_builder, action_source=None)
   devcfg_lcs_target_scan = env.Scanner(devcfg_lcs_target_scan_func, name='DevCfgTargetScanner')
   devcfg_lcs_bld = env.Builder(action = devcfg_lcs_act,
                                target_scanner = devcfg_lcs_target_scan,
                                suffix = '.lcs')
   rootenv.Append(BUILDERS = {'DevcfgLCSBuilder' : devcfg_lcs_bld})
   
   return
   
def devcfg_lcs_target_scan_func(node, env, path):
   env.Depends(node, env.Value(env.get('QSEE_OEM_ENV').get('DEVCFG').getFeature('DEVCFG_INFO_COLLECTOR')))
   env.Depends(node, env.Value(env.get('HYP_OEM_ENV').get('DEVCFG').getFeature('DEVCFG_INFO_COLLECTOR')))
   return []

   
def devcfg_lcs_builder(target, source, env):
   """
   source: lcs template file name with location
   """
   rootenv = env.get('IMAGE_ENV')
   
   if rootenv.GetUsesFlag('USES_DEVCFG') is False:
      return None
     
   # The output linker script file name
   lcs_fn = env.RealPath(str(target[0]))
   create_devcfg_lcs_file(rootenv, lcs_fn)
   
def create_devcfg_lcs_file(env, output_devcfg_lcs_file):
   """
   This creates the output linker script for devcfg image
   INPUTS:
   env: Build environment
   template_file: Template filename that the linker script will be based off of
   devcfg_hdr_filename: The devcfg header file that will contain the addressed
   of the segments. These will be reserved in the primary elf
   OUTPUT:
   output_devcfg_lcs_file: Generated devcfg lcs file   
   """

   qsee_env         = env.get('QSEE_OEM_ENV')
   hyp_env          = env.get('HYP_OEM_ENV')
   env_list         = [hyp_env, qsee_env]
   hyp_source_list  = []
   tz_source_list   = []
   #Collect source list for both QSEE(tz) and HYP
   for environment in env_list:
       devcfg_xml_list = environment.get('DEVCFG').getFeature('devcfgXMLTagList')
       for tag in devcfg_xml_list:
           for build_tag in environment.get('BUILD_TAGS'):
               if 'DAL_DEVCFG_OEM_HYP_IMG' == build_tag:
                   hyp_source_list.extend(environment.get('DEVCFG').getFeature('DEVCFG_INFO_COLLECTOR').get(build_tag,{}).get('cc_'+tag,[]))
               if 'DAL_DEVCFG_OEM_QSEE_IMG' == build_tag:
                   tz_source_list.extend(environment.get('DEVCFG').getFeature('DEVCFG_INFO_COLLECTOR').get(build_tag,{}).get('cc_'+tag,[]))
   		  
   try:
      lcsf = open(output_devcfg_lcs_file, 'w')
   except IOError:
      err_str = " Couldn't open file: " + output_devcfg_lcs_file + "for writing\n"
      devcfg_lcs_error(err_str)
   
   template = '''/*===========================================================================
#
# FILE:         devconfig_data.scl
#
# DESCRIPTION:  Linker File for deviceconfig image
#
# AUTOGENERATED, DON NOT MODIFY THIS FILE
===========================================================================*/
#include "customer.h"
\n'''

   lcsf.write(template)
   segement = '''PHDRS {
  DEVCFG_DATA_SEG_TZ PT_LOAD;
  DEVCFG_DATA_SEG_HYP PT_LOAD;
}\n'''
   lcsf.write(segement)
   lcsf.write('SECTIONS {\n')
   #------------------------------------------------------------------------------
   # Linker Rule for QSEE Data
   #------------------------------------------------------------------------------
   lcsf.write('''
   DEVCFG_DATA_TZ (DEVCFG_OEM_BASEADDR):
   {
''')
   file_name_ext = 'DevCfgSegInfo_' + qsee_env.get('DEVCFG').getFeature('targetImg')+'.o'
   lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   for tag in qsee_env.get('DEVCFG').getFeature('devcfgXMLTagList'):
      id = str(tag).split("_")[0]
      file_name_ext = id + "_data_oem_tz.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
      file_name_ext = "DevCfg_" + id + "_oem_tz.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   for file in tz_source_list:
      file_path = qsee_env.RealPath(str(file))
      file_name_ext = os.path.basename(file_path)
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   lcsf.write('''      ASSERT(SIZEOF(DEVCFG_DATA_TZ) <= DEVCFG_DATA_TZ_SZ, "Oversize");\n   }:DEVCFG_DATA_SEG_TZ\n''')
   
  
   #------------------------------------------------------------------------------
   # Linker Rule for HYP Data
   #------------------------------------------------------------------------------
   lcsf.write('''
   DEVCFG_DATA_HYP (DEVCFG_DATA_HYP_ADDR):
   {
''')
   file_name_ext = 'DevCfgSegInfo_' + hyp_env.get('DEVCFG').getFeature('targetImg')+'.o'
   lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   for tag in hyp_env.get('DEVCFG').getFeature('devcfgXMLTagList'):
      id = str(tag).split("_")[0]
      file_name_ext = "DevCfgSegInfo_" + id + "_oem_hyp.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
      file_name_ext = id + "_data_oem_hyp.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
      file_name_ext = "DevCfg_" + id + "_oem_hyp.o"
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   for file in hyp_source_list:
      file_path = hyp_env.RealPath(str(file))
      file_name_ext = os.path.basename(file_path)
      lcsf.write("      KEEP(*\\" + file_name_ext + " (.rodata* .data* .sdata*))\n")
   lcsf.write('''      ASSERT(SIZEOF(DEVCFG_DATA_HYP) <= DEVCFG_DATA_HYP_SZ, "Oversize");\n     }:DEVCFG_DATA_SEG_HYP\n''')
   
   others = '''\n  .got : { * (.got) }
  .got.plt : { * (.got.plt) }
  .debug 0 : { *(.debug) }
  .line 0 : { *(.line) }

  .debug_srcinfo 0 : { *(.debug_srcinfo) }
  .debug_sfnames 0 : { *(.debug_sfnames) }

  .debug_aranges 0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }

  .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev 0 : { *(.debug_abbrev) }
  .debug_line 0 : { *(.debug_line) }
  .debug_frame 0 : { *(.debug_frame) }
  .debug_str 0 : { *(.debug_str) }
  .debug_loc 0 : { *(.debug_loc) }
  .debug_macinfo 0 : { *(.debug_macinfo) }

  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames 0 : { *(.debug_varnames) }

  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges 0 : { *(.debug_ranges) }
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
  .note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }
  /DISCARD/ : { *(.ARM.exidx*) *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.init) *(.fini)}\n'''

   lcsf.write(others)
   lcsf.write('''}''')
   lcsf.close()
   
   return
    
def devcfg_lcs_error(Info, Info1=None):
   """
   Error handler for devcfg framework. Info can be a string that describes the error and
   Info1 can be any data that needs to be printed along with the error message.
   """
   print Info
   raise Exception(Info)
   