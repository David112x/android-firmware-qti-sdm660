#include "typedef_ultrasound.h"
#include "hexagon_protos.h"

/*
 #####################################################################
 # NOTE:                                                             #
 # For vocodec application, the following functions will not match   #
 # the standard basic_op.h in some corner cases, and therefore it's  #
 # suggested to separate accumulation with multiplication instead.   #                      
 #  - L_mac, L_msu, mac_r, msu_r                                     #
 #                                                                   #
 # Related: cmpy -type                                               #
 #                                                                   #
 #####################################################################
*/


/*___________________________________________________________________________
 |                                                                           |
 |   Constants and Globals                                                   |
 |___________________________________________________________________________|
*/
#define MAX_64 (Word64)0x7fffffffffffffffLL
#define MIN_64 (Word64)0x8000000000000000LL

#define MAX_32 (Word32)0x7fffffffL
#define MIN_32 (Word32)0x80000000L

#define MAX_16 (Word16)0x7fff
#define MIN_16 (Word16)0x8000

/*___________________________________________________________________________
 |                                                                           |
 |   Operators prototypes                                                    |
 |___________________________________________________________________________|
*/
//----------------------------------------------------------------------
// Word16 extract_h(Word32 L_var1);    
// extract high 16-bits
//----------------------------------------------------------------------
#define   extract_h(x)       ((Word16)Q6_R_asrh_R( (x) ))       

//----------------------------------------------------------------------
// Word16 extract_l(Word32 L_var1);  
// extract low 16-bits
//----------------------------------------------------------------------
#define   extract_l(x)       ((Word16)(x))

//----------------------------------------------------------------------
// Word16 rnd(Word32 L_var1);  
// round 32-bit to 16-bit
//----------------------------------------------------------------------
#define   rnd(x)             ((Word16)Q6_R_vrndwh_P_sat((Word64)(x)))

//----------------------------------------------------------------------
// Word16 sature(Word32 L_var1); 
// sature 32-bit integer to 16-bit
//----------------------------------------------------------------------
#define   sature(x)          ((Word16)Q6_R_sath_R( (x) ))

//----------------------------------------------------------------------
// Word16 add(Word16 var1, Word16 var2); 
// short add with saturation
//----------------------------------------------------------------------
#define   add(x, y)          ((Word16)Q6_R_add_RlRl_sat( (x), (y) )) 

//----------------------------------------------------------------------
// Word16 sub(Word16 var1, Word16 var2);  
// short sub with saturation
//----------------------------------------------------------------------
#define   sub(x, y)          ((Word16)Q6_R_sub_RlRl_sat( (x), (y) )) 

//----------------------------------------------------------------------
// Word16 negate(Word16 var1);               
// Short negate
//----------------------------------------------------------------------
#define   negate(x)          ((Word16)Q6_R_sath_R(-Q6_R_sxth_R((x)))) 

//----------------------------------------------------------------------
// Word16 abs_s(Word16 var1);       
// short abs
//----------------------------------------------------------------------
#define   abs_s(x)           ((Word16)Q6_R_sath_R(Q6_R_abs_R( (x) ))) 

//----------------------------------------------------------------------
// Word16 mult(Word16 var1, Word16 var2);    
// Short fractional mult
//----------------------------------------------------------------------
#define   mult(x, y)         ((Word16)Q6_R_asrh_R(Q6_R_mpy_RlRl_s1_sat( (x), (y) )))

//----------------------------------------------------------------------
// Word16 mult_r(Word16 var1, Word16 var2);  
// Short fractional mult with round
//----------------------------------------------------------------------
#define   mult_r(x, y)       ((Word16)Q6_R_asrh_R(Q6_R_mpy_RlRl_s1_rnd_sat( (x), (y) )))

//----------------------------------------------------------------------
// Word16 shl(Word16 var1, Word16 var2);   
// short shift left with saturation
//----------------------------------------------------------------------
#define   shl(x,n)           ((Word16)Q6_R_sath_R(Q6_R_asl_RR_sat(Q6_R_sxth_R((x)),(n))))

//----------------------------------------------------------------------
// Word16 shr(Word16 var1, Word16 var2);   
// short shift right with saturation
//----------------------------------------------------------------------
#define   shr(x,n)           ((Word16)Q6_R_sath_R(Q6_R_asr_RR_sat(Q6_R_sxth_R((x)),(n))))

//----------------------------------------------------------------------
// Word16 shr_r(Word16 var1, Word16 var2);
// shift right by const with round
//----------------------------------------------------------------------
#define   shr_r(x,c)         ((Word16)Q6_R_asr_RI_rnd(Q6_R_sxth_R((x)),(c)-1))

//----------------------------------------------------------------------
// Word32 L_deposit_h(Word16 var1);   
// 16 bit var1 -> MSB,      
//----------------------------------------------------------------------
#define   L_deposit_h(x)     (Q6_R_aslh_R( (x) ))

//----------------------------------------------------------------------
// Word32 L_deposit_l(Word16 var1);       
// 16 bit var1 -> LSB,      
//----------------------------------------------------------------------
#define   L_deposit_l(x)     (Q6_R_sxth_R( (x) ))

//----------------------------------------------------------------------
// Word32 L_add(Word32 L_var1, Word32 L_var2);   
// Long add with sat 
//----------------------------------------------------------------------
#define   L_add(x, y)        (Q6_R_add_RR_sat( (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_sub(Word32 L_var1, Word32 L_var2);  
// Long sub with sat
//----------------------------------------------------------------------
#define   L_sub(x, y)        (Q6_R_sub_RR_sat( (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_negate(Word32 L_var1);              
// Long negate with sat
//----------------------------------------------------------------------
#define   L_negate(x)        (Q6_R_neg_R_sat( (x) ))

//----------------------------------------------------------------------
// Word32 L_abs(Word32 L_var1);   
// Long abs with sat
//----------------------------------------------------------------------
#define   L_abs(x)           (Q6_R_abs_R_sat( (x) ))

//----------------------------------------------------------------------
// Word32 L_mult(Word16 var1, Word16 var2);  
// Long fractional mult (with sat)
//----------------------------------------------------------------------
#define   L_mult(x, y)       (Q6_R_mpy_RlRl_s1_sat( (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_mac(Word32 L_var3, Word16 var1, Word16 var2); 
// Long fractional MAC (with sat)
//----------------------------------------------------------------------
#define   L_mac(z,x,y)       (Q6_R_mpyacc_RlRl_s1_sat( (z), (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_msu(Word32 L_var3, Word16 var1, Word16 var2); 
// mult and sub  (with sat
//----------------------------------------------------------------------
#define   L_msu(z,x,y)       (Q6_R_mpynac_RlRl_s1_sat( (z), (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_macNs(Word32 L_var3, Word16 var1, Word16 var2);
// Mac without sat
//----------------------------------------------------------------------
#define   L_macNs(z,x,y)     (Q6_R_mpyacc_RlRl_s1( (z), (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_msuNs(Word32 L_var3, Word16 var1, Word16 var2);
// Msu without sat
//----------------------------------------------------------------------
#define   L_msuNs(z,x,y)     (Q6_R_mpynac_RlRl_s1( (z), (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_shl(Word32 L_var1, Word16 var2); 
// Long shift left with sat 
//----------------------------------------------------------------------
#define   L_shl(x,n)         (Q6_R_asl_RR_sat( (x),(n) ))

//----------------------------------------------------------------------
// Word32 L_shr(Word32 L_var1, Word16 var2); 
// Long shift right with sat  
//----------------------------------------------------------------------
#define   L_shr(x,n)         (Q6_R_asr_RR_sat( (x),(n) ))

//----------------------------------------------------------------------
// Word16 norm_s(Word16 var1);  
// Short norm,    
//----------------------------------------------------------------------
#define   norm_s(x)          (Q6_R_normamt_R(Q6_R_sxth_R( (x) ))-16)

//----------------------------------------------------------------------
// Word16 norm_l(Word32 L_var1);    
// long norm,    
//----------------------------------------------------------------------
#define   norm_l(x)          (Q6_R_normamt_R( (x) ))

//----------------------------------------------------------------------
// Word16 mac_r(Word32 L_var3, Word16 var1, Word16 var2);
// Mac with rounding
//----------------------------------------------------------------------
#define   mac_r(z,x,y)       (rnd(L_mac( (z), (x), (y) )))

//----------------------------------------------------------------------
// Word16 msu_r(Word32 L_var3, Word16 var1, Word16 var2);
// Msu with rounding
//----------------------------------------------------------------------
#define   msu_r(z,x,y)       (rnd(L_msu( (z), (x), (y) )))

//----------------------------------------------------------------------
// Word32 L_shr_r(Word32 L_var1, Word16 var2);
// Long shift right by const with round
//----------------------------------------------------------------------
#define   L_shr_r(x,c)       (Q6_R_asr_RI_rnd((x),((c)-1)))

#define   L_max                 Q6_R_max_RR
#define   L_min                 Q6_R_min_RR

// ---------
// unsolved
// ---------
// Word32 L_macnoset(Word32 L_var3, Word16 var1, Word16 var2); /* Mac,     */
// Word32 L_add_c(Word32 L_var1, Word32 L_var2); /*Long add with c,   */
// Word32 L_sub_c(Word32 L_var1, Word32 L_var2); /*Long sub with c,   */
// Word32 L_sat(Word32 L_var1);            /* Long saturation,        */
// Word16 div_s(Word16 var1, Word16 var2); /* Short division,        */


/*___________________________________________________________________________
 |                                                                           |
 |   Operators prototypes  (extended)                                        |
 |___________________________________________________________________________|
*/
//----------------------------------------------------------------------
// Word32 max(Word32 x, Word32 y);
// max
//----------------------------------------------------------------------
#define   max(x, y)          (Q6_R_max_RR( (x), (y) ))

//----------------------------------------------------------------------
// Word32 min(Word32 x, Word32 y);
// min
//----------------------------------------------------------------------
#define   min(x, y)          (Q6_R_min_RR( (x), (y) ))

//----------------------------------------------------------------------
// Word32 L_asl(Word32 L_var1, Word16 var2); 
// Long shift left 
//----------------------------------------------------------------------
#define   L_asl(x,n)         (Q6_R_asl_RR( (x),(n) ))

//----------------------------------------------------------------------
// Word32 L_asr(Word32 L_var1, Word16 var2); 
// Long shift right
//----------------------------------------------------------------------
#define   L_asr(x,n)         (Q6_R_asr_RR( (x),(n) ))

//----------------------------------------------------------------------
// Word32 clb(Word32 x);
// count leading bits
//----------------------------------------------------------------------
#define   clb(x)             (Q6_R_clb_R( (x) ))

//----------------------------------------------------------------------
// Word32 cl0(Word32 x);
// count leading zero bits
//----------------------------------------------------------------------
#define   cl0(x)             (Q6_R_cl0_R( (x) ))

//----------------------------------------------------------------------
// Word64 L_combine(Word32 x, Word32 y);
// deposit x and y as MSB and LSB of long long
//----------------------------------------------------------------------
#define   L_combine          Q6_P_combine_RR

//----------------------------------------------------------------------
// Word32 L_mult32x16r(Word32 var1, Word16 var2);
// 32x16 multiply (fractional)
//----------------------------------------------------------------------
#define   L_mult32x16r(x, y) (Q6_R_mpy_RRl_s1_rnd_sat( (x), (y) ))    

//----------------------------------------------------------------------
// Word32 L_mult32(Word32 var1, Word32 var2);     
// 32x32 integer multiply and  take upper result(no sat)
//----------------------------------------------------------------------
#define   L_mult32(x, y)     (Q6_R_mpy_RR( (x), (y) ))  

//----------------------------------------------------------------------
// Word32 L_mult32r(Word32 var1, Word32 var2);     
// 32x32 integer multiply and  take upper result( with round)
//----------------------------------------------------------------------
#define   L_mult32r(x, y)     (Q6_R_mpy_RR_rnd( (x), (y) ))  


//----------------------------------------------------------------------
// Word32 L_mult32u(Word32 var1, Word32 var2);     
// unsigned 32x32 integer multiply and  take upper result(no sat)
//----------------------------------------------------------------------
#define   L_mult32u(x, y)     (Q6_R_mpyu_RR( (x), (y) ))  

//----------------------------------------------------------------------
// Word32 L_sat(Word64 L_var);              
// saturate 64 bit to 32 bit               
//----------------------------------------------------------------------
#define   L_sat(x)           (Q6_R_sat_P( (x) ))

//----------------------------------------------------------------------
// Word64  LL_shl(Word64 x, Word32 n);
// long long shift left 
//----------------------------------------------------------------------
#define   LL_shl(x, n)       (Q6_P_asl_PR((x),(n)))

//----------------------------------------------------------------------
// Word64  LL_shr(Word64 x, Word32 n);
// long long shift right 
//----------------------------------------------------------------------
#define   LL_shr(x, n)       (Q6_P_asr_PR((x),(n)))

//----------------------------------------------------------------------
// Word64  LL_mult32(Word32 x, Word32 32);
// signed 32x32 multiply with 64-bit result 
//----------------------------------------------------------------------
#define   LL_mult32(x, y)     (Q6_P_mpy_RR((x),(y)))

//----------------------------------------------------------------------
// Word64  LL_mult32u(Word32 x, Word32 32);
// unsigned 32x32 multiply with 64-bit result 
//----------------------------------------------------------------------
#define   LL_mult32u(x, y)    (Q6_P_mpyu_RR((x),(y)))

/*___________________________________________________________________________
 |                                                                           |
 |   Operators prototypes  for Complex number (extended)                     |
 |___________________________________________________________________________|
*/
//----------------------------------------------------------------------
// Word16 real(CWord2x16 x);     
// get real part of complex number
//----------------------------------------------------------------------
#define  real(x)             (extract_l( (x) ))

//----------------------------------------------------------------------
// Word16 imag(CWord2x16 x);     
// get imag part of complex number
//----------------------------------------------------------------------
#define  imag(x)             (extract_h( (x) ))

//----------------------------------------------------------------------
// CWord2x16 complex(Word16 xr, Word16 xi);     
// get imag part of complex number
//----------------------------------------------------------------------
#define  complex(xr,xi)      (Q6_R_combine_RlRl( (xi), (xr) ))

//----------------------------------------------------------------------
// Word32 real(CWord2x32 x);     
// get real part of complex number
//----------------------------------------------------------------------
#define  L_real(x)           ((Word32)(x))

//----------------------------------------------------------------------
// Word32 imag(CWord2x32 x);     
// get imag part of complex number
//----------------------------------------------------------------------
#define  L_imag(x)           ((Word32)((x)>>32))

//----------------------------------------------------------------------
// CWord2x32 complex(Word32 xr, Word16 32);     
// get imag part of complex number
//----------------------------------------------------------------------
#define  L_complex(xr,xi)      (Q6_P_combine_RR( (xi), (xr) ))

//----------------------------------------------------------------------
// CWord2x16 conjugate(CWord2x16 x);     
// Complex add (with sat)
//----------------------------------------------------------------------
#define   conjugate(x)         ((CWord2x16)Q6_P_vconj_P_sat( (x) ))

//----------------------------------------------------------------------
// CWord2x16 cadd(CWord2x16 var1, CWord2x16 var2);     
// Complex add (with sat)
//----------------------------------------------------------------------
#define   cadd(x, y)         (Q6_R_vaddh_RR_sat( (x), (y) ))

//----------------------------------------------------------------------
// CWord2x16 csub(CWord2x16 var1, CWord2x16 var2);     
// Complex sub (with sat)
//----------------------------------------------------------------------
#define   csub(x, y)         (Q6_R_vsubh_RR_sat( (x), (y) ))

//----------------------------------------------------------------------
// Word2x16 cmult_r(Word2x16 var1, Word2x16 var2);     
// Complex mult and round
//----------------------------------------------------------------------
#define   cmult_r(x, y)      (Q6_R_cmpy_RR_s1_rnd_sat( (x), (y) )) 

//----------------------------------------------------------------------
// Word2x16 cmult_cr(Word2x16 var1, Word2x16 var2);     
// Complex mult
//----------------------------------------------------------------------
#define   cmult_cr(x, y)     (Q6_R_cmpy_RR_conj_s1_rnd_sat( (x), (y) )) 

//----------------------------------------------------------------------
// CWord2x32 L_cmult(Word2x16 var1, Word2x16 var2);     
// Complex mult
//----------------------------------------------------------------------
#define   L_cmult(x,y)       (Q6_P_cmpy_RR_s1_sat( (x), (y) )) 

//----------------------------------------------------------------------
// CWord2x32 L_cmult_c(CWord2x16 x, CWord2x16 y);     
// L_cmpy(var1, conj(var2))
//----------------------------------------------------------------------
#define   L_cmult_c          Q6_P_cmpy_RR_conj_s1_sat 

//----------------------------------------------------------------------
// CWord2x32 L_cmac(CWord2x32 var, CWord2x16 x, CWord2x16 y);     
// Complex mac
//----------------------------------------------------------------------
#define   L_cmac             Q6_P_cmpyacc_RR_s1_sat 

//----------------------------------------------------------------------
// CWord2x32 L_cmac_c(CWord2x32 var, CWord2x16 x, CWord2x16 y);     
// L_cmac(var, var1, conj(var2))
//----------------------------------------------------------------------
#define   L_cmac_c           Q6_P_cmpyacc_RR_conj_s1_sat 

//----------------------------------------------------------------------
// CWord2x32 L_cmsu(CWord2x32 var, CWord2x16 x, CWord2x16 y);     
// Complex msu
//----------------------------------------------------------------------
#define   L_cmsu             Q6_P_cmpynac_RR_s1_sat 

//----------------------------------------------------------------------
// CWord2x32 L_cmsu_c(CWord2x32 var, CWord2x16 x, CWord2x16 y);     
// L_cmsu(var, var1, conj(var2))
//----------------------------------------------------------------------
#define   L_cmsu_c           Q6_P_cmpynac_RR_conj_s1_sat 

//----------------------------------------------------------------------
// CWord2x16  cavg(CWord2x16 x, CWord2x16 y);                                
// Average two complex numbers with convergent rounding
//----------------------------------------------------------------------  
#define   cavg               Q6_P_vavgh_PP_crnd

//----------------------------------------------------------------------
// CWord2x16 cnavg(CWord2x16 x, CWord2x16 y);
// Average a complex number with the negation of another
// and apply convergent rounding.
//----------------------------------------------------------------------
#define   cnavg              Q6_P_vnavgh_PP_crnd_sat

/*___________________________________________________________________________
 |                                                                           |
 |   Operators prototypes  for Vector (extended)                             |
 |___________________________________________________________________________|
*/
//----------------------------------------------------------------------
// Word64 L_Vadd(Word64 x, Word64 y);
// Vector add long
//----------------------------------------------------------------------
#define   L_Vadd             Q6_P_vaddw_PP_sat

//----------------------------------------------------------------------
// Word64 L_Vadd(Word64 x, Word64 y);
// Vector sub long
//----------------------------------------------------------------------
#define   L_Vsub             Q6_P_vsubw_PP_sat

//----------------------------------------------------------------------
// Word64 L_Vmpy32x16(Word64 x, Word64 y);
// Vector 32x16 mult
//----------------------------------------------------------------------
#define   L_Vmpy32x16        Q6_P_vmpyweh_PP_s1_rnd_sat

//----------------------------------------------------------------------
// Word64 L_Vmpy32x16u(Word64 x, Word64 y);
// Vector 32-bit sign mult by 16-bit unsigned
//----------------------------------------------------------------------
#define   L_Vmpy32x16u       Q6_P_vmpyweuh_PP_s1_rnd_sat

//----------------------------------------------------------------------
// Word64 L_Vsxt(Word32 x)
// Vector sign extend short to long
//----------------------------------------------------------------------
#define   L_Vsxt             Q6_P_vsxthw_R     

//----------------------------------------------------------------------
// Word64 L_Vasl(Word64 x, Word32 n)
// Vector shift left long
//----------------------------------------------------------------------
#define   L_Vasl             Q6_P_vaslw_PR

//----------------------------------------------------------------------
// Word64 L_Vasl(Word64 x, Word32 n)
// Vector shift right long
//----------------------------------------------------------------------
#define   L_Vasr             Q6_P_vasrw_PR

//----------------------------------------------------------------------
// Word32 L_Vrnd(Word64 x)
// Vector rnd long to short
//----------------------------------------------------------------------
#define   Vrnd               Q6_R_vrndwh_P

//----------------------------------------------------------------------
// Word32 L_Vsat(Word64 x)
// Vector sat long to short
//----------------------------------------------------------------------
#define   Vsat               Q6_R_vsatwh_P

//----------------------------------------------------------------------
// Word32 L_Vextract_l(Word64 x, Word64 y)
// Vector extract low
//----------------------------------------------------------------------
#define   Vextract_l         Q6_P_vtrunewh_PP

//----------------------------------------------------------------------
// Word32 L_Vextract_h(Word64 x, Word64 y)
// Vector extract high
//----------------------------------------------------------------------
#define   Vextract_h         Q6_P_vtrunowh_PP


/*___________________________________________________________________________
 |                                                                           |
 |   Operators prototypes  for speical functions(extended)                   |
 |___________________________________________________________________________|
*/
//----------------------------------------------------------------------
// Word32 parity(Word64 x, Word64 y)
// Get parity sum
//----------------------------------------------------------------------
#define   parity(x, y)       (Q6_R_parity_PP((Word64)(x), (Word64)(y)))

