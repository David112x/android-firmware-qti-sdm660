/*
============================================================================

FILE:          HAL_rs.h

DESCRIPTION:   Resampler HW driver HAL header file.

                Copyright (c) 2011 Qualcomm Technologies Incorporated.
                All Rights Reserved.
                Qualcomm Confidential and Proprietary	
============================================================================

============================================================================
  EDIT HISTORY FOR MODULE

  when        who  what, where, why
  ----------  ---  -----------------------------------------------------------
  2011-03-21   qm   Initial version.
============================================================================
*/
#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#ifndef HAL_RS_H
#define HAL_RS_H

#include "qurt_elite.h"
#include "common.h" //reg_wr reg_rd

//#include "LPASS_ADDRESS_FILE.h"


#define RESAMPLER_HW_VERSION_2        0x20000000    //All other chips
#define RESAMPLER_HW_VERSION_3        0x30000000    //8996 only
#define RESAMPLER_HW_VERSION_4        0x40000000    //8998 only

#define MAX_JOB_NUM 8
#define MAX_CHANNEL 32                                        //8 for V2 and 32 for V3

//
#define RS_JOB_ONGOING                        RESAMPLER_P0_JOB_STATUS__JOB0__NIL                 //0   
#define RS_JOB_DONE                           RESAMPLER_P0_JOB_STATUS__JOB0__DONE                //1
#define RS_JOB_AHB_ERROR                      RESAMPLER_P0_JOB_STATUS__JOB0__AHB_ERROR           //2
#define RS_JOB_SAMPLE_COUNT_ERROR             RESAMPLER_P0_JOB_STATUS__JOB0__SAMPLE_COUNT_ERROR  //3


typedef enum
{
   CORE_CLOCK = 0,    
   CORE_CLOCK_PERIOD,        
   AHB_CLOCK,    
   AHB_CLOCK_PERIOD,        
   LATENCY
}rs_clock_idx;


/**
* HW resampler power mode
*/
typedef enum
{
   POWER_MODE_XO = 0,
   POWER_MODE_SVS2,
   POWER_MODE_SVS,
   POWER_MODE_NORMAL,
   POWER_MODE_TURBO

}rs_hw_power_mode;

//clock table structure
typedef struct
{
   rs_hw_power_mode power_mode;                
   uint32 core_clock;              // clcok cycle per-sec
   uint32 core_clock_period;       // in (ns * 1000) unit
   uint32 ahb_clock;               // clcok cycle per-sec
   uint32 ahb_clock_period;        // in (ns * 1000) unit
   uint32 latency;                 // in (ns * 1000) unit
} struct_clock_table;


//stream config structure
typedef struct
{
   uint16 submit_job;                // 0:cancel, 1:submit
   uint16 num_channels;              // Number of channels in submitted job
   uint16 job_id;                    // Job ID number submitted or cancelled
   uint16 operation;                 // 1: upsampling, 2: downsampling, 3 both
   uint16 us_coeff_id;               // 0:1344, 1:8096  for V2      0:1632, 1:10880  for V3
   uint16 ds_coeff_id;               // 0:1344          for V2      0:1632           for V3
   uint16 data_width;                // 0:16, 1:32
   uint16 first_frame;               // 0: not first_frame, 1: first_frame
   uint16 us_interp_mode;            // 0: linear, 1: quadratic
   uint16 force_interpol;            // 0: off, 1: on
   uint16 dynamic_mode;              // 0: off, 1: on                                V3 only
} struct_rs_config;

//stream structure
typedef struct
{
   //RESAMPLER_FRAME_SIZE
   uint16 in_frame_size;                 //number of input samples i.e. input frame size                                //Shared for both V2 and V3
   uint16 out_frame_size;                 //number of consumed/generated samples i.e. output frame size                 //Shared for both V2 and V3

   //RESAMPLER_FILT_INDEX_PTRS_I
   uint16 up_sampler_flt_fptr;      //location of the end of the UpSampler filter = ptrDnSampStruct->filtMemOffset      //Shared for both V2 and V3
   uint16 up_sampler_flt_optr;      //location of next sample generated by UPsampler                                    //Shared for both V2 and V3

   //RESAMPLER_FILT_INDEX_PTRS_II
   uint16 resampler_flt_iptr;     //location of next input sample read from memory  = ptrDnSampStruct->inputOffset      //Shared for both V2 and V3
   uint16 dn_sampler_flt_fptr;     //location of the end of the DnSampler Filter                                        //Shared for both V2 and V3
   
   //RESAMPLER_US_CUR_PHASE
   uint32 cur_frac_phase;         //Current fractional phase                                                            //Shared for both V2 and V3
   uint16 cur_int_phase;            //Current Integer phase                                                             //Shared for both V2 and V3
   
   //RESAMPLER_US_FILTER_CONSTS
   uint16 shift_const;              //Shift Constant                                                                    //Shared for both V2 and V3
   uint32 frac_const;             //Fractional Constant                                                                 //Shared for both V2 and V3

   //RESAMPLER_US_PHASE_STEP_SIZE
   uint32 frac_phase_step_size;     //Fractional phase step size                                                        //Shared for both V2 and V3
   uint16 int_phase_step_size;     //Integer phase step size                                                            //Shared for both V2 and V3

   //RESAMPLER_US_OUTPUT_FREQ
   uint32 out_freq;                 //Output frequency                                                                  //Shared for both V2 and V3
   
   //RESAMPLER_DS_CFG
   uint16 dn_factor;                //input stream is divided by this factor                                            //Shared for both V2 and V3
   uint16 dn_step;                  //number of coefficeints that needs to be skipped.                                  //Shared for both V2 and V3
   uint16 dn_filt_mem_size;         //dn sampler filter mem size.                                                       //Shared for both V2 and V3

   //RESAMPLER_FILT_MEM_BASE_ADDR
   uint32 filt_mem_base_addr_phys;     //Starting address Filter States                                                 //Shared for both V2 and V3. It is LSB for V3.

   //LPASS_RESAMPLER_FILT_MEM_BASE_ADDR_MSB
   uint32 filt_mem_base_addr_phys_msb;     //Starting address Filter States                                             //MSB for V3 only.

   //RESAMPLER_STREAM_STATUS_I
   uint32 status_i_value;                                                                                                //Shared for both V2 and V3

   //RESAMPLER_STREAM_STATUS_II
   uint32 status_ii_value;                                                                                               //Shared for both V2 and V3

   //RESAMPLER_STREAM_SPARE
   uint32 spare_value;                                                                                                   //Shared for both V2 and V3

   uint32 inp_buf_addr_phys_ch7_0_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, input buffer for ch 0 to 7.
   uint32 out_buf_addr_phys_ch7_0_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, output buffer for ch 0 to 7.

   uint32 inp_buf_addr_phys_ch15_8_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, input buffer for ch 8 to 15.
   uint32 out_buf_addr_phys_ch15_8_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, output buffer for ch 8 to 15.

   uint32 inp_buf_addr_phys_ch23_16_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, input buffer for ch 16 to 23.
   uint32 out_buf_addr_phys_ch23_16_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, output buffer for ch 16 to 23.

   uint32 inp_buf_addr_phys_ch31_24_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, input buffer for ch 31 to 24.
   uint32 out_buf_addr_phys_ch31_24_offset;                                                                                //V3 only. Four MSB bits for 36 bit address, output buffer for ch 31 to 24.

   //RESAMPLER_INP_BUFF_CH0 ~ CH7
   uint32 inp_buf_addr_phys[MAX_CHANNEL];//address of channel 0-7 input buffer                                             //Shared for both V2 and V3. It is 32 bit LSB for V3.

   //RESAMPLER_OUT_BUFF_CH0 ~ CH7
   uint32 out_buf_addr_phys[MAX_CHANNEL];//address of channel 0-7 outut buffer                                             //Shared for both V2 and V3. It is 32 bit LSB for V3.

   uint32 filt_mem_base_addr;     //Starting address Filter States                                                         //Shared for both V2 and V3. Virtual address, 32 bit only.

   uint32 inp_buf_addr[MAX_CHANNEL];//address of channel 0-7 input buffer                                                  //Shared for both V2 and V3. Virtual address, 32 bit only.
   uint32 out_buf_addr[MAX_CHANNEL];//address of channel 0-7 outut buffer                                                  //Shared for both V2 and V3. Virtual address, 32 bit only.

   uint32 usr_out_buf_addr[MAX_CHANNEL];   //this is for driver itself use                                                 //Shared for both V2 and V3. Virtual address, 32 bit only.

}struct_rs_stream;


#include "hal_rs_func_defs.h"

void HAL_rs_init_common(uint32 base_virt_addr, uint32 hw_version, void* hal_func_def_ptr);

static inline void HAL_rs_init(uint32 base_virt_addr)
{
   return hal_rs_func_def_ptr_g->HAL_rs_init_f(base_virt_addr);
}

static inline void HAL_rs_start(uint16 px, uint16 mask)
{
   return hal_rs_func_def_ptr_g->HAL_rs_start_f(px, mask);
}
static inline uint16 HAL_rs_get_cur_channel(uint16 px)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_cur_channel_f(px);
}

static inline uint16 HAL_rs_get_cur_job_id(uint16 px)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_cur_job_id_f(px);
}

static inline uint16 HAL_rs_get_cur_op_status(uint16 px)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_cur_op_status_f(px);
}

static inline void HAL_rs_set_stream_config(uint16 px, struct_rs_config* ptr_config_struct)
{
   return hal_rs_func_def_ptr_g->HAL_rs_set_stream_config_f(px, ptr_config_struct);
}

static inline void HAL_rs_get_stream_config(uint16 px, struct_rs_config* ptr_config_struct)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_stream_config_f(px, ptr_config_struct);
}

static inline uint16 HAL_get_stream_struct_size(uint16 num_channels)
{
   return hal_rs_func_def_ptr_g->HAL_get_stream_struct_size_f(num_channels);
}

static inline void HAL_rs_set_stream_struct(uint16 px, struct_rs_stream* stream_struct, uint32* ptr_stream_mem, uint32* ptr_stream_mem_phys, uint16 num_channels)
{
   return hal_rs_func_def_ptr_g->HAL_rs_set_stream_struct_f(px, stream_struct, ptr_stream_mem, ptr_stream_mem_phys, num_channels);
}

static inline void HAL_rs_get_stream_struct(uint16 px, struct_rs_stream* stream_struct, uint32* ptr_stream_mem, uint32* ptr_stream_mem_phys)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_stream_struct_f(px, stream_struct, ptr_stream_mem, ptr_stream_mem_phys);
}

static inline boolean HAL_rs_is_ack_valid(uint16 px)
{
   return hal_rs_func_def_ptr_g->HAL_rs_is_ack_valid_f(px);
}

static inline boolean HAL_rs_get_job_accepted_status(uint16 px, uint16 *job_id)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_job_accepted_status_f(px, job_id);
}
static inline void HAL_rs_get_job_done_status(uint16 px, uint16 *ptr_job_array)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_job_done_status_f(px, ptr_job_array);
}

static inline void HAL_rs_set_job_clear(uint16 px, uint16 job_id, uint16 this_job_status)
{
   return hal_rs_func_def_ptr_g->HAL_rs_set_job_clear_f(px, job_id, this_job_status);
}

static inline uint32 HAL_rs_get_estimated_total_clks_hiq(uint16 px)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_estimated_total_clks_hiq_f(px);
}

static inline uint32 HAL_rs_get_estimated_total_clks_loq(uint16 px)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_estimated_total_clks_loq_f(px);
}

static inline void HAL_rs_set_estimated_clks(uint16 px, uint32 clks)
{
   return hal_rs_func_def_ptr_g->HAL_rs_set_estimated_clks_f(px, clks);
}
/////
static inline uint32 HAL_rs_get_upsampler_flt_mem_length(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_upsampler_flt_mem_length_f();
}

static inline uint32 HAL_rs_get_upsampler_flt_coeff_length_hq(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_upsampler_flt_coeff_length_hq_f();
}

static inline uint32 HAL_rs_get_upsampler_flt_coeff_length_shq(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_upsampler_flt_coeff_length_shq_f();
}

static inline uint32 HAL_rs_get_downsampler_flt_coeff_length_hq(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_downsampler_flt_coeff_length_hq_f();
}

static inline uint32 HAL_rs_get_downsampler_flt_coeff_length_shq(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_downsampler_flt_coeff_length_shq_f();
}

static inline uint32 HAL_rs_get_downsampler_flt_output_buf_size(uint16 div_factor)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_downsampler_flt_output_buf_size_f(div_factor);
}

static inline uint32 HAL_rs_get_memory_load_burst_size(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_memory_load_burst_size_f();
}

static inline uint32 HAL_rs_get_parallel_pipeline_num(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_parallel_pipeline_num_f();
}

static inline uint32 HAL_rs_get_data_from_clk_tbl(rs_hw_power_mode power_mode, rs_clock_idx clk_idx)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_data_from_clk_tbl_f(power_mode, clk_idx);
}


static inline rs_hw_power_mode HAL_rs_get_power_mode_lowest(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_power_mode_lowest_f();
}

static inline rs_hw_power_mode HAL_rs_get_power_mode_highest(void)
{
   return hal_rs_func_def_ptr_g->HAL_rs_get_power_mode_highest_f();
}


#endif

#ifdef __cplusplus
}
#endif //__cplusplus


