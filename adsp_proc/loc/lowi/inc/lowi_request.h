#ifndef __LOWI_REQUEST_H__
#define __LOWI_REQUEST_H__


/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

        LOWI Request Interface Header file

GENERAL DESCRIPTION
  This file contains the structure definitions and function prototypes for
  LOWIRequest

Copyright (c) 2012-2013 Qualcomm Atheros, Inc.
  All Rights Reserved.
  Qualcomm Atheros Confidential and Proprietary.

Copyright (c) 2017 Qualcomm Technologies, Inc.
All Rights Reserved.
Qualcomm Technologies Proprietary and Confidential.

=============================================================================*/
#include "lowi_const.h"
#include "lowi_mac_address.h"
#include "lowi_service_v01.h"
#include "lowi_client_handle.h"
#include "vector.h"

namespace qc_loc_fw
{

// Indicates, to provide the cached data only from the last scan results
// Comes as part of the measAgeFilter in request
// Only valid for cache fall-back request
#define LOWI_LATEST_SCAN_RESULTS_MASK 0xFFFFFFFF

// QMI interface allows the fall-back time to be in seconds.
// This mask allows the clients to indicate, if the fall-back time
// should be treated as msec instead.
#define LOWI_MSEC_MASK 0x80000000

/**
 * Base class for all requests LOWI can handle
 */
class LOWIRequest
{
protected:
  static const char* const TAG;
private:
  eSupportedServiceVersion mRequestVersion;
  uint32 mClientId;

public:
  /** Type of Request*/
  enum eRequestType
  {
    DISCOVERY_SCAN,
    RANGING_SCAN,
    CAPABILITY,
    RESET_CACHE,
    ASYNC_DISCOVERY_SCAN_RESULTS,
    WLAN_EVENTS_SUBSCRIPTION,
    WLAN_EVENTS_QUERY,
    BATCHING_SUBSCRIPTION,
    BATCHING_RESULTS,
    BGSCAN_SUBSCRIPTION,
    BGSCAN_RESULTS
  };

public:

  /**
   * Constructor
   * @param eSupportedServiceVersion Version for this request.
   *  This can be different for different major version of the QMI service
   * @param uint32 Unique ID of the Client who made this request
   */
  LOWIRequest (eSupportedServiceVersion version, uint32 client_id);

  /** Destructor*/
  virtual ~LOWIRequest () = 0;

  /** Copy Constructor */
  LOWIRequest( const LOWIRequest& rhs );
  /** Assignment operator */
  LOWIRequest& operator=( const LOWIRequest& rhs );

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  virtual uint32 getRequestId () const = 0;

  /**
   * Returns the Client ID for the client who made this request
   * @return Unique ID of the Client who made this request
   */
  virtual uint32 getClientId () const;

  /**
   * Returns the request version
   * @return Request version
   */
  virtual eSupportedServiceVersion getRequestVersion () const;

  /**
   * Returns the request type
   * @return eRequestType type of request
   */
  virtual eRequestType getRequestType () const = 0;

};

///////////////////////////
// Capability Request
///////////////////////////

/**
 * Capability Request
 */
class LOWICapabilityRequest: public LOWIRequest
{
private:
#if !APSS
  QmiLowiCapabilitiesRequest_v01 mCapabilityRequest;
#endif

public:

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiCapabilitiesRequest_v01* Request message
   */
  LOWICapabilityRequest (uint32 client_id,
      QmiLowiCapabilitiesRequest_v01* req);

  /** Destructor*/
  virtual ~LOWICapabilityRequest ();

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of request
   */
  virtual eRequestType getRequestType () const;
};

///////////////////////////
// Discovery scan Request
///////////////////////////
#if 0
// Forward declaration
class LOWIChannelInfo;
#endif

/**
 * Class to make a Discovery scan request
 */
class LOWIDiscoveryScanRequest: public LOWIRequest
{
public:
  /** Defines the available type of Discovery Scan*/
  enum eScanType
  {
    /**Passive Scan*/
    PASSIVE_SCAN,
    /**Active Scan*/
    ACTIVE_SCAN
  };

  /** Defines the available mode of Discovery Scan Request*/
  enum eRequestMode
  {
    /** Request to perform a Fresh scan. The request will trigger a Request
     * being sent to WifiDriver for fresh scan */
    FORCED_FRESH,
    /** Request to perform Fresh scan with throttling. If the last fresh
     * scan results are relatively fresh then this Request will be serviced
     * from Cache. Criteria to determine freshness is
     * current time < last scan time + threshold (defined in config file)
     */
    NORMAL,
    /** Request to return the result from Cache*/
    CACHE_ONLY,
    /** Request to provide the result from Cache but if results
     * are not found in cache then start the fresh scan*/
    CACHE_FALLBACK
  };

  /** Defines the bands for which the Discovery Scan Request can be made*/
  enum eBand
  {
    /** 2.4 Ghz only*/
    TWO_POINT_FOUR_GHZ,
    /** 5 Ghz only*/
    FIVE_GHZ,
    /** Both (2.5 & 5 Ghz)*/
    BAND_ALL
  };

  /**
   * Returns the scan type
   * @return Passive scan or Active scan
   */
  eScanType getScanType () const;
  /**
   * Returns the request mode
   * @return Mode of request
   */
  eRequestMode getRequestMode () const;
  /**
   * Returns Measurement age filter in milli seconds.
   * For Cache Request, at the time of generating the
   *  response for the request, all the measurements which
   *  are older than Current time - filter age,
   *  will be filtered out from the response.
   *  So '0' age filter could potentially
   *  return no measurements from the cache.
   *
   * For Fresh scan Request, at the time of generating the
   *  response for the request, all the measurements which
   *  are older than Request time to WLAN driver - filter age,
   *  will be filtered out from the response.
   *
   * Note:
   * For Cache Fall Back Request, Client can send a
   * Meas Age Filter as 0xFFFF to indicate to provide only
   * the last scan results. In that case, this API
   * provides the 0 as the filter age.
   *
   * @return Measurement age in msec
  */
  uint32 getMeasAgeFilterMSec () const
  {
    uint32 age = 0;
    if (!(mDiscoveryrequest->measAgeFilterSec & LOWI_LATEST_SCAN_RESULTS_MASK))
    {
      age = mDiscoveryrequest->measAgeFilterSec* 1000;
    }
	return age;
  }

  /**
  * Indicates if the Last scan results are to be returned as part of
  * the cache fallback request only.
  * Note: Applicable to only cash fallback request
  * MeasAgeFilter can contain 0xFFFF from a client to indicate if
  * client wants the last scan reults only if the results could
  * be provided from the cache
  */
  bool getlastScanResults () const
  {
    bool retVal = false;
    if (mDiscoveryrequest->measAgeFilterSec & LOWI_LATEST_SCAN_RESULTS_MASK)
    {
      retVal = true;
    }
	return retVal;
  }

  /**
  * Returns the Fallback tolerance in Msec
  *
  * Only valid when eRequestMode is CACHE_FALLBACK.
  * At the time of evaluating this request, all the
  * requested channels should have last measurement
  * timestamp equal to or greater than Current time -
  * Fallback tolerance. If not, then fallback to
  * trigger a fresh scan. Client can provide 0 if they
  * want to trigger a fresh scan as well.
  *
  * QMI has the fallback tolerance in seconds
  * We are using the top most bit to indicate, if the tolerance is to be
  * treated in sec or msec
  * if MSB is set to 1, treat it as msec otherwise sec
  * @return Cache fallback tolerance
  */
  uint32 getFallbackToleranceMSec () const
  {
    if (mDiscoveryrequest->fallbackToleranceSec & LOWI_MSEC_MASK)
    {
      return (mDiscoveryrequest->fallbackToleranceSec & ~LOWI_MSEC_MASK);
    }
	else
	{
	  // Convert to Msec
	  return (mDiscoveryrequest->fallbackToleranceSec * 1000);
	}
  }

  /**
   * Returns the band
   * @return RF band to scan.
   */
  eBand getBand () const;
  /**
   * Returns the dynamic array containing the list of frequencies
   * to be scanned.
   * Number of entries in the vector should not be more than
   * MAX_CHAN_INFO_SIZE as that's the max LOWI supports as of
   * now. Any ChannelInfo more than MAX_CHAN_INFO_SIZE will be
   * ignored.
   * @return bool indicating if the freq list is available or not
   */
  bool getChannels (vector <uint32>& freq);

  /** Destructor*/
  virtual ~LOWIDiscoveryScanRequest ();

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiDiscoveryRequest_v01* request message
   */
  LOWIDiscoveryScanRequest (uint32 client_id,
      QmiLowiDiscoveryRequest_v01* request);

  /**
   * Discovery scan request
   */
  QmiLowiDiscoveryRequest_v01* mDiscoveryrequest;

};

#if 0
/**
 * Defines the info for a Channel
 */
class LOWIChannelInfo
{
private:
  /** Frequency in Mhz*/
  uint32 frequency;
public:
  LOWIChannelInfo ();
  /**
   * Constructor
   * @param uint32 frequency of the channel
   */
  LOWIChannelInfo (uint32 freq);

  /**
   * Constructor
   * @param uint32 Channel number
   * @param uint64 Mask indicating band of the channel
   */
  LOWIChannelInfo (uint32 channel, uint64 band);

  ~LOWIChannelInfo ();
  /**
   * Returns the band associated with the channel.
   * @return Band for the channel.
   */
  LOWIDiscoveryScanRequest::eBand getBand () const;
  /**
   * Returns the Frequency associated with the channel.
   * @return Frequency of the channel
   */
  uint32 getFrequency () const;
  /**
   * Returns the Channel number for the Channel Info.
   * Channel number corresponds to the Band
   *
   * @return Channel Number
   */
  uint32 getChannel () const;
};
#endif

///////////////////////////
// Ranging scan Request
///////////////////////////

/** Defines available type of Wifi Nodes*/
enum eNodeType
{
  NODE_TYPE_UNKNOWN = 0,
  ACCESS_POINT,
  PEER_DEVICE
};
#if 0
/** Defines supported RTT types for Ranging scan request */
enum eRttType
{
  RTT1_RANGING = 0,    /* Ranging with no Multipath correction */
  RTT2_RANGING,        /* Ranging with Multipath correction */
  RTT3_RANGING,        /* Two-sided Ranging as defined in 802.11mc spec */
  BEST_EFFORT_RANGING  /* One of the above, which ever the peer supports */
};

/** Defines RTT report types for Ranging scan */
enum eRttReportType
{
  RTT_REPORT_1_FRAME_CFR = 0,  /* Responses sent on a per frame basis with CFR capture */
  RTT_REPORT_1_FRAME_NO_CFR,   /* Responses sent on a per frame basis without CFR captiure */
  RTT_REPORT_AGGREGATE         /* Single responses containing results for all requested APs and frames*/
};

/**
 * Defines the information for a Wifi Node
 */
struct LOWINodeInfo
{
  /** MacId of the Node*/
  LOWIMacAddress bssid;
  /** Frequency in Mhz, which the node is transmitting*/
  uint32 frequency;
  /** Either PEER_DEVICE or ACCESS_POINT*/
  eNodeType nodeType;
  /* Spoof MacId needed for peer device ranging.
   * Only valid if nodeType is PEER_DEVICE*/
  LOWIMacAddress spoofMacId;

  /** The Type Of RTT to be performed */
  eRttType rttType;
};

/**
 * Class to make a Ranging scan request.
 */
class LOWIRangingScanRequest: public LOWIRequest
{
private:
  /**
   * Dynamic array containing the wifi Node Info to be scanned.
   * Currently LOWI only supports 16 wifi nodes to be scanned
   * with Ranging scan. Any thing more than 16 will be ignored.
   */
  vector <LOWINodeInfo> nodeInfo;

  /** Absolute timestamp on which the request will be dropped if not processed
   * value should be 0 if the timeoutTimestamp is not valid.
   */
  int64             timeoutTimestamp;

  /** The Type Of RTT Report the FW should provide */
  eRttReportType rttReportType;

public:

  /**
   * Returns the Dynamic array containing the LOWINodeInfo
   * @return Dynamic array containing the LOWINodeInfo
   */
  vector <LOWINodeInfo> & getNodes ();

  /**
   * Returns the timestamp at which the request expires
   * @return timestamp at which the request expires
   */
  int64 getTimeoutTimestamp () const;

  /**
   * Sets the RTT report type for the request
   * @return void
   */
  void setReportType(eRttReportType report_type);

  /**
   * Returns the RTT Report Type for this Request
   * @return eRttReportType RTT Report type
   */
  eRttReportType getReportType() const;


  /**
   * Constructor
   * @param uint32 Request id generated by the client
   *        This will be echoed back in the corresponding response.
   * @param vector<LOWINodeInfo> Dynamic array containing wifi nodes
   *                           that need to be scanned.
   * @param int64 Timestamp at which the request will be dropped if not
   *              processed already. Should be 0 if this is to be ignored.
   */
  LOWIRangingScanRequest (uint32 requestId, vector <LOWINodeInfo>& node_info,
      int64 timestamp);
  /** Destructor*/
  virtual ~LOWIRangingScanRequest ();

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;
};

#endif
/**
 * Class to make a subscription Request for snoop scans.
*/
class LOWIAsyncDiscoveryScanResultRequest : public LOWIRequest
{
private:
  QmiLowiSnoopScanSubscriptionRequest_v01 mRequest;

public:
  /**
   * Constructor
   * A client registers this request to receive the discovery
   * scan results as and when they are available.
   * LOWI provides the snoop scan results to the client for as long
   * as the subscriptions iv not canceled or the request time is not
   * expired. After the request timer expiry the request will be dropped
   * silently and no more indications are sent to clients.
   *
   * Client will not get the results / response to this request
   * if there was a discovery scan result available but was
   * triggered by a discovery scan request from the same client.
   *
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiSnoopScanSubscriptionRequest_v01* request
   */
  LOWIAsyncDiscoveryScanResultRequest (
      uint32 client_id,
      QmiLowiSnoopScanSubscriptionRequest_v01* request);

  /**
   * Returns the expiry time of the Request in sec.
   * @return uint32 Request expiry time
   */
  uint32 getRequestExpiryTime ();

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /**
   * Checks if only scans are to be sent, not sent to APSS.
   * @return bool true to only send scans not sent to APSS,
   *  false to send all scans
   */
  bool isSendScansNotSentToApss ();

  /**
   * Returns the state (Subscribe / Unsubscribe request)
   * @return true for subscription, false for unsubscribe
   */
  bool isSubscriptionRequest ();

  /**
   * Sets the subscription state
   * @param bool true to subscribe, false to cancel subscription
   */
  void setSubscriptionState (bool subscribe);

  /**
   * Creates a Dummy async Request for internal usage.
   * This is the request used by LOWIController internally to subscribe
   * for the LOWIAsyncDiscoveryScanResultRequest to WLAN Driver.
   */
  static LOWIAsyncDiscoveryScanResultRequest* createDummyAsyncRequest ();
};

/**
 * Class to make a subscription Request for WLAN Events.
*/
class LOWIWLANEventsSubscriptionRequest : public LOWIRequest
{
public:
  QmiLowiWlanInterfaceEventsSubscriptionRequest_v01 mRequest;

  /**
   * A client registers this request to receive the wlan events
   * LOWI provides the WLAN events to the clients for as long
   * as the subscriptions is not canceled.
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiWlanInterfaceEventsSubscriptionRequest_v01* request
   */
  LOWIWLANEventsSubscriptionRequest (uint32 client_id,
      QmiLowiWlanInterfaceEventsSubscriptionRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /**
   * Returns the state (Subscribe / Unsubscribe request)
   * @return true for subscription, false for unsubscribe
   */
  bool isSubscriptionRequest ();


  /**
   * Sets the subscription state
   * @param bool true to subscribe, false to cancel subscription
   */
  void setSubscriptionState (bool subscribe);

  /**
   * Creates a Dummy Events subscription Request for internal usage.
   * This is the request used by LOWIController internally to subscribe
   * for LOWIWLANEventsSubscriptionRequest to WLAN Driver.
   */
  static LOWIWLANEventsSubscriptionRequest* createDummyEventsSubscriptionRequest ();
};

/**
 * Request to query a WLAN state.
*/
class LOWIWLANStateQueryRequest : public LOWIRequest
{
private:
  QmiLowiWlanInterfaceEventTriggerRequest_v01 mRequest;

public:
  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiWlanInterfaceEventTriggerRequest_v01* request
   */
  LOWIWLANStateQueryRequest (uint32 client_id,
      QmiLowiWlanInterfaceEventTriggerRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;
};

/**
 * Request to subscribe for Batching.
*/
class LOWIBatchingSubscriptionRequest : public LOWIRequest
{

public:
  QmiLowiBatchingSubscriptionRequest_v01 mRequest;

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiBatchingSubscriptionRequest_v01* request
   */
  LOWIBatchingSubscriptionRequest (uint32 client_id,
      QmiLowiBatchingSubscriptionRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /** Destructor*/
  virtual ~LOWIBatchingSubscriptionRequest ();
};

/**
 * Request to get the Batching results.
*/
class LOWIGetBatchingResultsRequest : public LOWIRequest
{

public:
  QmiLowiGetBatchingResultsRequest_v01 mRequest;

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiGetBatchingResultsRequest_v01* request
   */
  LOWIGetBatchingResultsRequest (uint32 client_id,
      QmiLowiGetBatchingResultsRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /** Destructor*/
  virtual ~LOWIGetBatchingResultsRequest ();
};

/**
 * Request to subscribe for BGScan.
*/
class LOWIBGScanSubscriptionRequest : public LOWIBatchingSubscriptionRequest
{

public:
  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiBatchingSubscriptionRequest_v01* request
   */
  LOWIBGScanSubscriptionRequest (uint32 client_id,
      QmiLowiBatchingSubscriptionRequest_v01* request);

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;
};

/**
 * Request to get the BGScan results.
*/
class LOWIGetBGScanResultsRequest : public LOWIGetBatchingResultsRequest
{

public:

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiGetBatchingResultsRequest_v01* request
   */
  LOWIGetBGScanResultsRequest (uint32 client_id,
      QmiLowiGetBatchingResultsRequest_v01* request);

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;
};


} // namespace qc_loc_fw

#endif //#ifndef __LOWI_REQUEST_H__
