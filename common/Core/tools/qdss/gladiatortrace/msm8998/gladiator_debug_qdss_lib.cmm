;----------------------------------------------------------------------------
;  Name: debug_suite_qdss_lib.cmm
;    This script is a collection of some of helper functions for 
;    configuring gladiator QDSS functionality
;
;  You can call these functions with
;    do ~~~~/debug_suite_qdss_lib.cmm <FUNCTION> <ARGUMENTS>
;
;  PoC:
;    aidapala / SWArch
;
; Copyright (c) 2006-2015 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
;---------------------------------------------------------------

;************************************************
;************* QDSS definitions *****************
;************************************************
; Access Port
&qdss_access_port="qdss_dap_apb"
&target="8998_R1"

&qdss_apb_base_addr=0x80000000
&qdss_axi_cfg_base_addr=0x6000000

; QDSS debug components
&qdss_csr_offset=0x1000
&qdss_in_funnel0_offset=0x41000
&qdss_in_funnel1_offset=0x42000
&qdss_merge_funnel_offset=0x45000

&qdss_tmc_etb_offset=0x47000
&qdss_tmc_etr_offset=0x48000

; CPUSS debug components
&qdss_cpuss_funnel1_offset=0x1B70000

&qdss_cpuss_top_cti_offset=0x1B80000
&qdss_cpuss_top_cti_trigout_gladiator_trace=0x3
&qdss_cpuss_top_cti_trigout_gladiator_statdump=0x4
&qdss_cpuss_top_cti_gladiator_channel=0x3
&qdss_top_cti_spdm_periodic_trigin_num=0x3

; 8998 CTI config
; CTI0 : QDSS_BASE+0x10000  - QDSS (ETR,STM)
; CTI1 : QDSS_BASE+0x11000  - QDSS (TPIU, TPDM, TPDA)
; CTI2 : QDSS_BASE+0x12000  - QDSS (GPIO)
; CTI3 : QDSS_BASE+0x13000  - QDSS (TGU)
; CTI4 : QDSS_BASE+0x14000  - MNOC Eprobe
; CTI5 : QDSS_BASE+0x15000  - MNOC Tprobe, SNOC eprobe
; CTI6 : QDSS_BASE+0x15000  - Aggr NoC, MDSS, DSA, NAV
; CTI7 : QDSS_BASE+0x17000  - SPDM, BIMC, Aggr NoC1
; TRIGIN2  - SPDM_Profile_En        : Generated by a register in SPDM to enable the profiling in SPDM.
;                                     It also outputs this signal to TRIGIN[2] if there is a need to use
;                                     SPDM as the time keeper for profiling.
;
; TRIGOUT2 - SPDM_Profile_En        : For enabling the profiling in SPDM. It is expected to be a level signal.
;
; TRIGIN3  - SPDM_PeriodicDump      : A periodic pulse generated by a timer in SPDM.
;                                     SPDM outputs this signal to TRIGIN[3] if there
;                                     is a need to use SPDM as the time keeper for profiling.
;
; TRIGOUT3 - SPDM_Profile_TimeKeeper: A periodic pulse, each assertion triggers
;                                     the SPDM to dump the profiling metrics using AHB master of SPDM.
; CTI8 : QDSS_BASE+0x18000  - GCC, MSS, NAV TPDMs
; CTI9 : QDSS_BASE+0x19000  - Aggr NoC2, DSA, CPP, MDSS
; CTI10: QDSS_BASE+0x1A000  - MDSS, DCC, JPEG, GPU
; CTI11: QDSS_BASE+0x1B000  - VFE, DCC, SPDM,
; CTI12: QDSS_BASE+0x1C000  - PIMEM, Venus, PRNG, VSENSE
; CTI13: QDSS_BASE+0x1D000  - DDRSS, VSENSE
; CTI14: QDSS_BASE+0x1E000  - SNOC, MNOC
; CTI15: QDSS_BASE+0x1F000  - SNOC
;
//spdm config regs
&SPDM_CREG_CFG0=0x620000
&SPDM_OLEM_CFG0=0x621000


;************* End of QDSS definitions  *********

ENTRY &func %line &arg
LOCAL &func &arg &result

ON ERROR GOTO
(
	LOCAL &ppf
	&ppf=OS.PPF()
	PRINT %ERROR "Sorry, '"+OS.FILE.NAME("&ppf")+"' doesn't know function '&func'"
	STOP
)
&func=STRING.UPR("&func")
GOSUB &func &arg
ENTRY %LINE &result
ENDDO &result


;*****************************************************************************************************
;*****************************************************************************************************
;*****************************************************************************************************
; general QDSS register handling API
;*****************************************************************************************************
;*****************************************************************************************************
;*****************************************************************************************************

;================================================================================
; Function: QDSS_REGISTER_READ
; Description: Reads a Gladiator register
; Usage :
      do ~~~~/debug_suite_qdss_lib.cmm QDSS_REGISTER_READ &offset
; Inputs:
;     &offset : offset of the register that need to be accessed
; Outputs:
;     &val    : value read
;================================================================================
QDSS_REGISTER_READ:
ON ERROR NOTHING
PRIVATE &mem_addr &val
ENTRY &offset

    if ("&qdss_access_port"=="qdss_dap_apb")
    (
        &mem_addr=V.VALUE(&qdss_apb_base_addr+&offset)
    )
    else if ("&qdss_access_port"=="cpu")
    (
        &mem_addr=V.VALUE(&qdss_axi_cfg_base_addr+&offset)
    )
    else if ("&qdss_access_port"=="qdss_axi_cfg")
    (
        &mem_addr=V.VALUE(&qdss_axi_cfg_base_addr+&offset)
    )

    if ("&qdss_access_port"=="qdss_dap_apb")
    (
        &val=data.long(eapb:&mem_addr)
    )
    else if ("&qdss_access_port"=="cpu")
    (
        &val=data.long(zsd:&mem_addr)
    )
    else if ("&qdss_access_port"=="qdss_axi_cfg")
    (
        &val=data.long(ezaxi:&mem_addr)
    )

    ;print "QDSS_REGISTER_READ : address 0x" FORMAT.HEX(8,&mem_addr) " value 0x" FORMAT.HEX(8,&val)

RETURN &val


;================================================================================
; Function: QDSS_REGISTER_WRITE
; Description: Writes a Gladiator register with a value
; Usage :
      do ~~~~/debug_suite_qdss_lib.cmm QDSS_REGISTER_WRITE &offset &val
; Inputs:
;     &offset : offset of the register that need to be written
;     &value  : value to be written
; Outputs:
;     none
;================================================================================
QDSS_REGISTER_WRITE:
ON ERROR NOTHING
PRIVATE &mem_addr
ENTRY &offset &val

    if ("&qdss_access_port"=="qdss_dap_apb")
    (
        &mem_addr=V.VALUE(&qdss_apb_base_addr+&offset)
    )
    else if ("&qdss_access_port"=="cpu")
    (
        &mem_addr=V.VALUE(&qdss_axi_cfg_base_addr+&offset)
    )
    else if ("&qdss_access_port"=="qdss_axi_cfg")
    (
        &mem_addr=V.VALUE(&qdss_axi_cfg_base_addr+&offset)
    )

    if ("&qdss_access_port"=="qdss_dap_apb")
    (
        d.s eapb:&mem_addr %LE %LONG &val
    )
    else if ("&qdss_access_port"=="cpu")
    (
        d.s zsd:&mem_addr %LE %LONG &val
    )
    else if ("&qdss_access_port"=="qdss_axi_cfg")
    (
        d.s ezaxi:&mem_addr %LE %LONG &val
    )

    ;print "QDSS_REGISTER_WRITE : address 0x" FORMAT.HEX(8,&mem_addr) " value 0x" FORMAT.HEX(8,&val)

RETURN

;================================================================================
; Function: QDSS_REGISTER_SET_BITS
; Description: Set register bits with a bit-pattern
; Usage :
;     do ~~~~/debug_suite_qdss_lib.cmm QDSS_REGISTER_SET_BITS &offset &bitmask
; Inputs:
;     &offset   : offset of the register that need to be written
;     &bitmask  : value to be written
; Outputs:
;     none
;================================================================================
QDSS_REGISTER_SET_BITS:
ON ERROR NOTHING
PRIVATE &temp
ENTRY &offset &bitmask

    gosub QDSS_REGISTER_READ &offset
    ENTRY %LINE &temp
    &bitmask=V.VALUE(&temp|&bitmask)
    gosub QDSS_REGISTER_WRITE &offset &bitmask

RETURN

;================================================================================
; Function: QDSS_REGISTER_CLEAR_BITS
; Description: Clear register bits with a bit-pattern
; Usage :
;     do ~~~~/debug_suite_qdss_lib.cmm QDSS_REGISTER_CLEAR_BITS &offset &bitmask
; Inputs:
;     &offset   : offset of the register that need to be written
;     &bitmask  : value to be written
; Outputs:
;     none
;================================================================================
QDSS_REGISTER_CLEAR_BITS:
ON ERROR NOTHING
PRIVATE &temp
ENTRY &offset &bitmask

    gosub QDSS_REGISTER_READ &offset
    ENTRY %LINE &temp
    &bitmask=V.VALUE(&temp&(~&bitmask))
    gosub QDSS_REGISTER_WRITE &offset &bitmask

RETURN



;*****************************************************************************************************
;*****************************************************************************************************
;*****************************************************************************************************
; PLATFORM SPECIFIC init function executed only once.
;*****************************************************************************************************
;*****************************************************************************************************
;*****************************************************************************************************

;================================================================================
; Function: PLATFORM_QDSS_SETUP
; Description: Reads The Platform ID and sets the register offsets accordingly.
; Usage : required to Exeuted only once.
;	  do ~~~~/debug_suite_qdss_lib.cmm PLATFORM_QDSS_SETUP &target
; Inputs: 
;     &target : target ID : supported : 8998_R1, BEAR
; Outputs: 
;     &status : status of the function. 0: success, 1: failure
;================================================================================
PLATFORM_QDSS_SETUP:
ON ERROR NOTHING
PRIVATE &offset &status
ENTRY &target

	&status=1

	if ("&target"=="8998_R1")
	(
		&status=0

		&qdss_apb_base_addr=0x80000000
		&qdss_axi_cfg_base_addr=0x6000000

		; QDSS debug components
		&qdss_csr_offset=0x1000
		&qdss_in_funnel0_offset=0x41000
		&qdss_in_funnel1_offset=0x42000
		&qdss_merge_funnel_offset=0x45000

		&qdss_tmc_etb_offset=&qdss_base+0x47000
		&qdss_tmc_etr_offset=&qdss_base+0x48000

		; CPUSS Top-Level Funnel1
		&qdss_cpuss_funnel1_offset=0x1B70000

		; CPUSS Top-Level CTI
		&qdss_cpuss_top_cti_offset=0x1B80000
	)
	else if ("&target"=="BEAR")
	(
		&status=0

		&qdss_apb_base_addr=0x80000000
		&qdss_axi_cfg_base_addr=0x6000000

		;QDSS debug components offset
		&qdss_csr_offset=0x1000
		&qdss_in_funnel0_offset=0x21000   
		&qdss_in_funnel1_offset=0x22000     
		&qdss_merge_funnel_offset=0x23000   
		&qdss_top_funnel_offset=0x68000
		&qdss_replicator_offset=0x24000
		&qdss_tmc_etb_offset=0x25000
		&qdss_tmc_etr_offset=0x26000
		&cpuss_funnel0_offset=0xb60000
		&qdss_cpuss_funnel1_offset=0xb70000
		&qdss_cpuss_top_cti_offset=0xb80000

		; In-Funnel0 offset
		; 0:RPM_ETM    1:Q6_vec     2:LPASS       3:DCC TPDA   4:A5x_GFX       5:Venus VBIF  6:TOP_FUNNEL     7: STM  
		; In-Funnel1 offset
		; 0:PRONTO     1:RPM_ITM    2:A5x_VBIF    3:???????    4:CMASS_VFE_1   5:CAMSS_CPP   6:CPUSS          7:Q6_SCL
		; Merge Funnel1 Base 
		; 0:in_funnel0 1:in_funnel1 
		; Top Funnel1 Base 
		; 0:MDSS       1:CMSS_VFE_0 2:CAMSS_JPEG  3: BIMC      4:MSS_DBG       5:SNOC        6:PCNOC          7:?????
		;
		; CPUSS debug components
		;  funnel0 => 0:7 : CPU0-7
		;  funnel1 => 0:CPU 1:LMH 2:GLADIATOR 3:XXXX
		;                                              -------
		; CPUSS CTI
		;  Gladiator Error IRQ-------------->TRIGIN0->|  CTI  |->TRIGOUT0-->APC0 voltage sensor input trigger
		;  Gladiator event overflow IRQ----->TRIGIN1->|       |->TRIGOUT1-->APC1 voltage sensor input trigger
		;  APC0 Voltage Sensor Alarm-------->TRIGIN2->|       |->TRIGOUT2-->LMH-Lite TPDA trigger input
		;  APC1 Voltage Sensor Alarm-------->TRIGIN3->|       |->TRIGOUT3-->Gladiator CTI Trigger TraceEn (GlobalEn)
		;  LMH-Lite TPDM CMD patt match----->TRIGIN4->|       |->TRIGOUT4-->Gladiator CTI Trigger StatDump (StatGo)
		;  Gladiator TraceAlarm------------->TRIGIN5->|       |->TRIGOUT5-->
		;  Gladiator StatAlarm-------------->TRIGIN6->|       |->TRIGOUT6-->
		;  ???????                        -->TRIGIN7->|       |->TRIGOUT7-->
		;                                              -------
	)
	else
	(
		print "PLATFORM_SETUP : target &target not valid !!!" 
	)	

RETURN &status

;******************************************************************************
;********************************* QDSS API ***********************************
;******************************************************************************

;================================================================================
; Function: QDSS_SETUP_TMC_ETB
; Description: Setup TMC in circular buffer mode
; Usage : QDSS_SETUP_TMC_ETB &base_offset
; Inputs:
;     &base_offset   : base_offset address of TMC
; Outputs:
;     none
;================================================================================
QDSS_SETUP_TMC_ETB:
ON ERROR NOTHING
PRIVATE &offset
ENTRY &base_offset
    print "  Setup QDSS TMC ETB in BUFFER mode start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

    &offset=&base_offset+0x20 // Disable Trace Capture
    gosub QDSS_REGISTER_CLEAR_BITS &offset 0xFFFFFFFF

    &offset=&base_offset+0x28 // Mode to circular buffer
    gosub QDSS_REGISTER_WRITE &offset 0x0

    &offset=&base_offset+0x14 // Set read pointer
    gosub QDSS_REGISTER_WRITE &offset 0x0

    &offset=&base_offset+0x18 // Set write pointer
    gosub QDSS_REGISTER_WRITE &offset 0x0

    ;&offset=&base_offset+0x304 // Formatter and Flush Control
    ;gosub QDSS_REGISTER_WRITE &offset 0x433

    &offset=&base_offset+0x20 // Enable Trace Capture
    gosub QDSS_REGISTER_WRITE &offset 0x1

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "  Setup QDSS TMC ETB in BUFFER mode Done."

RETURN

;================================================================================
; Function: QDSS_SETUP_TMC_ETF
; Description: Setup TMC in FIFO mode
; Usage : QDSS_SETUP_TMC_ETF &base_offset
; Inputs:
;     &base_offset   : base_offset address of TMC
; Outputs:
;     none
;================================================================================
QDSS_SETUP_TMC_ETF:
ON ERROR NOTHING
PRIVATE &offset
ENTRY &base_offset

    print "Setup QDSS TMC ETB in HW FIFO mode start..."

    &offset=&base_offset+0xFB0 // unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

    &offset=&base_offset+0x20 // Disable Trace Capture
    gosub QDSS_REGISTER_CLEAR_BITS &offset 0xFFFFFFFF

    &offset=&base_offset+0x28 //set mode to hw fifo
    gosub QDSS_REGISTER_WRITE &offset 0x2

    &offset=&base_offset+0x304 // Formatter and Flush Control
    gosub QDSS_REGISTER_WRITE &offset 0x3

    &offset=&base_offset+0x20 // Enable Trace Capture
    gosub QDSS_REGISTER_WRITE &offset 0x1

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "Setup QDSS TMC ETB in HW FIFO mode Done."
RETURN


;================================================================================
; Function: QDSS_SETUP_TMC_ETR
; Description: Setup TMC ETR
; Usage : QDSS_SETUP_TMC_ETR &base_offset &ddr_base &ddr_size
; Inputs:
;     &base_offset   : base_offset address of TMC
;     &ddr_base : buffer address
;     &ddr_size : buffer size
; Outputs:
;     none
;================================================================================
QDSS_SETUP_TMC_ETR:
ON ERROR NOTHING
PRIVATE &offset
ENTRY &base_offset &ddr_base &ddr_size

    ; initialize the memory buffer with 0

    print "  Setup QDSS ETR start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

    &offset=&base_offset+0x20 // Disable Trace Capture
    gosub QDSS_REGISTER_CLEAR_BITS &offset 0xFFFFFFFF

    &offset=&base_offset+0x28 // Mode to circular buffer
    gosub QDSS_REGISTER_WRITE &offset 0x0

    &offset=&base_offset+0x4 // set up RAM size
    gosub QDSS_REGISTER_WRITE &offset &ddr_size

    // AXI control configuration : cacheable, bufferable, non-secure data to single continuous block of memory
    &offset=&base_offset+0x110
    gosub QDSS_REGISTER_WRITE &offset 0xF0E

    &offset=&base_offset+0x118 // setup ETR base_offset
    gosub QDSS_REGISTER_WRITE &offset &ddr_base

    ;&offset=&base_offset+0x304 // Formatter and Flush Control
    ;gosub QDSS_REGISTER_WRITE &offset 0x1133

    ;&offset=&base_offset+0x1C // trigger counter
    ;gosub QDSS_REGISTER_WRITE &offset 0x0

    ;&offset=&base_offset+0x20 // Enable Trace Capture
    ;gosub QDSS_REGISTER_WRITE &offset 0x1

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "  Setup QDSS ETR Done"

RETURN

;================================================================================
; Function: QDSS_SETUP_TMC_FLUSH
; Description: Flush the trace data using TMC
; Usage : QDSS_SETUP_TMC_FLUSH &base_offset
; Inputs:
;     &base_offset   : base_offset address of TMC
; Outputs:
;     none
;================================================================================
QDSS_SETUP_TMC_FLUSH:
ON ERROR NOTHING
PRIVATE &offset
ENTRY &base_offset

RETURN

;================================================================================
; Function: QDSS_SETUP_FUNNEL_PORTS_ENABLE
; Description: Setup funnel enable ports
; Usage : QDSS_SETUP_FUNNEL_PORTS_ENABLE &base_offset &ports
; Inputs:
;     &base_offset   : base_offset address of TMC
;     &ports  : ports
; Outputs:
;     none
;================================================================================
QDSS_SETUP_FUNNEL_PORTS_ENABLE:
ON ERROR NOTHING
PRIVATE &offset &val
ENTRY &base_offset &ports

    print "  Setup QDSS &base_offset Funnel ports enable start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

    &val=(0x700|&ports)
    gosub QDSS_REGISTER_SET_BITS &base_offset &val

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "  Setup QDSS Funnel ports enable Done."

RETURN

;================================================================================
; Function: QDSS_SETUP_FUNNEL_PORTS_DISBLE
; Description: Setup funnel disable ports
; Usage : QDSS_SETUP_FUNNEL_PORTS_DISBLE &base_offset &ports
; Inputs:
;     &base_offset   : base_offset address of TMC
;     &ports  : ports
; Outputs:
;     none
;================================================================================
QDSS_SETUP_FUNNEL_PORTS_DISBLE:
ON ERROR NOTHING
PRIVATE &offset
ENTRY &base_offset &ports

    print "  Setup QDSS &base_offset Funnel ports disable start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

    gosub QDSS_REGISTER_CLEAR_BITS &base_offset &ports

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "  Setup QDSS Funnel Ports Disable Done."

RETURN

;================================================================================
; Function: QDSS_SETUP_TIMESTAMPS_ENABLE
; Description: Setup QDSS timestamps
; Usage : QDSS_SETUP_TIMESTAMPS_ENABLE
; Inputs:
;     base_offset : QDSS CSR base_offset
; Outputs:
;     none
;================================================================================
QDSS_SETUP_TIMESTAMPS_ENABLE:
ON ERROR NOTHING
PRIVATE &offset
ENTRY &base_offset
    print "  enable QDSS timestamps start..."

    &offset=&base_offset+0xFB0 // unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

    ; enable timestamp clock
    ; GCC_QDSS_TSCTR_****

    &offset=&base_offset+0x38
    ; enable timestamps
    gosub QDSS_REGISTER_SET_BITS &offset 0x2
    ; enable timestamps
    gosub QDSS_REGISTER_SET_BITS &offset 0x6

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "  enable QDSS timestamps done."

RETURN

;================================================================================
; Function: QDSS_SETUP_CTI_TRIGIN
; Description: Setup CTI input triggers to channels
; Usage : QDSS_SETUP_CTI_TRIGIN &base_offset &trigin &channel
; Inputs:
;     &base_offset   : base_offset address of CTI
;	  &trigin        : Trigger input
;     &channel       : channel to connect
; Outputs:
;     none
;================================================================================
QDSS_SETUP_CTI_TRIGIN:
ON ERROR NOTHING
PRIVATE &offset &val
ENTRY &base_offset &trigin &channel

    print "Setup QDSS CTI TRIGIN start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

	; connect the trigger inputs to channels
	if ((&trigin>=0)||(&trigin<=7))
	(
		if ((&channel>=0)||(&channel<=3))
		(
    		&offset=&base_offset+0x20+(&trigin*0x4)
			gosub QDSS_REGISTER_WRITE &offset (0x1<<&channel)
		)
	)

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "Setup QDSS CTI TRIGIN Done."

RETURN

;================================================================================
; Function: QDSS_SETUP_CTI_TRIGOUT
; Description: Setup CTI channel to outpput triggers
; Usage : QDSS_SETUP_CTI_TRIGOUT &base_offset &trigout &channel
; Inputs:
;     &base_offset   : base_offset address of CTI
;	  &trigout       : Trigger Output
;     &channel       : channel to connect
; Outputs:
;     none
;================================================================================
QDSS_SETUP_CTI_TRIGOUT:
ON ERROR NOTHING
PRIVATE &offset &val
ENTRY &base_offset &trigout &channel

    print "Setup QDSS CTI TRIGOUT start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

	; connect the chanel to trigger outputs
	if ((&trigout>=0)||(&trigout<=7))
	(
		if ((&channel>=0)||(&channel<=3))
		(
    		&offset=&base_offset+0xA0+(&trigout*0x4)
			gosub QDSS_REGISTER_WRITE &offset (0x1<<&channel)
		)
	)

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "Setup QDSS CTI TRIGOUT Done."

RETURN

;================================================================================
; Function: QDSS_SETUP_CTI_MANUAL_TRIGGER
; Description: Generate Manual CTI trigger on channel
; Usage : QDSS_SETUP_CTI_MANUAL_TRIGGER &base_offset &channel
; Inputs:
;     &base_offset   : base_offset address of CTI
;     &channel       : channel to connect
; Outputs:
;     none
;================================================================================
QDSS_SETUP_CTI_MANUAL_TRIGGER:
ON ERROR NOTHING
PRIVATE &offset &val
ENTRY &base_offset &channel

    print "Setup QDSS CTI Manual trigger start..."

	if ("&base_offset"=="")
	(
		&base_offset=&qdss_cpuss_top_cti_offset
	)

	if ("&channel"=="")
	(
		&channel=&qdss_cpuss_top_cti_gladiator_channel
	)
	
    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

	; connect the chanel to trigger outputs
	if ((&channel>=0x0)||(&channel<=0x3))
	(
   		&offset=&base_offset+0x1C
		gosub QDSS_REGISTER_WRITE &offset (0x1<<&channel)
	)

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "Setup QDSS CTI Manual trigger Done."

RETURN

;================================================================================
; Function: QDSS_SETUP_CTI_ENABLE
; Description: CTI Disable
; Usage : QDSS_SETUP_CTI_ENABLE &base_offset
; Inputs:
;     &base_offset   : base_offset address of CTI
; Outputs:
;     none
;================================================================================
QDSS_SETUP_CTI_ENABLE:
ON ERROR NOTHING
PRIVATE &offset &val
ENTRY &base_offset

    print "Setup QDSS CTI with base &base_offset enable start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

	gosub QDSS_REGISTER_WRITE &base_offset 0x1

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "Setup QDSS CTI with base &base_offset enable Done."

RETURN

;================================================================================
; Function: QDSS_SETUP_CTI_DISABLE
; Description: CTI enable
; Usage : QDSS_SETUP_CTI_DISABLE &base_offset
; Inputs:
;     &base_offset   : base_offset address of CTI
; Outputs:
;     none
;================================================================================
QDSS_SETUP_CTI_DISABLE:
ON ERROR NOTHING
PRIVATE &offset &val
ENTRY &base_offset

    print "Setup QDSS CTI Disable start..."

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

	gosub QDSS_REGISTER_WRITE &base_offset 0x0

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "Setup QDSS CTI Disable Done."

RETURN

;================================================================================
; Function: QDSS_CTI_CONFIG_SETUP
; Description: Configures QDSS CTI
; Usage : QDSS_CTI_CONFIG_SETUP
;   do ~~~~/debug_suite_qdss_lib.cmm QDSS_CTI_CONFIG_SETUP 8998_R1
; Inputs:
;     none
; Outputs:
;     none
;================================================================================
QDSS_CTI_CONFIG_SETUP:
ON ERROR NOTHING
PRIVATE &offset &trigout &channel
ENTRY &target

    print "Setup QDSS CTI Config start..."

	; Configure Gladiator Triggers
	&channel=&qdss_cpuss_top_cti_gladiator_channel
	&trigout=&qdss_cpuss_top_cti_trigout_gladiator_statdump
	gosub QDSS_SETUP_CTI_TRIGOUT &qdss_cpuss_top_cti_offset &trigout &channel

	&trigout=&qdss_cpuss_top_cti_trigout_gladiator_trace
	gosub QDSS_SETUP_CTI_TRIGOUT &qdss_cpuss_top_cti_offset &trigout &channel

	; Enable CTI
	gosub QDSS_SETUP_CTI_ENABLE &qdss_cpuss_top_cti_offset

    print "Setup QDSS CTI Config Done."

RETURN


;================================================================================
; Function: SETUP_SPDM_TRIGGER_TO_QDSS_CHANNEL
; Description: Setup SPDM based periodic triggers to QDSS channel
; Usage : SETUP_SPDM_TRIGGER_TO_QDSS_CHANNEL
; Inputs:
;     none
; Outputs:
;     none
;================================================================================
SETUP_SPDM_TRIGGER_TO_QDSS_CHANNEL:
ON ERROR NOTHING
PRIVATE &offset &count
ENTRY &channel

    print "  Setup QDSS SPDM trigger connectivity to QDSS channel &channel start."

    ; Connect SPDM periodic trigger to QDSS CTI7 channel
    gosub QDSS_SETUP_CTI_TRIGIN 0x17000 &qdss_top_cti_spdm_periodic_trigin_num &channel

    ; Enable all CTIs in the path to Route the trigger to System Components on same channel
    &count=0
    &offset=0x10000
    while &count<10.
    (
        gosub QDSS_SETUP_CTI_ENABLE &offset
        ; CTIGATE is not required to configure as by default it is enabled.

        &offset=&offset+0x1000
        &count=&count+0x1
    )

    print "  Setup QDSS SPDM trigger connectivity to QDSS channel &channel Done."

RETURN




;================================================================================
; Function: QDSS_TRACE_DUMP_ETB
; Description: dumps trace data from the device ETB
; Usage : 
;   do ~~~~/debug_suite_qdss_lib.cmm QDSS_TRACE_DUMP_ETB &etb_base &trace_file &full
; Inputs:
;     none
; Outputs:
;     none
;================================================================================
QDSS_TRACE_DUMP_ETB:
ON ERROR NOTHING
PRIVATE &pwd_path &offset &data
PRIVATE &dump_size &dump_full_etb &status &write_ptr &rrp_original
ENTRY &base_offset &trace_file &full

	if ("&base_offset"=="")
	(
		&base_offset=&qdss_tmc_etb_offset
	)

    if ("&trace_file"=="")
    (
    	&pwd_path=OS.PPD()
        &trace_file="&pwd_path\gladiator_trace_etb.dat"
    )

    &offset=&base_offset+0xFB0 //unlock
    gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

    &offset=&base_offset+0x304 // Flush the system
    gosub QDSS_REGISTER_SET_BITS &offset 0x40

    &offset=&base_offset+0x20 // Disable ETB
    gosub QDSS_REGISTER_CLEAR_BITS &offset 0xFFFFFFFF

    &offset=&base_offset+0x18 // Write Pointer
	gosub QDSS_REGISTER_READ &offset
	ENTRY %LINE &write_ptr

    &offset=&base_offset+0x14 // Read Pointer
	gosub QDSS_REGISTER_READ &offset
	ENTRY %LINE &rrp_original

    &offset=&base_offset+0xC // Status Register
	gosub QDSS_REGISTER_READ &offset
	ENTRY %LINE &status

    &start_ptr=0
    &dump_size=&write_ptr
    &dump_full_etb=0
    if ((&status&0x1)==0x1)
    (
        print "ETB full"
        &dump_full_etb=1
    )
    else if ("&full"!="")
    (
        &dump_full_etb=1
    )

    if (&dump_full_etb==1)
    (
        &start_ptr=&write_ptr
        &offset=&base_offset+0x4    // ETB size
		gosub QDSS_REGISTER_READ &offset
		ENTRY %LINE &dump_size
    )

    print "Dumping "  &dump_size " 32 bit words from ETB starting at " &start_ptr

    &offset=&base_offset+0x14 // Read Pointer
    gosub QDSS_REGISTER_WRITE &offset &start_ptr
    open #1 &trace_file /Create
    &offset=&base_offset+0x10 //Read Data
    &i=0
    WHILE &i<&dump_size
    (
		gosub QDSS_REGISTER_READ &offset
		ENTRY %LINE &data
        write #1 format.hex(8.,&data)
        &i=&i+1
    )
    close #1

    ; Restore Read Pointer
    &offset=&base_offset+0x14 // Read Pointer
    gosub QDSS_REGISTER_WRITE &offset &rrp_original

    &offset=&base_offset+0x20 // Re-Enable ETB Trace Capture
    gosub QDSS_REGISTER_WRITE &offset 0x1

    &offset=&base_offset+0xFB0 // lock
    gosub QDSS_REGISTER_WRITE &offset 0x0

    print "QDSS TMC ETB BUFFER Dump to &trace_file Done."

RETURN

;================================================================================
; Function: QDSS_TRACE_DUMP_ETR
; Description: dumps trace data from the device ETR
; Usage : 
;   do ~~~~/debug_suite_qdss_lib.cmm QDSS_TRACE_DUMP_ETR &etr_base &trace_file &full
; Inputs:
;     none
; Outputs:
;     none
;================================================================================
QDSS_TRACE_DUMP_ETR:
ON ERROR NOTHING
PRIVATE &pwd_path &offset &data
PRIVATE &dump_size &status &write_ptr &count &buf_base &buf_end &buf_size &dump_start &dump_size
ENTRY &base_offset &trace_file

	if ("&base_offset"=="")
	(
		&base_offset=&qdss_tmc_etr_offset
	)

    if ("&trace_file"=="")
    (
    	&pwd_path=OS.PPD()
        &trace_file="&pwd_path\gladiator_trace_ddr.dat"
    )

	; tmc_flush
	&buf_base=0x0
	&buf_size=0x0
	&dump_start=0x0
	&dump_size=0x0

	&offset=&base_offset+0xFB0 //unlock
	gosub QDSS_REGISTER_WRITE &offset 0xC5ACCE55

	&offset=&base_offset+0x20 // Disable ETR Trace Capture
	gosub QDSS_REGISTER_WRITE &offset 0x0

	&offset=&base_offset+0x4  // ETR buffer size
	gosub QDSS_REGISTER_READ &offset
	ENTRY %LINE &buf_size

	&offset=&base_offset+0x118 // ETR buffer base address
	gosub QDSS_REGISTER_READ &offset
	ENTRY %LINE &buf_base 

	&offset=&base_offset+0x18 // ETR Write Pointer
	gosub QDSS_REGISTER_READ &offset
	ENTRY %LINE &write_ptr

	&offset=&base_offset+0xC // ETR Status Register
	gosub QDSS_REGISTER_READ &offset
	ENTRY %LINE &status

	&buf_end=&buf_base+&buf_size

	if ((&status&0x1)==0x1)
	(
		&dump_start=&write_ptr
		&dump_size=&buf_size
	)
	else
	(
		&dump_start=&buf_base
		&dump_size=&write_ptr-&buf_base
	)

	print "Dumping "  &dump_size " 32 bit words from ETR starting at " &dump_start

	open #1 &trace_file /Create
	&count=0
	&offset=&dump_start
	WHILE &count<&dump_size
	(
		&data=data.long(eaxi:&offset)
		write #1 format.hex(8.,&data)
		&offset=&offset+0x4
		if (&offset>&buf_end)
		(
			&offset=&buf_base
		)
		&count=&count+1
	)
	close #1

	&offset=&base_offset+0x20 // Re-Enable ETB Trace Capture
	gosub QDSS_REGISTER_WRITE &offset 0x1

	&offset=&base_offset+0xFB0 // lock
	gosub QDSS_REGISTER_WRITE &offset 0x0

	print "QDSS DDR BUFFER Dump to &trace_file Done."

RETURN

;================================================================================
; Function: QDSS_TRACE_CONFIG_SETUP
; Description: Configures QDSS
; Usage : QDSS_TRACE_CONFIG_SETUP
;   do ~~~~/debug_suite_qdss_lib.cmm QDSS_TRACE_CONFIG_SETUP 8998_R1 [etb/etr]
; Inputs:
;     none
; Outputs:
;     none
;================================================================================
QDSS_TRACE_CONFIG_SETUP:
ON ERROR NOTHING
PRIVATE &offset &status
ENTRY &target &trace_sink

    print "  Gladiator QDSS Trace Configuration Start...."

    ; setup CPUSS Funnel 1 Port
    gosub QDSS_SETUP_FUNNEL_PORTS_ENABLE &qdss_cpuss_funnel1_offset 0x4

    ; setup QDSS IN Funnel CPUSS port
    gosub QDSS_SETUP_FUNNEL_PORTS_ENABLE &qdss_in_funnel1_offset 0x40

    ; setup QDSS MERGE Funnel IN Funnel ports
    gosub QDSS_SETUP_FUNNEL_PORTS_ENABLE &qdss_merge_funnel_offset 0x2

    ; enable QDSS timestamp logic
    gosub QDSS_SETUP_TIMESTAMPS_ENABLE &qdss_csr_offset

select_trace_sink:

	if ("trace_sink"=="")
	(
		print " Select trace Sink (etb/etr/none): "
		enter &trace_sink
	)

    if ("&trace_sink"=="etb")
    (
        ; setup trace sink as etb
        gosub QDSS_SETUP_TMC_ETB &qdss_tmc_etb_offset

        print "  Gladiator QDSS Trace Sink as ETB Done."
    )
    else if ("&trace_sink"=="etr")
    (
        // Other Configuration
        print "  Trace Sink as DDR configuration :"
        print "    NOTE: please make sure to use the right address and size "
        print "    by probing the kernel for reserved-continuous-memory regions and use one of them."

        print "  Select the DDR buffer base address allocated for ETR trace sink : "
        enter &tmc_etr_mem_base
        if ("&tmc_etr_mem_base"=="")
        (
            print "  !!!! Invalid DDR buffer base_offset Address for ETR !!!!"
            goto select_trace_sink

        )

        print "  Select the DDR buffer size allocated for ETR trace sink : "
        enter &tmc_etr_mem_size
        if ("&tmc_etr_mem_size"=="")
        (
            print "  !!!! Invalid DDR buffer size for ETR !!!!"
            goto select_trace_sink
        )

        ;setup trace sink as DDR
        ;setup ETB for HW FIFO mode
        gosub QDSS_SETUP_TMC_ETF &qdss_tmc_etb_offset

        ; setup ETR mode
        gosub QDSS_SETUP_TMC_ETR &qdss_tmc_etr_offset &tmc_etr_mem_base &tmc_etr_mem_size

        print "  Gladiator QDSS Trace Sink as DDR base:&tmc_etr_mem_base size:&tmc_etr_mem_size Done."
    )
    else if ("&trace_sink"=="none")
    (
        print "  !!! Gladiator QDSS Trace Sink Configuration Skipped !!!!."
    )
    else
    (
        print "  !!! Invalid selection of trace sink !!! "
        goto select_trace_sink
    )

    print "  Gladiator QDSS Trace Configuration Done."

RETURN

;================================================================================
; Function: SETUP_SPDM_PERIODIC_TRIGGERS
; Description: Setup SPDM based periodic triggers
; Usage : SETUP_SPDM_PERIODIC_TRIGGERS &period_us &iterations
; Inputs:
;     &period_us   : time period for SPDM triggers (interms of us)
;     &iterations  : number of iterations
; Outputs:
;     none
;================================================================================
SETUP_SPDM_PERIODIC_TRIGGERS:
ON ERROR NOTHING
PRIVATE &offset
ENTRY &period_us &iterations

    print "  Setup SPDM based perioic triggers at &period_us start..."

    gosub SETUP_SPDM_TRIGGER_TO_QDSS_CHANNEL &qdss_cpuss_top_cti_gladiator_channel

    ; Gladiator trigger input connectivity is already done.
	gosub QDSS_CTI_CONFIG_SETUP 

    if ("&period_us"=="")
    (
        ;&period_us=0x4B00 // 1000 us interval
        &period_us=0x2EE00 // 1000000 us interval
        print "  No input for period_us, Selecting default value &period_us us"
    )

    if ("&iterations"=="")
    (
        &iterations=0x100FFF // 4000 iterations
        print "  No input for iterations, Selecting default value &iterations "
    )

    //timed enable mode
	&offset=&SPDM_CREG_CFG0
    D.S EZAXI:&offset %LE %LONG 0x1

	&offset=&SPDM_OLEM_CFG0+0xC
    D.S EZAXI:&offset %LE %LONG 0xffffffff

	&offset=&SPDM_OLEM_CFG0+0x10
    D.S EZAXI:&offset %LE %LONG 0xFFFFFFFF

	&offset=&SPDM_OLEM_CFG0+0x4
    D.S EZAXI:&offset %LE %LONG &period_us

	&offset=&SPDM_OLEM_CFG0
    D.S EZAXI:&offset %LE %LONG 0x00000A

	&offset=&SPDM_OLEM_CFG0
    D.S EZAXI:&offset %LE %LONG &iterations

	&offset=&SPDM_OLEM_CFG0+0xC
    D.S EZAXI:&offset %LE %LONG 0x0

	&offset=&SPDM_OLEM_CFG0+0x14
    D.S EZAXI:&offset %LE %LONG 0xFF

    print "  Setup SPDM based perioic triggers at &period_us Done."

RETURN



