
;============================================================================
;
; *************** THIS SCRIPT WAS AUTOGENERATED ****************
;
; TARGET
;
;
; SCRIPT
;   TESTPLL.CMM
;
; GENERAL DESCRIPTION
;   This script can be used to lookup PLL config/status/frequency values.
;
; FUNCTIONS
;   N/A
;
;    Copyright (c) 2015 by QUALCOMM Technologies Inc.  All Rights Reserved.
;============================================================================


;-----------------------------------------------------------------------------
; Local variables
;-----------------------------------------------------------------------------

local &clk_err
local &success
local &chipset_name
local &testpll_main_area
local &subscript
local &pre_div
local &post_div
local &access_mode

local &log_filename
local &logging
&logging=0

; PLLs available in this version of the script
local &pll0
local &pll1
local &pll2
local &pll3
local &pll4
local &pll5
local &pll6
local &pll7
local &pll8
local &pll9
local &pll10
local &pll11
local &pll12
local &pll13
local &pll14
local &pll15
local &pll16
local &pll17


;-----------------------------------------------------------------------------
; Go initialize constants
;-----------------------------------------------------------------------------

goto Init_Constants
Init_Constants_Done:


;-----------------------------------------------------------------------------
; Parse commandline arguments
;-----------------------------------------------------------------------------

;
; These arguments are passed in from testclock.cmm to enable a PLL
;
; TODO: is the above statement still accurate?
;
&testpll_cmd_arg0=""
&testpll_cmd_arg1=""

ENTRY &testpll_cmd_arg0 &testpll_cmd_arg1

if ("&testpll_cmd_arg0"=="on")||("&testpll_cmd_arg0"=="off")
(
  &pll_on_off_choice="&testpll_cmd_arg0"
  &pll_name_choice="&testpll_cmd_arg1"
  
  gosub Enable_Disable_PLL
  
  ; Nothing else to be done
  goto SCRIPT_END
)

;-----------------------------------------------------------------------------
; Define the window
;-----------------------------------------------------------------------------

; Check if testpll was invoked by another script ('super_script_area' mode).
&testpll_main_area=string.ScanAndExtract("&testpll_cmd_arg0", "super_script_area=", "TESTPLL")

; Create new areas.
if ("&testpll_main_area"=="TESTPLL")
(
  &subscript=0
  gosub area_create_list 1 &testpll_main_area 180. 1000.
  entry &success

  if (&success==0)
  (
    area.select
    print %ERROR "ERROR: Failed to create areas for testclock.cmm."
    enddo FALSE()
  )
)
else
(
  &subscript=1
)

; Create a new window if needed.
if (WIN.EXIST("testpll_main_window")==FALSE())
(
  local &x_start
  local &y_start
  local &x_len
  local &y_len

  ; Check if there are previously saved window settings.
  gosub find_saved_window_settings testpll_main_window
  entry &x_start &y_start &x_len &y_len

  if (&x_start!=-1)
  (
    ; Use the previous window settings.
    winpos &x_start &y_start &x_len &y_len 0. 0. testpll_main_window
  )
  else
  (
    gosub Default_WINPOS_Main
  )
)

AREA.view &testpll_main_area
AREA.Select &testpll_main_area


;-----------------------------------------------------------------------------
; Generic Top-Level Error Handler
;-----------------------------------------------------------------------------

on ERROR gosub
(
  print %ERROR "ERROR: Caught error in 'testpll.cmm'."
  return
)


;-----------------------------------------------------------------------------
; Main Menu
;-----------------------------------------------------------------------------

print ""
print ""
print "[-------------------- [&chipset_name] TEST PLL --------------------]"
print ""

gosub Display_Help  ; print help message upon launch

Main_Loop:
(
  print ""
  print "[testpll.cmm] Version: <04/30/2015>" 
  print "Enter command (? for help):"
  enter &choice
  print ""

  gosub save_window_settings testpll_main_window

  if ("&choice"=="?")
  (
    gosub Display_Help
  )
  else if ("&choice"=="x")
  (
    winclear testpll_main_window

    if (&logging!=0)
    (
      area.close &testpll_main_area
    )

    area.select   ; select default area

    print "Exited [&chipset_name] 'testpll.cmm'."
    enddo TRUE()
  )
  else if ("&choice"=="log")
  (
    gosub Open_Output_Log
  )
  else if ("&choice"=="wr")
  (
    ; Reset the window size/position to default settings.
    winclear testpll_main_window

    gosub Default_WINPOS_Main
    area.view &testpll_main_area
  )
  else if ("&choice"=="1")
  (
    gosub Display_Configurations
  )
  else if ("&choice"=="2")
  (
    gosub Display_Votes
  )
  else if ("&choice"=="3")
  (
    gosub Display_Dump
  )
  else if ("&choice"=="4")
  (
    gosub Configure_PLL_Enter
  )
  else if ("&choice"=="5")
  (
    gosub Enable_Disable_PLL_Enter
  )
  else if ("&choice"=="6")
  (
    gosub Route_PLL_To_Pad
  )
  else
  (
    print %ERROR "ERROR: Invalid command '&choice'. Enter '?' for help."
  )

  goto Main_Loop
)

Display_Help:
(
  print ""
  print "*** Commands ***"
  print ""
  print " 1   : Configurations."
  print " 2   : Votes."
  print " 3   : Register Dump."
  print " 4   : Configure PLLs.         [beta]"
  print " 5   : Turn PLLs on/off.       [beta]"
  print " 6   : Route PLLs to test pad. [beta]"
  print ""
  print " log : Start logging output to a file."
  print " x   : Exit."
  print " wr  : Reset window size/position."
  print ""

  return
)

Default_WINPOS_Main:
(
  winpos 0. 0. 50% 100% 0. 0. testpll_main_window
  return
)

;
; Begins logging output to a file.
;
Open_Output_Log:
(
  ; Check if an output log is already open.
  if (&logging==0)
  (
    print "Enter log file [c:\temp\testpll.log]: "
    enter &log_filename

    if ("&log_filename"=="")
    (
      &log_filename="c:\temp\testpll.log"
    )
    print "Logging output to '&log_filename'."

    ; Open the output log.
    (
      ON ERROR gosub
      (
        print %ERROR "ERROR: Failed to open clock output log '&log_filename'."
        &clk_err="failed_to_open_output_log"
        return
      )

      &clk_err=""
      area.open &testpll_main_area &log_filename
    )

    if ("&clk_err"!="failed_to_open_output_log")
    (
      &logging=1
    )
  )
  else
  (
    ; Does not currently support multiple output logs per single session.
    print "Already logging output to '&log_filename'. The log will close upon 'x' exit."
  )

  return
)


;-----------------------------------------------------------------------------
; Initialize constants
;-----------------------------------------------------------------------------

Init_Constants:

  ; Chipset Name
  &chipset_name="msm8996"

  ; Access mode
  &access_mode="ezaxi"

  ; L, M, N, ALPHA, ALPHA_U mask values
  &HWIO_PLL_L_VAL_MASK=0xFFFF
  &HWIO_PLL_M_VAL_MASK=0x7FFFF
  &HWIO_PLL_N_VAL_MASK=0x7FFFF
  &HWIO_PLL_ALPHA_VAL_MASK=0xFFFFFFFF
  &HWIO_PLL_ALPHA_U_VAL_MASK=0xFF

  ; PLL vote registers
  &HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR=0x352000
  &HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR=0x353000
  &HWIO_GCC_LPASS_DSP_GPLL_ENA_VOTE_ADDR=0x355000
  &HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR=0x351000
  &HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR=0x357000
  &HWIO_GCC_SSC_GPLL_ENA_VOTE_ADDR=0x354000
  &HWIO_LPASS_LPA_PLL_VOTE_APPS_ADDR=0x9003000
  &HWIO_LPASS_LPA_PLL_VOTE_LPASSQ6_ADDR=0x9004000
  &HWIO_LPASS_LPA_PLL_VOTE_LPASS_HW_ADDR=0x9005000
  &HWIO_MMSS_MMSS_PLL_VOTE_APCS_ADDR=0x8c0100
  &HWIO_MMSS_MMSS_PLL_VOTE_RPM_ADDR=0x8c4230
  &HWIO_GCC_HYP_GPLL_ENA_VOTE_ADDR=0x356000
  &HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR=0x335000
  &HWIO_GCC_SPARE1_GPLL_ENA_VOTE_ADDR=0x35a000
  &HWIO_GCC_SPARE2_GPLL_ENA_VOTE_ADDR=0x369000

  ; GPLL0 registers
  &HWIO_GCC_GPLL0_MODE_ADDR=0x300000
  &HWIO_GCC_GPLL0_L_VAL_ADDR=0x300004
  &HWIO_GCC_GPLL0_ALPHA_VAL_ADDR=0x300008
  &HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR=0x30000c
  &HWIO_GCC_GPLL0_USER_CTL_ADDR=0x300010
  &HWIO_GCC_GPLL0_USER_CTL_U_ADDR=0x300014
  &HWIO_GCC_GPLL0_CONFIG_CTL_ADDR=0x300018
  &HWIO_GCC_GPLL0_TEST_CTL_ADDR=0x30001c
  &HWIO_GCC_GPLL0_TEST_CTL_U_ADDR=0x300020
  &HWIO_GCC_GPLL0_STATUS_ADDR=0x300024

  ; GPLL1 registers
  &HWIO_GCC_GPLL1_MODE_ADDR=0x301000
  &HWIO_GCC_GPLL1_L_VAL_ADDR=0x301004
  &HWIO_GCC_GPLL1_ALPHA_VAL_ADDR=0x301008
  &HWIO_GCC_GPLL1_ALPHA_VAL_U_ADDR=0x30100c
  &HWIO_GCC_GPLL1_USER_CTL_ADDR=0x301010
  &HWIO_GCC_GPLL1_USER_CTL_U_ADDR=0x301014
  &HWIO_GCC_GPLL1_CONFIG_CTL_ADDR=0x301018
  &HWIO_GCC_GPLL1_TEST_CTL_ADDR=0x30101c
  &HWIO_GCC_GPLL1_TEST_CTL_U_ADDR=0x301020
  &HWIO_GCC_GPLL1_STATUS_ADDR=0x301024

  ; GPLL2 registers
  &HWIO_GCC_GPLL2_MODE_ADDR=0x302000
  &HWIO_GCC_GPLL2_L_VAL_ADDR=0x302004
  &HWIO_GCC_GPLL2_ALPHA_VAL_ADDR=0x302008
  &HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR=0x30200c
  &HWIO_GCC_GPLL2_USER_CTL_ADDR=0x302010
  &HWIO_GCC_GPLL2_USER_CTL_U_ADDR=0x302014
  &HWIO_GCC_GPLL2_CONFIG_CTL_ADDR=0x302018
  &HWIO_GCC_GPLL2_TEST_CTL_ADDR=0x30201c
  &HWIO_GCC_GPLL2_TEST_CTL_U_ADDR=0x302020
  &HWIO_GCC_GPLL2_STATUS_ADDR=0x302024

  ; GPLL3 registers
  &HWIO_GCC_GPLL3_MODE_ADDR=0x303000
  &HWIO_GCC_GPLL3_L_VAL_ADDR=0x303004
  &HWIO_GCC_GPLL3_ALPHA_VAL_ADDR=0x303008
  &HWIO_GCC_GPLL3_ALPHA_VAL_U_ADDR=0x30300c
  &HWIO_GCC_GPLL3_USER_CTL_ADDR=0x303010
  &HWIO_GCC_GPLL3_USER_CTL_U_ADDR=0x303014
  &HWIO_GCC_GPLL3_CONFIG_CTL_ADDR=0x303018
  &HWIO_GCC_GPLL3_TEST_CTL_ADDR=0x30301c
  &HWIO_GCC_GPLL3_TEST_CTL_U_ADDR=0x303020
  &HWIO_GCC_GPLL3_STATUS_ADDR=0x303024

  ; GPLL4 registers
  &HWIO_GCC_GPLL4_MODE_ADDR=0x377000
  &HWIO_GCC_GPLL4_L_VAL_ADDR=0x377004
  &HWIO_GCC_GPLL4_ALPHA_VAL_ADDR=0x377008
  &HWIO_GCC_GPLL4_ALPHA_VAL_U_ADDR=0x37700c
  &HWIO_GCC_GPLL4_USER_CTL_ADDR=0x377010
  &HWIO_GCC_GPLL4_USER_CTL_U_ADDR=0x377014
  &HWIO_GCC_GPLL4_CONFIG_CTL_ADDR=0x377018
  &HWIO_GCC_GPLL4_TEST_CTL_ADDR=0x37701c
  &HWIO_GCC_GPLL4_TEST_CTL_U_ADDR=0x377020
  &HWIO_GCC_GPLL4_STATUS_ADDR=0x377024

  ; LPASS_LPAAUDIO_PLL registers
  &HWIO_LPASS_LPAAUDIO_PLL_MODE_ADDR=0x9000000
  &HWIO_LPASS_LPAAUDIO_PLL_L_VAL_ADDR=0x9000004
  &HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_ADDR=0x9000008
  &HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_U_ADDR=0x900000c
  &HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_ADDR=0x9000010
  &HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_U_ADDR=0x9000014
  &HWIO_LPASS_LPAAUDIO_PLL_CONFIG_CTL_ADDR=0x9000018
  &HWIO_LPASS_LPAAUDIO_PLL_TEST_CTL_ADDR=0x900001c
  &HWIO_LPASS_LPAAUDIO_PLL_TEST_CTL_U_ADDR=0x9000020
  &HWIO_LPASS_LPAAUDIO_PLL_STATUS_ADDR=0x9000024

  ; LPASS_LPAAUDIO_DIG_PLL registers
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_MODE_ADDR=0x9001000
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_L_VAL_ADDR=0x9001004
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_ADDR=0x9001008
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_U_ADDR=0x900100c
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_ADDR=0x9001010
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_U_ADDR=0x9001014
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_CONFIG_CTL_ADDR=0x9001018
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_TEST_CTL_ADDR=0x900101c
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_TEST_CTL_U_ADDR=0x9001020
  &HWIO_LPASS_LPAAUDIO_DIG_PLL_STATUS_ADDR=0x9001024

  ; LPASS_QDSP6SS_PLL registers
  &HWIO_LPASS_QDSP6SS_PLL_MODE_ADDR=0x9300200
  &HWIO_LPASS_QDSP6SS_PLL_L_VAL_ADDR=0x9300204
  &HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_ADDR=0x9300208
  &HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_U_ADDR=0x930020c
  &HWIO_LPASS_QDSP6SS_PLL_USER_CTL_ADDR=0x9300210
  &HWIO_LPASS_QDSP6SS_PLL_USER_CTL_U_ADDR=0x9300214
  &HWIO_LPASS_QDSP6SS_PLL_CONFIG_CTL_ADDR=0x9300218
  &HWIO_LPASS_QDSP6SS_PLL_TEST_CTL_ADDR=0x930021c
  &HWIO_LPASS_QDSP6SS_PLL_TEST_CTL_U_ADDR=0x9300220
  &HWIO_LPASS_QDSP6SS_PLL_STATUS_ADDR=0x9300224

  ; MMPLL0_PLL registers
  &HWIO_MMSS_MMPLL0_PLL_MODE_ADDR=0x8c0000
  &HWIO_MMSS_MMPLL0_PLL_L_VAL_ADDR=0x8c0004
  &HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_ADDR=0x8c0008
  &HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_U_ADDR=0x8c000c
  &HWIO_MMSS_MMPLL0_PLL_USER_CTL_ADDR=0x8c0010
  &HWIO_MMSS_MMPLL0_PLL_USER_CTL_U_ADDR=0x8c0014
  &HWIO_MMSS_MMPLL0_PLL_CONFIG_CTL_ADDR=0x8c0018
  &HWIO_MMSS_MMPLL0_PLL_TEST_CTL_ADDR=0x8c001c
  &HWIO_MMSS_MMPLL0_PLL_TEST_CTL_U_ADDR=0x8c0020
  &HWIO_MMSS_MMPLL0_PLL_STATUS_ADDR=0x8c0024

  ; MMPLL1_PLL registers
  &HWIO_MMSS_MMPLL1_PLL_MODE_ADDR=0x8c0030
  &HWIO_MMSS_MMPLL1_PLL_L_VAL_ADDR=0x8c0034
  &HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_ADDR=0x8c0038
  &HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_U_ADDR=0x8c003c
  &HWIO_MMSS_MMPLL1_PLL_USER_CTL_ADDR=0x8c0040
  &HWIO_MMSS_MMPLL1_PLL_USER_CTL_U_ADDR=0x8c0044
  &HWIO_MMSS_MMPLL1_PLL_CONFIG_CTL_ADDR=0x8c0048
  &HWIO_MMSS_MMPLL1_PLL_TEST_CTL_ADDR=0x8c004c
  &HWIO_MMSS_MMPLL1_PLL_TEST_CTL_U_ADDR=0x8c0050
  &HWIO_MMSS_MMPLL1_PLL_STATUS_ADDR=0x8c0054

  ; MMPLL2_PLL registers
  &HWIO_MMSS_MMPLL2_PLL_MODE_ADDR=0x8c4100
  &HWIO_MMSS_MMPLL2_PLL_L_VAL_ADDR=0x8c4104
  &HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_ADDR=0x8c4108
  &HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_U_ADDR=0x8c410c
  &HWIO_MMSS_MMPLL2_PLL_USER_CTL_ADDR=0x8c4110
  &HWIO_MMSS_MMPLL2_PLL_USER_CTL_U_ADDR=0x8c4114
  &HWIO_MMSS_MMPLL2_PLL_CONFIG_CTL_ADDR=0x8c4118
  &HWIO_MMSS_MMPLL2_PLL_TEST_CTL_ADDR=0x8c411c
  &HWIO_MMSS_MMPLL2_PLL_TEST_CTL_U_ADDR=0x8c4120
  &HWIO_MMSS_MMPLL2_PLL_STATUS_ADDR=0x8c4124

  ; MMPLL3_PLL registers
  &HWIO_MMSS_MMPLL3_PLL_MODE_ADDR=0x8c0060
  &HWIO_MMSS_MMPLL3_PLL_L_VAL_ADDR=0x8c0064
  &HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_ADDR=0x8c0068
  &HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_U_ADDR=0x8c006c
  &HWIO_MMSS_MMPLL3_PLL_USER_CTL_ADDR=0x8c0070
  &HWIO_MMSS_MMPLL3_PLL_USER_CTL_U_ADDR=0x8c0074
  &HWIO_MMSS_MMPLL3_PLL_CONFIG_CTL_ADDR=0x8c0078
  &HWIO_MMSS_MMPLL3_PLL_TEST_CTL_ADDR=0x8c007c
  &HWIO_MMSS_MMPLL3_PLL_TEST_CTL_U_ADDR=0x8c0080
  &HWIO_MMSS_MMPLL3_PLL_STATUS_ADDR=0x8c0084

  ; MMPLL4_PLL registers
  &HWIO_MMSS_MMPLL4_PLL_MODE_ADDR=0x8c0090
  &HWIO_MMSS_MMPLL4_PLL_L_VAL_ADDR=0x8c0094
  &HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_ADDR=0x8c0098
  &HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_U_ADDR=0x8c009c
  &HWIO_MMSS_MMPLL4_PLL_USER_CTL_ADDR=0x8c00a0
  &HWIO_MMSS_MMPLL4_PLL_USER_CTL_U_ADDR=0x8c00a4
  &HWIO_MMSS_MMPLL4_PLL_CONFIG_CTL_ADDR=0x8c00a8
  &HWIO_MMSS_MMPLL4_PLL_TEST_CTL_ADDR=0x8c00ac
  &HWIO_MMSS_MMPLL4_PLL_TEST_CTL_U_ADDR=0x8c00b0
  &HWIO_MMSS_MMPLL4_PLL_STATUS_ADDR=0x8c00b4

  ; MMPLL5_PLL registers
  &HWIO_MMSS_MMPLL5_PLL_MODE_ADDR=0x8c00c0
  &HWIO_MMSS_MMPLL5_PLL_L_VAL_ADDR=0x8c00c4
  &HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_ADDR=0x8c00c8
  &HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_U_ADDR=0x8c00cc
  &HWIO_MMSS_MMPLL5_PLL_USER_CTL_ADDR=0x8c00d0
  &HWIO_MMSS_MMPLL5_PLL_USER_CTL_U_ADDR=0x8c00d4
  &HWIO_MMSS_MMPLL5_PLL_CONFIG_CTL_ADDR=0x8c00d8
  &HWIO_MMSS_MMPLL5_PLL_TEST_CTL_ADDR=0x8c00dc
  &HWIO_MMSS_MMPLL5_PLL_TEST_CTL_U_ADDR=0x8c00e0
  &HWIO_MMSS_MMPLL5_PLL_STATUS_ADDR=0x8c00e4

  ; MMPLL8_PLL registers
  &HWIO_MMSS_MMPLL8_PLL_MODE_ADDR=0x8c4130
  &HWIO_MMSS_MMPLL8_PLL_L_VAL_ADDR=0x8c4134
  &HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_ADDR=0x8c4138
  &HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_U_ADDR=0x8c413c
  &HWIO_MMSS_MMPLL8_PLL_USER_CTL_ADDR=0x8c4140
  &HWIO_MMSS_MMPLL8_PLL_USER_CTL_U_ADDR=0x8c4144
  &HWIO_MMSS_MMPLL8_PLL_CONFIG_CTL_ADDR=0x8c4148
  &HWIO_MMSS_MMPLL8_PLL_TEST_CTL_ADDR=0x8c414c
  &HWIO_MMSS_MMPLL8_PLL_TEST_CTL_U_ADDR=0x8c4150
  &HWIO_MMSS_MMPLL8_PLL_STATUS_ADDR=0x8c4154

  ; MMPLL9_PLL registers
  &HWIO_MMSS_MMPLL9_PLL_MODE_ADDR=0x8c4200
  &HWIO_MMSS_MMPLL9_PLL_L_VAL_ADDR=0x8c4204
  &HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_ADDR=0x8c4208
  &HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_U_ADDR=0x8c420c
  &HWIO_MMSS_MMPLL9_PLL_USER_CTL_ADDR=0x8c4210
  &HWIO_MMSS_MMPLL9_PLL_USER_CTL_U_ADDR=0x8c4214
  &HWIO_MMSS_MMPLL9_PLL_CONFIG_CTL_ADDR=0x8c4218
  &HWIO_MMSS_MMPLL9_PLL_TEST_CTL_ADDR=0x8c421c
  &HWIO_MMSS_MMPLL9_PLL_TEST_CTL_U_ADDR=0x8c4220
  &HWIO_MMSS_MMPLL9_PLL_STATUS_ADDR=0x8c4224

  ; SCC_PEEL_PLL registers
  &HWIO_SSC_SCC_SCC_PEEL_PLL_MODE_ADDR=0x1e20000
  &HWIO_SSC_SCC_SCC_PEEL_PLL_L_VAL_ADDR=0x1e20004
  &HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_ADDR=0x1e2000c
  &HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_U_ADDR=0x1e20010
  &HWIO_SSC_SCC_SCC_PEEL_PLL_CONFIG_CTL_ADDR=0x1e20014
  &HWIO_SSC_SCC_SCC_PEEL_PLL_TEST_CTL_ADDR=0x1e20018
  &HWIO_SSC_SCC_SCC_PEEL_PLL_TEST_CTL_U_ADDR=0x1e2001c
  &HWIO_SSC_SCC_SCC_PEEL_PLL_STATUS_ADDR=0x1e20020

  ; QDSP6SS_PLL registers
  &HWIO_SSC_QDSP6SS_PLL_MODE_ADDR=0x1c00200
  &HWIO_SSC_QDSP6SS_PLL_L_VAL_ADDR=0x1c00204
  &HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_ADDR=0x1c00208
  &HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_U_ADDR=0x1c0020c
  &HWIO_SSC_QDSP6SS_PLL_USER_CTL_ADDR=0x1c00210
  &HWIO_SSC_QDSP6SS_PLL_USER_CTL_U_ADDR=0x1c00214
  &HWIO_SSC_QDSP6SS_PLL_CONFIG_CTL_ADDR=0x1c00218
  &HWIO_SSC_QDSP6SS_PLL_TEST_CTL_ADDR=0x1c0021c
  &HWIO_SSC_QDSP6SS_PLL_TEST_CTL_U_ADDR=0x1c00220
  &HWIO_SSC_QDSP6SS_PLL_STATUS_ADDR=0x1c00224

  goto Init_Constants_Done


;-----------------------------------------------------------------------------
; Calculate Pre-div and Post-Div for SR PLLs; where
; Pre-Div  [14:12]
; Post-Div [9:8]
;-----------------------------------------------------------------------------

Calculate_Pre_Post_Div_SR:

  if (&user_ctl_val&0x7000)==0x0000
    &pre_div=1
  else if (&user_ctl_val&0x7000)==0x1000
    &pre_div=2
  else if (&user_ctl_val&0x7000)==0x2000
    &pre_div=3
  else if (&user_ctl_val&0x7000)==0x3000
    &pre_div=4
  else if (&user_ctl_val&0x7000)==0x4000
    &pre_div=5
  else if (&user_ctl_val&0x7000)==0x5000
    &pre_div=6
  else if (&user_ctl_val&0x7000)==0x6000
    &pre_div=7
  else
    &pre_div=8

  if (&user_ctl_val&0x300)==0x000
    &post_div=1
  else if (&user_ctl_val&0x300)==0x100
    &post_div=2
  else
    &post_div=4

  return


;-----------------------------------------------------------------------------
; Calculate Pre-div and Post-Div for SR2/HF PLLs; where
; Pre-Div  [12]
; Post-Div [9:8]
;-----------------------------------------------------------------------------

Calculate_Pre_Post_Div_SR2_HF:

  if (&user_ctl_val&0x1000)==0x0000
    &pre_div=1
  else
    &pre_div=2

  if (&user_ctl_val&0x300)==0x000
    &post_div=1
  else if (&user_ctl_val&0x300)==0x100
    &post_div=2
  else
    &post_div=4

  return


;-----------------------------------------------------------------------------
; Calculate Pre-div and Post-Div for PRIUS/TESLA PLLs; where
; Pre-Div  [??]
; Post-Div [??]
;-----------------------------------------------------------------------------

Calculate_Pre_Post_Div_PRIUS_TESLA:

  if (&user_ctl_val&0x7000)==0x1000
    &pre_div=2
  else
    &pre_div=1
  
  if (&user_ctl_val&0xF00)==0x100
    &post_div=2
  else if (&user_ctl_val&0xF00)==0x300
    &post_div=4
  else if (&user_ctl_val&0xF00)==0x700
    &post_div=8
  else if (&user_ctl_val&0xF00)==0xF00
    &post_div=16
  else
    &post_div=1

  return



;-----------------------------------------------------------------------------
; Display the PLL settings
;-----------------------------------------------------------------------------

Display_PLL:

  ENTRY &pll_name &pll_num &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref

  local &mode_val
  local &l_val
  local &alpha_val
  local &alpha_u_val
  local &m_val
  local &n_val
  local &user_ctl_val
  local &user_ctl_u_val
  local &status_val
  local &pll_state
  local &pll_votable
  local &pll_main
  local &pll_test
  local &pll_aux
  local &pll_aux2
  local &pll_early
  local &pll_freq
  local &alpha_combined_hex
  local &alpha_divisor
  local &alpha_float
  local &pll_num_formatted
  local &pll_name_formatted

  &mode_val=data.long(&access_mode:&mode_reg)
  &l_val=data.long(&access_mode:&l_reg)&(&HWIO_PLL_L_VAL_MASK)

  ; Get m value
  if (&m_reg!=0)
    &m_val=data.long(&access_mode:&m_reg)&(&HWIO_PLL_M_VAL_MASK)
  else
    &m_val=0

  ; Get n value
  if (&n_reg!=0)
  (
    &n_val=data.long(&access_mode:&n_reg)&(&HWIO_PLL_N_VAL_MASK)
    if &n_val==0
      &n_val=1
  )
  else
    &n_val=0

  ; Get alpha value
  if (&alpha_reg!=0)
    &alpha_val=data.long(&access_mode:&alpha_reg)&(&HWIO_PLL_ALPHA_VAL_MASK)
  else
    &alpha_val=0

  ; Get alpha_u value
  if (&alpha_u_reg!=0)
    &alpha_u_val=data.long(&access_mode:&alpha_u_reg)&(&HWIO_PLL_ALPHA_U_VAL_MASK)
  else
    &alpha_u_val=0

  &status_val=data.long(&access_mode:&status_reg)
  &user_ctl_val=data.long(&access_mode:&user_ctl_reg)

 ; Check for ON/OFF status
  if (&mode_val&0x80000000)==0x80000000
    &pll_state="ON "
  else
    &pll_state="OFF"

  ; Check for FSM mode
  if (&mode_val&0x100000)==0x100000
    &pll_votable="YES"
  else
    &pll_votable="NO "

  ; Check for test output
  if (&user_ctl_val&0x10)==0x10
    &pll_test="ON "
  else
    &pll_test="OFF"

  ; Check for early output
  if (&user_ctl_val&0x08)==0x08
    &pll_early="ON "
  else
    &pll_early="OFF"

  ; Check for aux2 output
  if (&user_ctl_val&0x04)==0x04
    &pll_aux2="ON "
  else
    &pll_aux2="OFF"

  ; Check for aux output
  if (&user_ctl_val&0x02)==0x02
    &pll_aux="ON "
  else
    &pll_aux="OFF"

 ; Check for main output
  if (&user_ctl_val&0x01)==0x01
    &pll_main="ON "
  else
    &pll_main="OFF"

  ; Check pre-div and post-div
  if ("&pll_type"=="sr_pll")
  (
    gosub Calculate_Pre_Post_Div_SR
  )
  else if ("&pll_type"=="sr2_pll")||("&pll_type"=="hf_pll")
  (
    gosub Calculate_Pre_Post_Div_SR2_HF
  )
  else
  (
    gosub Calculate_Pre_Post_Div_PRIUS_TESLA
  )

  ; Calculate the PLL frequency based on PLL type.
  if (&m_reg!=0)
  (
    &pll_freq=FORMAT.FLOAT(10, 6, (&clk_ref*&l_val+&clk_ref*&m_val/&n_val)/&pre_div/&post_div)
  )
  else
  (
    ; Combine alpha lower + upper
    &alpha_combined_hex=&alpha_val+(&alpha_u_val<<32.)
    &alpha_float=(&alpha_combined_hex*1.0)/((1<<40.)*1.0)

    &pll_freq=FORMAT.FLOAT(10, 6, (&clk_ref/&pre_div)*((&l_val+&alpha_float)/&post_div))
  )

  ; Format the pll num and name strings
  ;&pll_num_formatted=FORMAT.DECIMAL(2., &pll_num)
  &pll_num_formatted=&pll_num

  ;&pll_name_formatted=STRING.CUT("        ", STRING.LEN("&pll_name"))
  ;&pll_name_formatted="&pll_name&pll_name_formatted"
  &pll_name_formatted=&pll_name

  print "&pll_num_formatted  &pll_name_formatted    &pll_state        &pll_votable        &pll_main        &pll_test        &pll_aux        &pll_aux2        &pll_early  &pll_freq"

  return


;-----------------------------------------------------------------------------
; Format dump registers 
;-----------------------------------------------------------------------------

Format_Dump_Registers:

  ENTRY &num &use &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  local &mode_val
  local &user_ctl_val
  local &user_ctl_u_val
  local &config_ctl_val
  local &test_ctl_val
  local &test_ctl_u_val
  local &status_val
  local &l_val
  local &alpha_val
  local &alpha_u_val
  local &m_val
  local &n_val
  local &left_width
  local &temp_string
  local &temp_string_formatted

  ; Format PLL num and use
  &num=FORMAT.DECIMAL(0x2, &num)

  ; Format mode
  &mode_val=FORMAT.HEX(0x8, data.long(&access_mode:&mode_reg))
  &mode_reg=FORMAT.HEX(0x9, &mode_reg)

  ; Format l 
  &l_val=FORMAT.HEX(0x8, data.long(&access_mode:&l_reg))
  &l_reg=FORMAT.HEX(0x9, &l_reg)

  ; Format alpha if the register address is not zero
  if (&alpha_reg!=0)
  (
    &alpha_val=FORMAT.HEX(0x8, data.long(&access_mode:&alpha_reg))
    &alpha_reg=FORMAT.HEX(0x9, &alpha_reg)
  )

  ; Format alpha_u if the register address is not zero
  if (&alpha_u_reg!=0)
  (
    &alpha_u_val=FORMAT.HEX(0x8, data.long(&access_mode:&alpha_u_reg))
    &alpha_u_reg=FORMAT.HEX(0x9, &alpha_u_reg)
  )

  ; Format m if the register address is not zero
  if (&m_reg!=0)
  (
    &m_val=FORMAT.HEX(0x8, data.long(&access_mode:&m_reg))
    &m_reg=FORMAT.HEX(0x9, &m_reg)
  )

  ; Format n if the register address is not zero
  if (&n_reg!=0)
  (
    &n_val=FORMAT.HEX(0x8, data.long(&access_mode:&n_reg))
    &n_reg=FORMAT.HEX(0x9, &n_reg)
  )

  ; Format user_ctl
  &user_ctl_val=FORMAT.HEX(0x8, data.long(&access_mode:&user_ctl_reg))
  &user_ctl_reg=FORMAT.HEX(0x9, &user_ctl_reg)

  ; Format user_ctl_u if the register address is not zero
  if (&user_ctl_u_reg!=0)
  (
    &user_ctl_u_val=FORMAT.HEX(0x8, data.long(&access_mode:&user_ctl_u_reg))
    &user_ctl_u_reg=FORMAT.HEX(0x9, &user_ctl_u_reg)
  )

  ; Format config_ctl
  &config_ctl_val=FORMAT.HEX(0x8, data.long(&access_mode:&config_ctl_reg))
  &config_ctl_reg=FORMAT.HEX(0x9, &config_ctl_reg)

  ; Format test_ctl
  &test_ctl_val=FORMAT.HEX(0x8, data.long(&access_mode:&test_ctl_reg))
  &test_ctl_reg=FORMAT.HEX(0x9, &test_ctl_reg)

  ; Format test_ctl_u if the register address is not zero
  if (&test_ctl_u_reg!=0)
  (
    &test_ctl_u_val=FORMAT.HEX(0x8, data.long(&access_mode:&test_ctl_u_reg))
    &test_ctl_u_reg=FORMAT.HEX(0x9, &test_ctl_u_reg)
  )

  ; Format status
  &status_val=FORMAT.HEX(0x8, data.long(&access_mode:&status_reg))
  &status_reg=FORMAT.HEX(0x9, &status_reg)

  &left_width="                                     "

  print "__________________________________________________________________"
  &temp_string="[PLL&num : &use]"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string&temp_string_formatted"
  print "&temp_string_formatted | |     Address : Value"

  &temp_string="MODE"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&mode_reg : 0x&mode_val"

  &temp_string="L"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&l_reg : 0x&l_val"

  if (&alpha_reg!=0)
  (
    &temp_string="ALPHA"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&alpha_reg : 0x&alpha_val"
  )

  if (&alpha_u_reg!=0)
  (
    &temp_string="ALPHA_U"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&alpha_u_reg : 0x&alpha_u_val"
  )

  if (&m_reg!=0)
  (
    &temp_string="M"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&m_reg : 0x&m_val"
  )

  if (&n_reg!=0)
  (
    &temp_string="N"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&n_reg : 0x&n_val"
  )

  &temp_string="USER_CTL"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&user_ctl_reg : 0x&user_ctl_val"

  if (&user_ctl_u_reg!=0)
  (
    &temp_string="USER_CTL_U"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&user_ctl_u_reg : 0x&user_ctl_u_val"
  )

  &temp_string="CONFIG_CTL"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&config_ctl_reg : 0x&config_ctl_val"

  &temp_string="TEST_CTL"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&test_ctl_reg : 0x&test_ctl_val"

  if (&test_ctl_u_reg!=0)
  (
    &temp_string="TEST_CTL_U"
    &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
    &temp_string_formatted="&temp_string_formatted&temp_string"
    print "&temp_string_formatted | | 0x&test_ctl_u_reg : 0x&test_ctl_u_val"
  )

  &temp_string="STATUS"
  &temp_string_formatted=STRING.CUT("&left_width", STRING.LEN("&temp_string"))
  &temp_string_formatted="&temp_string_formatted&temp_string"
  print "&temp_string_formatted | | 0x&status_reg : 0x&status_val"

  return


;-----------------------------------------------------------------------
; Display Configurations
;-----------------------------------------------------------------------

Display_Configurations:

  local &pll_name
  local &pll_num
  local &pll_type
  local &l_reg
  local &m_reg
  local &n_reg
  local &alpha_reg
  local &alpha_u_reg
  local &mode_reg
  local &user_ctl_reg
  local &status_reg

  print "PLL            USE                   STATE     VOTABLE   MAIN_OUT   TEST_OUT    AUX_OUT   AUX2_OUT   EARLY_OUT   CALC FREQ (MHz)"
  print "--- ------------------------------   -----     -------   --------   --------    -------   --------   ---------   ---------------"


  &pll_name="GPLL0                       "
  &pll_num="0  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL0_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL0_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL0_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="GPLL1                       "
  &pll_num="1  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL1_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL1_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_GCC_GPLL1_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL1_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL1_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="GPLL2                       "
  &pll_num="2  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL2_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL2_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL2_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="GPLL3                       "
  &pll_num="3  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_GCC_GPLL3_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL3_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL3_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL3_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_GCC_GPLL3_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL3_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL3_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="GPLL4                       "
  &pll_num="4  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_GCC_GPLL4_MODE_ADDR
  &l_reg=&HWIO_GCC_GPLL4_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_GCC_GPLL4_USER_CTL_ADDR
  &status_reg=&HWIO_GCC_GPLL4_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_GCC_GPLL4_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL4_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL4_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="LPASS_LPAAUDIO_PLL          "
  &pll_num="5  "
  &pll_type="brammo_pll"
  &mode_reg=&HWIO_LPASS_LPAAUDIO_PLL_MODE_ADDR
  &l_reg=&HWIO_LPASS_LPAAUDIO_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_LPASS_LPAAUDIO_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="LPASS_LPAAUDIO_DIG_PLL      "
  &pll_num="6  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_MODE_ADDR
  &l_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="LPASS_QDSP6SS_PLL           "
  &pll_num="7  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_LPASS_QDSP6SS_PLL_MODE_ADDR
  &l_reg=&HWIO_LPASS_QDSP6SS_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_LPASS_QDSP6SS_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_LPASS_QDSP6SS_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_LPASS_QDSP6SS_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL0_PLL                  "
  &pll_num="8  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_MMSS_MMPLL0_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL0_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL0_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL0_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL0_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL1_PLL                  "
  &pll_num="9  "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_MMSS_MMPLL1_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL1_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL1_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL1_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL1_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL2_PLL                  "
  &pll_num="10 "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_MMSS_MMPLL2_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL2_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL2_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL2_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL2_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL3_PLL                  "
  &pll_num="11 "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_MMSS_MMPLL3_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL3_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL3_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL3_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL3_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL4_PLL                  "
  &pll_num="12 "
  &pll_type="brammo_pll"
  &mode_reg=&HWIO_MMSS_MMPLL4_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL4_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL4_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL4_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL4_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL5_PLL                  "
  &pll_num="13 "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_MMSS_MMPLL5_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL5_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL5_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL5_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL5_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL8_PLL                  "
  &pll_num="14 "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_MMSS_MMPLL8_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL8_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL8_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL8_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL8_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="MMPLL9_PLL                  "
  &pll_num="15 "
  &pll_type="brammo_pll"
  &mode_reg=&HWIO_MMSS_MMPLL9_PLL_MODE_ADDR
  &l_reg=&HWIO_MMSS_MMPLL9_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_MMSS_MMPLL9_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_MMSS_MMPLL9_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL9_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="SCC_PEEL_PLL                "
  &pll_num="16 "
  &pll_type="peel_pll"
  &mode_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_MODE_ADDR
  &l_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_STATUS_ADDR
  &clk_ref=0.032768


  &user_ctl_u_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  &pll_name="QDSP6SS_PLL                 "
  &pll_num="17 "
  &pll_type="spark_pll"
  &mode_reg=&HWIO_SSC_QDSP6SS_PLL_MODE_ADDR
  &l_reg=&HWIO_SSC_QDSP6SS_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_reg=&HWIO_SSC_QDSP6SS_PLL_USER_CTL_ADDR
  &status_reg=&HWIO_SSC_QDSP6SS_PLL_STATUS_ADDR
  &clk_ref=19.2


  &alpha_reg=&HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_SSC_QDSP6SS_PLL_USER_CTL_U_ADDR
  gosub Display_PLL "&pll_name" "&pll_num" &pll_type &mode_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg &user_ctl_reg &status_reg &clk_ref


  print " "
  print " "

  return


;-----------------------------------------------------------------------------
; Display the dump of mode/status registers.
;-----------------------------------------------------------------------------

Display_Dump:

  local &mode_reg
  local &user_ctl_reg
  local &user_ctl_u_reg
  local &config_ctl_reg
  local &test_ctl_reg
  local &test_ctl_u_reg
  local &status_reg

  ; Display the PLL mode, status, user, and test registers.


  &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL0_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL0_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL0_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL0_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL0_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_GPLL0_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   0. GPLL0                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL1_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL1_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL1_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL1_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_GPLL1_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL1_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL1_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_GPLL1_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   1. GPLL1                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL2_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL2_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL2_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL2_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL2_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_GPLL2_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   2. GPLL2                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_GCC_GPLL3_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL3_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL3_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL3_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL3_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL3_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_GPLL3_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL3_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL3_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_GPLL3_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   3. GPLL3                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_GCC_GPLL4_MODE_ADDR
  &status_reg=&HWIO_GCC_GPLL4_STATUS_ADDR
  &user_ctl_reg=&HWIO_GCC_GPLL4_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_GCC_GPLL4_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_GCC_GPLL4_TEST_CTL_ADDR
  &l_reg=&HWIO_GCC_GPLL4_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_GCC_GPLL4_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_GCC_GPLL4_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_GCC_GPLL4_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_GCC_GPLL4_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   4. GPLL4                        &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_LPASS_LPAAUDIO_PLL_MODE_ADDR
  &status_reg=&HWIO_LPASS_LPAAUDIO_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_LPASS_LPAAUDIO_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_LPASS_LPAAUDIO_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_LPASS_LPAAUDIO_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   5. LPASS_LPAAUDIO_PLL           &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_MODE_ADDR
  &status_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   6. LPASS_LPAAUDIO_DIG_PLL       &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_LPASS_QDSP6SS_PLL_MODE_ADDR
  &status_reg=&HWIO_LPASS_QDSP6SS_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_LPASS_QDSP6SS_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_LPASS_QDSP6SS_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_LPASS_QDSP6SS_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_LPASS_QDSP6SS_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_LPASS_QDSP6SS_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_LPASS_QDSP6SS_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   7. LPASS_QDSP6SS_PLL            &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL0_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL0_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL0_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL0_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL0_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL0_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL0_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL0_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   8. MMPLL0_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL1_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL1_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL1_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL1_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL1_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL1_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL1_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL1_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers   9. MMPLL1_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL2_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL2_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL2_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL2_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL2_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL2_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL2_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL2_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  10. MMPLL2_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL3_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL3_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL3_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL3_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL3_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL3_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL3_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL3_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  11. MMPLL3_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL4_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL4_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL4_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL4_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL4_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL4_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL4_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL4_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  12. MMPLL4_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL5_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL5_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL5_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL5_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL5_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL5_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL5_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL5_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  13. MMPLL5_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL8_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL8_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL8_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL8_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL8_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL8_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL8_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL8_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  14. MMPLL8_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_MMSS_MMPLL9_PLL_MODE_ADDR
  &status_reg=&HWIO_MMSS_MMPLL9_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_MMSS_MMPLL9_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_MMSS_MMPLL9_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_MMSS_MMPLL9_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_MMSS_MMPLL9_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_MMSS_MMPLL9_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_MMSS_MMPLL9_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  15. MMPLL9_PLL                   &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_MODE_ADDR
  &status_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &user_ctl_u_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  16. SCC_PEEL_PLL                 &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  &mode_reg=&HWIO_SSC_QDSP6SS_PLL_MODE_ADDR
  &status_reg=&HWIO_SSC_QDSP6SS_PLL_STATUS_ADDR
  &user_ctl_reg=&HWIO_SSC_QDSP6SS_PLL_USER_CTL_ADDR
  &config_ctl_reg=&HWIO_SSC_QDSP6SS_PLL_CONFIG_CTL_ADDR
  &test_ctl_reg=&HWIO_SSC_QDSP6SS_PLL_TEST_CTL_ADDR
  &l_reg=&HWIO_SSC_QDSP6SS_PLL_L_VAL_ADDR
  &alpha_reg=0
  &alpha_u_reg=0
  &m_reg=0
  &n_reg=0
  &user_ctl_u_reg=0
  &test_ctl_u_reg=0
  &alpha_reg=&HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_ADDR
  &alpha_u_reg=&HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_U_ADDR
  &user_ctl_u_reg=&HWIO_SSC_QDSP6SS_PLL_USER_CTL_U_ADDR
  &test_ctl_u_reg=&HWIO_SSC_QDSP6SS_PLL_TEST_CTL_U_ADDR
  gosub Format_Dump_Registers  17. QDSP6SS_PLL                  &mode_reg &user_ctl_reg &user_ctl_u_reg &config_ctl_reg &test_ctl_reg &test_ctl_u_reg &status_reg &l_reg &alpha_reg &alpha_u_reg &m_reg &n_reg

  print "" 
  print "" 
    
  return


;-----------------------------------------------------------------------
; Get votes for MMSS's
;-----------------------------------------------------------------------

Get_PLL_Vote_MMSS:

  ENTRY &vote_reg

  &temp_reg=data.long(&access_mode:&vote_reg)

  if (&temp_reg&0x2)==0x2
    &pll9="Y"
  else
    &pll9=" "

  if (&temp_reg&0x1)==0x1
    &pll8="Y"
  else
    &pll8=" "

  return


;-----------------------------------------------------------------------
; Get votes for GCC's
;-----------------------------------------------------------------------

Get_PLL_Vote_GCC:

  ENTRY &vote_reg

  &temp_reg=data.long(&access_mode:&vote_reg)

  if (&temp_reg&0x10)==0x10
    &pll4="Y"
  else
    &pll4=" "

  if (&temp_reg&0x8)==0x8
    &pll3="Y"
  else
    &pll3=" "

  if (&temp_reg&0x4)==0x4
    &pll2="Y"
  else
    &pll2=" "

  if (&temp_reg&0x2)==0x2
    &pll1="Y"
  else
    &pll1=" "

  if (&temp_reg&0x1)==0x1
    &pll0="Y"
  else
    &pll0=" "

  return


;-----------------------------------------------------------------------
; Get votes for LPASS's
;-----------------------------------------------------------------------

Get_PLL_Vote_LPASS:

  ENTRY &vote_reg

  &temp_reg=data.long(&access_mode:&vote_reg)

  if (&temp_reg&0x4)==0x4
    &pll7="Y"
  else
    &pll7=" "

  if (&temp_reg&0x2)==0x2
    &pll6="Y"
  else
    &pll6=" "

  if (&temp_reg&0x1)==0x1
    &pll5="Y"
  else
    &pll5=" "

  return


;-----------------------------------------------------------------------
; Display PLL vote headline
;-----------------------------------------------------------------------

Display_PLL_Vote:
  
  print "&image |  &pll0  |  &pll1  |  &pll2  |  &pll3  |  &pll4  |  &pll5  |  &pll6  |  &pll7  |  &pll8  |  &pll9  |   "

  return


;-----------------------------------------------------------------------
; Reset PLL votes
;-----------------------------------------------------------------------

Reset_PLL_Votes:

  &pll0=" "
  &pll1=" "
  &pll2=" "
  &pll3=" "
  &pll4=" "
  &pll5=" "
  &pll6=" "
  &pll7=" "
  &pll8=" "
  &pll9=" "


  return


;-----------------------------------------------------------------------
; Display PLL voting table
;-----------------------------------------------------------------------

Display_Votes:

  local &vote_reg

  print " _____________       _____ _____ _____ _____ _____ _____ _____ _____ _____ _____    "
  print "|\            \    |\     \     \     \     \     \     \     \     \     \     \   "
  print "| \            \   | \  0  \  1  \  2  \  3  \  4  \  5  \  6  \  7  \  8  \  9  \  "
  print "|  \____________\__|  \_____\_____\_____\_____\_____\_____\_____\_____\_____\_____\ "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display SPARE1 votes
  gosub Reset_PLL_Votes
  &image="|\ |  SPARE1    |  |\"

  ; Get SPARE1 votes on GCC's
  &vote_reg=&HWIO_GCC_SPARE1_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display SPARE2 votes
  gosub Reset_PLL_Votes
  &image="|\ |  SPARE2    |  |\"

  ; Get SPARE2 votes on GCC's
  &vote_reg=&HWIO_GCC_SPARE2_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display MSS votes
  gosub Reset_PLL_Votes
  &image="|\ |  MSS       |  |\"

  ; Get MSS votes on GCC's
  &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display HYP votes
  gosub Reset_PLL_Votes
  &image="|\ |  HYP       |  |\"

  ; Get HYP votes on GCC's
  &vote_reg=&HWIO_GCC_HYP_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display SPARE votes
  gosub Reset_PLL_Votes
  &image="|\ |  SPARE     |  |\"

  ; Get SPARE votes on GCC's
  &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display LPASS_HW votes
  gosub Reset_PLL_Votes
  &image="|\ |  LPASS_HW  |  |\"

  ; Get LPASS_HW votes on LPASS's
  &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASS_HW_ADDR
  gosub Get_PLL_Vote_LPASS &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display APCS_TZ votes
  gosub Reset_PLL_Votes
  &image="|\ |  APCS_TZ   |  |\"

  ; Get APCS_TZ votes on GCC's
  &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display APCS votes
  gosub Reset_PLL_Votes
  &image="|\ |  APCS      |  |\"

  ; Get APCS votes on GCC's
  &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  ; Get APCS votes on LPASS's
  &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_APPS_ADDR
  gosub Get_PLL_Vote_LPASS &vote_reg

  ; Get APCS votes on MMSS's
  &vote_reg=&HWIO_MMSS_MMSS_PLL_VOTE_APCS_ADDR
  gosub Get_PLL_Vote_MMSS &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display LPASS votes
  gosub Reset_PLL_Votes
  &image="|\ |  LPASS     |  |\"

  ; Get LPASS votes on GCC's
  &vote_reg=&HWIO_GCC_LPASS_DSP_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  ; Get LPASS votes on LPASS's
  &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASSQ6_ADDR
  gosub Get_PLL_Vote_LPASS &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display RPM votes
  gosub Reset_PLL_Votes
  &image="|\ |  RPM       |  |\"

  ; Get RPM votes on GCC's
  &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  ; Get RPM votes on MMSS's
  &vote_reg=&HWIO_MMSS_MMSS_PLL_VOTE_RPM_ADDR
  gosub Get_PLL_Vote_MMSS &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  ; Display SSC votes
  gosub Reset_PLL_Votes
  &image="|\ |  SSC       |  |\"

  ; Get SSC votes on GCC's
  &vote_reg=&HWIO_GCC_SSC_GPLL_ENA_VOTE_ADDR
  gosub Get_PLL_Vote_GCC &vote_reg

  gosub Display_PLL_Vote

  print "| \|____________|__| \|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____| "
  print "|  |            |  |  |     |     |     |     |     |     |     |     |     |     | "


  print "" 
  print "" 
    
  return


;-----------------------------------------------------------------------
; Configure a PLL - Wrapper
;-----------------------------------------------------------------------

Configure_PLL_Enter:

  &pll_name_choice=""
  gosub Configure_PLL

  return


;-----------------------------------------------------------------------
; Configure SR / SR2 / HF / Prius / Tesla PLLs.
; Note:
;-----------------------------------------------------------------------
          
Generic_PLL_Configure:

  ENTRY &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

  &HWIO_PLL_VOTE_FSM_ENA_MASK=0x100000
  &HWIO_PLL_VOTE_FSM_RESET_MASK=0x200000

  &HWIO_PLL_BIAS_COUNT_MASK=0xfc000
  &HWIO_PLL_LOCK_COUNT_MASK=0x3f00

  &HWIO_PLL_BIAS_COUNT_VAL=(0x1<<0xe)
  &HWIO_PLL_LOCK_COUNT_VAL=0x0

  &HWIO_PLL_ALPHA_EN_MASK=0x1000000
  &HWIO_PLL_VCO_SEL_MASK=0x300000
  &HWIO_PLL_PRE_DIV_RATIO_MASK=0x7000
  &HWIO_PLL_POST_DIV_RATIO_MASK=0xf00

  &HWIO_PLL_VOTE_FSM_ENA_SHIFT=0x14
  &HWIO_PLL_ALPHA_EN_SHIFT=0x18
  &HWIO_PLL_VCO_SEL_SHIFT=0x14
  &HWIO_PLL_PRE_DIV_RATIO_SHIFT=0xc
  &HWIO_PLL_POST_DIV_RATIO_SHIFT=0x8

  local &mode_val
  local &user_val
  local &is_fsm_mode_enabled

  &is_fsm_mode_enabled=0x0
  ;data.set &access_mode:&mode_reg %long 0x0

  &mode_val=data.long(&access_mode:&mode_reg)

  if (&is_votable==0x1)
  (
    ; Disable FSM mode
    if (&mode_val&(&HWIO_PLL_VOTE_FSM_ENA_MASK))==&HWIO_PLL_VOTE_FSM_ENA_MASK
    (
      &is_fsm_mode_enabled=0x1
      &mode_val=&mode_val&~(&HWIO_PLL_VOTE_FSM_ENA_MASK)
      data.set &access_mode:&mode_reg %long &mode_val
    )
  )

  ; Set L
  data.set &access_mode:&l_reg %long &l_val

  ; Set ALPHA if register is non-zero
  if (&alpha_reg!=0)
  (
    data.set &access_mode:&alpha_reg %long &alpha_val
  )

  ; Set ALPHA_U if register is non-zero
  if (&alpha_u_reg!=0)
  (
    data.set &access_mode:&alpha_u_reg %long &alpha_u_val
  )

  ; Set M if register is non-zero
  if (&m_reg!=0)
  (
    data.set &access_mode:&m_reg %long &m_val
  )

  ; Set N if register is non-zero
  if (&n_reg!=0)
  (
    data.set &access_mode:&n_reg %long &n_val
  )

  ; Clear fields in user control register
  &user_val=data.long(&access_mode:&user_reg)
  &user_val=&user_val&~((&HWIO_PLL_ALPHA_EN_MASK)|(&HWIO_PLL_VCO_SEL_MASK)|(&HWIO_PLL_PRE_DIV_RATIO_MASK)|(&HWIO_PLL_POST_DIV_RATIO_MASK))

  ; Set fields in user control register
  &user_val=&user_val|(0x2<<&HWIO_PLL_VCO_SEL_SHIFT)
  &user_val=&user_val|((&prediv-1)<<&HWIO_PLL_PRE_DIV_RATIO_SHIFT)
  &user_val=&user_val|((&postdiv-1)<<&HWIO_PLL_POST_DIV_RATIO_SHIFT)

  if (&alpha_val!=0)||(&alpha_u_val!=0)
  (
    &user_val=&user_val|(&HWIO_PLL_ALPHA_EN_MASK)
  )

  ; Program the user control register
  data.set &access_mode:&user_reg %long &user_val


  if (&is_votable==0x1)
  (
    ; Put the FSM in reset
    &mode_val=&mode_val|(&HWIO_PLL_VOTE_FSM_RESET_MASK)
    data.set &access_mode:&mode_reg %long &mode_val

    ; Set the lock and bias
    &mode_val=&mode_val&~((&HWIO_PLL_BIAS_COUNT_MASK)|(&HWIO_PLL_LOCK_COUNT_MASK))
    &mode_val=&mode_val|(&HWIO_PLL_BIAS_COUNT_VAL)
    &mode_val=&mode_val|(&HWIO_PLL_LOCK_COUNT_VAL)

    ; Enable the FSM
    &mode_val=&mode_val|(&HWIO_PLL_VOTE_FSM_ENA_MASK)

    ; Program the mode register
    data.set &access_mode:&mode_reg %long &mode_val

    ; Take the FSM out of reset
    &mode_val=&mode_val&~(&HWIO_PLL_VOTE_FSM_RESET_MASK)
    data.set &access_mode:&mode_reg %long &mode_val
  )

  return


;-----------------------------------------------------------------------
; Configure a PLL
;-----------------------------------------------------------------------

Configure_PLL:

  local &pll_name_choice

  ; Prompt user to choose PLL if choice not passed in via commandline
  if ("&pll_name_choice"=="")
  (
    print "Available PLLs are: "

  print "  GPLL0                       GPLL1                       GPLL2                       GPLL3                       "

  print "  GPLL4                       LPASS_LPAAUDIO_PLL          LPASS_LPAAUDIO_DIG_PLL      LPASS_QDSP6SS_PLL           "

  print "  MMPLL0_PLL                  MMPLL1_PLL                  MMPLL2_PLL                  MMPLL3_PLL                  "

  print "  MMPLL4_PLL                  MMPLL5_PLL                  MMPLL8_PLL                  MMPLL9_PLL                  "

  print "  SCC_PEEL_PLL                QDSP6SS_PLL                 "

    print ""
    print "Enter PLL: "
    enter &pll_name_choice
  )

  if ("&pll_name_choice"=="GPLL0")
  (
    &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL0_L_VAL_ADDR
    &l_val=0x001F

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_GCC_GPLL0_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x40
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL0 "
    print ""

    return
  )

  if ("&pll_name_choice"=="GPLL1")
  (
    &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL1_L_VAL_ADDR
    &l_val=0x001B

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_GCC_GPLL1_ALPHA_VAL_ADDR
    &alpha_val=0xAAAAAAAA
  &alpha_u_reg=&HWIO_GCC_GPLL1_ALPHA_VAL_U_ADDR
    &alpha_u_val=0xC2
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL1 "
    print ""

    return
  )

  if ("&pll_name_choice"=="GPLL2")
  (
    &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL2_L_VAL_ADDR
    &l_val=0x001B

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_ADDR
    &alpha_val=0xAAAAAAAA
  &alpha_u_reg=&HWIO_GCC_GPLL2_ALPHA_VAL_U_ADDR
    &alpha_u_val=0xC2
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL2 "
    print ""

    return
  )

  if ("&pll_name_choice"=="GPLL3")
  (
    &mode_reg=&HWIO_GCC_GPLL3_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL3_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL3_L_VAL_ADDR
    &l_val=0x0030

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_GCC_GPLL3_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_GCC_GPLL3_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x98
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL3 "
    print ""

    return
  )

  if ("&pll_name_choice"=="GPLL4")
  (
    &mode_reg=&HWIO_GCC_GPLL4_MODE_ADDR
    &user_reg=&HWIO_GCC_GPLL4_USER_CTL_ADDR

    &l_reg=&HWIO_GCC_GPLL4_L_VAL_ADDR
    &l_val=0x0050

    &prediv=0x0001
    &postdiv=0x0004

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_GCC_GPLL4_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_GCC_GPLL4_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured GPLL4 "
    print ""

    return
  )

  if ("&pll_name_choice"=="LPASS_LPAAUDIO_PLL")
  (
    &mode_reg=&HWIO_LPASS_LPAAUDIO_PLL_MODE_ADDR
    &user_reg=&HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_LPASS_LPAAUDIO_PLL_L_VAL_ADDR
    &l_val=0x0020

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="brammo_pll"

  &alpha_reg=&HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_LPASS_LPAAUDIO_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured LPASS_LPAAUDIO_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="LPASS_LPAAUDIO_DIG_PLL")
  (
    &mode_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_MODE_ADDR
    &user_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_L_VAL_ADDR
    &l_val=0x0020

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured LPASS_LPAAUDIO_DIG_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="LPASS_QDSP6SS_PLL")
  (
    &mode_reg=&HWIO_LPASS_QDSP6SS_PLL_MODE_ADDR
    &user_reg=&HWIO_LPASS_QDSP6SS_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_LPASS_QDSP6SS_PLL_L_VAL_ADDR
    &l_val=0x0012

    &prediv=0x0001
    &postdiv=0x0004

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_LPASS_QDSP6SS_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured LPASS_QDSP6SS_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL0_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL0_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL0_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL0_PLL_L_VAL_ADDR
    &l_val=0x0029

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_ADDR
    &alpha_val=0xAAAAAAAA
  &alpha_u_reg=&HWIO_MMSS_MMPLL0_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0xAA
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL0_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL1_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL1_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL1_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL1_PLL_L_VAL_ADDR
    &l_val=0x0026

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x1
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_ADDR
    &alpha_val=0xAAAAAAAA
  &alpha_u_reg=&HWIO_MMSS_MMPLL1_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x8A
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL1_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL2_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL2_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL2_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL2_PLL_L_VAL_ADDR
    &l_val=0x001A

    &prediv=0x0001
    &postdiv=0x0004

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_ADDR
    &alpha_val=0xAAAAAAAA
  &alpha_u_reg=&HWIO_MMSS_MMPLL2_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x0A
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL2_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL3_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL3_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL3_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL3_PLL_L_VAL_ADDR
    &l_val=0x002E

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_MMSS_MMPLL3_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0xE0
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL3_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL4_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL4_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL4_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL4_PLL_L_VAL_ADDR
    &l_val=0x0032

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="brammo_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_MMSS_MMPLL4_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL4_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL5_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL5_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL5_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL5_PLL_L_VAL_ADDR
    &l_val=0x0025

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_MMSS_MMPLL5_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x80
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL5_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL8_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL8_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL8_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL8_PLL_L_VAL_ADDR
    &l_val=0x001A

    &prediv=0x0001
    &postdiv=0x0004

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_ADDR
    &alpha_val=0xAAAAAAAA
  &alpha_u_reg=&HWIO_MMSS_MMPLL8_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x0A
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL8_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL9_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL9_PLL_MODE_ADDR
    &user_reg=&HWIO_MMSS_MMPLL9_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_MMSS_MMPLL9_PLL_L_VAL_ADDR
    &l_val=0x0032

    &prediv=0x0001
    &postdiv=0x0002

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="brammo_pll"

  &alpha_reg=&HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x00000000
  &alpha_u_reg=&HWIO_MMSS_MMPLL9_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x00
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured MMPLL9_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="SCC_PEEL_PLL")
  (
    &mode_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_MODE_ADDR
    &user_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_L_VAL_ADDR
    &l_val=0x1BA8

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="peel_pll"

    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured SCC_PEEL_PLL "
    print ""

    return
  )

  if ("&pll_name_choice"=="QDSP6SS_PLL")
  (
    &mode_reg=&HWIO_SSC_QDSP6SS_PLL_MODE_ADDR
    &user_reg=&HWIO_SSC_QDSP6SS_PLL_USER_CTL_ADDR

    &l_reg=&HWIO_SSC_QDSP6SS_PLL_L_VAL_ADDR
    &l_val=0x0024

    &prediv=0x0001
    &postdiv=0x0001

    &alpha_reg=0
    &alpha_val=0x0

    &alpha_u_reg=0
    &alpha_u_val=0x0

    &m_reg=0
    &m_val=0x0

    &n_reg=0
    &n_val=0x0

    &is_votable=0x0
    &pll_type="spark_pll"

  &alpha_reg=&HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_ADDR
    &alpha_val=0x55555555
  &alpha_u_reg=&HWIO_SSC_QDSP6SS_PLL_ALPHA_VAL_U_ADDR
    &alpha_u_val=0x75
    gosub Generic_PLL_Configure &mode_reg &user_reg &prediv &postdiv &l_reg &l_val &alpha_reg &alpha_val &alpha_u_reg &alpha_u_val &m_reg &m_val &n_reg &n_val &is_votable &pll_type

    print "Configured QDSP6SS_PLL "
    print ""

    return
  )

  ; PLL name did not match
  return


;-----------------------------------------------------------------------
; Enable or Disable a PLL - Wrapper
;-----------------------------------------------------------------------

Enable_Disable_PLL_Enter:

  &pll_name_choice=""
  gosub Enable_Disable_PLL

  return


;-----------------------------------------------------------------------
; Enable SR / SR2 / HF / Prius / Tesla PLLs.
; Note: This function turns on the PLLs from OFF state. It does not
; support the 'saved state' feature found on Prius PLLs.
;-----------------------------------------------------------------------
          
Generic_PLL_Enable:

  ENTRY &mode_reg &status_reg

  ; Return if PLL is already locked
  if (data.long(&access_mode:&status_reg)&0x10000)==0x10000
  (
    return
  )

  ; Put the PLL in reset
  &mode_val=data.long(&access_mode:&mode_reg)
  &mode_val=&mode_val&~(0x00000001|0x00000002|0x00000004)
  data.set &access_mode:&mode_reg %long &mode_val

  if ("&pll_type"=="sr_pll")
  (
    ; Deassert reset and bypass
    &mode_val=&mode_val|0x00000004|0x00000002
    data.set &access_mode:&mode_reg %long &mode_val
  )
  else if ("&pll_type"=="sr2_pll")||("&pll_type"=="hf_pll")||("&pll_type"=="prius_pll")||("&pll_type"=="tesla_pll")
  (
    ; Deassert bypass
    &mode_val=&mode_val|0x00000002
    data.set &access_mode:&mode_reg %long &mode_val

    ; Wait for PLL to initialize
    ; The actual PLL Init time is 5us, but T32 does not seem to allow this small value
    wait 1.ms
    
    ; Deassert reset
    &mode_val=&mode_val|0x00000004
    data.set &access_mode:&mode_reg %long &mode_val
  )
  
  ; Wait for PLL to warm up
  ; The actual PLL warm-up time is 50us, but T32 does not seem to allow this small value
  wait 1.ms
  
  ; Wait for PLL to lock
  while (data.long(&access_mode:&mode_reg)&0x80000000)==0x0
  (
  )
  
  ; Assert outctrl
  &mode_val=&mode_val|0x00000001
  data.set &access_mode:&mode_reg %long &mode_val

  return


;-----------------------------------------------------------------------
; Disable PLL
;-----------------------------------------------------------------------
                
Generic_PLL_Disable:

  ENTRY &mode_reg

  ; Put the PLL in reset
  &mode_val=data.long(&access_mode:&mode_reg)
  &mode_val=&mode_val&~(0x00000001|0x00000002|0x00000004)
  data.set &access_mode:&mode_reg %LONG &mode_val
  
  return


;-----------------------------------------------------------------------
; Enable or Disable a PLL
;-----------------------------------------------------------------------

Enable_Disable_PLL:

  local &pll_name_choice
  local &pll_on_off_choice

  print "Warning: PLL must already be configured, or the script will hang while waiting for the PLL to lock."
  print ""

  ; Prompt user to choose PLL if choice not passed in via commandline
  if ("&pll_name_choice"=="")
  (
    print "Available PLLs are: "

  print "  GPLL0                       GPLL1                       GPLL2                       GPLL3                       "

  print "  GPLL4                       LPASS_LPAAUDIO_PLL          LPASS_LPAAUDIO_DIG_PLL      LPASS_QDSP6SS_PLL           "

  print "  MMPLL0_PLL                  MMPLL1_PLL                  MMPLL2_PLL                  MMPLL3_PLL                  "

  print "  MMPLL4_PLL                  MMPLL5_PLL                  MMPLL8_PLL                  MMPLL9_PLL                  "

  print "  SCC_PEEL_PLL                QDSP6SS_PLL                 "

    print ""
    print "Enter PLL: "
    enter &pll_name_choice
    
    print "Enter on/off: "
    enter &pll_on_off_choice
  )

  print "PLL: " "&pll_name_choice" "."

  
  ; Votable PLLs

  if ("&pll_name_choice"=="GPLL0")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL0_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL0_STATUS_ADDR
    &pll_sel=0x1

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_TZ  LPASS  RPM  SPARE  SSC  HYP  MSS  SPARE1  SPARE2  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_GCC_LPASS_DSP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SSC")
      (
        &vote_reg=&HWIO_GCC_SSC_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="HYP")
      (
        &vote_reg=&HWIO_GCC_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE1")
      (
        &vote_reg=&HWIO_GCC_SPARE1_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE2")
      (
        &vote_reg=&HWIO_GCC_SPARE2_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL0 " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="GPLL1")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL1_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL1_STATUS_ADDR
    &pll_sel=0x2

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_TZ  LPASS  RPM  SPARE  SSC  HYP  MSS  SPARE1  SPARE2  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_GCC_LPASS_DSP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SSC")
      (
        &vote_reg=&HWIO_GCC_SSC_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="HYP")
      (
        &vote_reg=&HWIO_GCC_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE1")
      (
        &vote_reg=&HWIO_GCC_SPARE1_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE2")
      (
        &vote_reg=&HWIO_GCC_SPARE2_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL1 " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="GPLL2")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL2_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL2_STATUS_ADDR
    &pll_sel=0x4

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_TZ  LPASS  RPM  SPARE  SSC  HYP  MSS  SPARE1  SPARE2  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_GCC_LPASS_DSP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SSC")
      (
        &vote_reg=&HWIO_GCC_SSC_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="HYP")
      (
        &vote_reg=&HWIO_GCC_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE1")
      (
        &vote_reg=&HWIO_GCC_SPARE1_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE2")
      (
        &vote_reg=&HWIO_GCC_SPARE2_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL2 " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="GPLL3")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL3_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL3_STATUS_ADDR
    &pll_sel=0x8

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_TZ  LPASS  RPM  SPARE  SSC  HYP  MSS  SPARE1  SPARE2  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_GCC_LPASS_DSP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SSC")
      (
        &vote_reg=&HWIO_GCC_SSC_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="HYP")
      (
        &vote_reg=&HWIO_GCC_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE1")
      (
        &vote_reg=&HWIO_GCC_SPARE1_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE2")
      (
        &vote_reg=&HWIO_GCC_SPARE2_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL3 " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="GPLL4")
  (
    &vote_reg=0
    &mode_reg=&HWIO_GCC_GPLL4_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_GCC_GPLL4_STATUS_ADDR
    &pll_sel=0x10

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  APCS_TZ  LPASS  RPM  SPARE  SSC  HYP  MSS  SPARE1  SPARE2  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_GCC_APCS_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="APCS_TZ")
      (
        &vote_reg=&HWIO_GCC_APCS_TZ_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_GCC_LPASS_DSP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_GCC_RPM_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE")
      (
        &vote_reg=&HWIO_GCC_SPARE_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SSC")
      (
        &vote_reg=&HWIO_GCC_SSC_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="HYP")
      (
        &vote_reg=&HWIO_GCC_HYP_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="MSS")
      (
        &vote_reg=&HWIO_GCC_MSS_Q6_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE1")
      (
        &vote_reg=&HWIO_GCC_SPARE1_GPLL_ENA_VOTE_ADDR
      )
      else if ("&subsystem"=="SPARE2")
      (
        &vote_reg=&HWIO_GCC_SPARE2_GPLL_ENA_VOTE_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned GPLL4 " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="LPASS_LPAAUDIO_PLL")
  (
    &vote_reg=0
    &mode_reg=&HWIO_LPASS_LPAAUDIO_PLL_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_LPASS_LPAAUDIO_PLL_STATUS_ADDR
    &pll_sel=0x1

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  LPASS  LPASS_HW  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_APPS_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASSQ6_ADDR
      )
      else if ("&subsystem"=="LPASS_HW")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASS_HW_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned LPASS_LPAAUDIO_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="LPASS_LPAAUDIO_DIG_PLL")
  (
    &vote_reg=0
    &mode_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_STATUS_ADDR
    &pll_sel=0x2

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  LPASS  LPASS_HW  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_APPS_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASSQ6_ADDR
      )
      else if ("&subsystem"=="LPASS_HW")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASS_HW_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned LPASS_LPAAUDIO_DIG_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="LPASS_QDSP6SS_PLL")
  (
    &vote_reg=0
    &mode_reg=&HWIO_LPASS_QDSP6SS_PLL_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_LPASS_QDSP6SS_PLL_STATUS_ADDR
    &pll_sel=0x4

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  LPASS  LPASS_HW  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_APPS_ADDR
      )
      else if ("&subsystem"=="LPASS")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASSQ6_ADDR
      )
      else if ("&subsystem"=="LPASS_HW")
      (
        &vote_reg=&HWIO_LPASS_LPA_PLL_VOTE_LPASS_HW_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned LPASS_QDSP6SS_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="MMPLL0_PLL")
  (
    &vote_reg=0
    &mode_reg=&HWIO_MMSS_MMPLL0_PLL_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_MMSS_MMPLL0_PLL_STATUS_ADDR
    &pll_sel=0x1

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  RPM  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_MMSS_MMSS_PLL_VOTE_APCS_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_MMSS_MMSS_PLL_VOTE_RPM_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned MMPLL0_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )


  if ("&pll_name_choice"=="MMPLL1_PLL")
  (
    &vote_reg=0
    &mode_reg=&HWIO_MMSS_MMPLL1_PLL_MODE_ADDR
    &mode_val=data.long(&access_mode:&mode_reg)
    &status_reg=&HWIO_MMSS_MMPLL1_PLL_STATUS_ADDR
    &pll_sel=0x2

    ; this votable PLL is in FSM mode
    if (&mode_val&0x100000)==0x100000
    (
      print "This source is votable. Which processor do you want to vote from? Choices are: "
      print "[  APCS  RPM  ]"

      print ""
      print "Enter your choice: "
      enter &subsystem

      if ("&subsystem"=="APCS")
      (
        &vote_reg=&HWIO_MMSS_MMSS_PLL_VOTE_APCS_ADDR
      )
      else if ("&subsystem"=="RPM")
      (
        &vote_reg=&HWIO_MMSS_MMSS_PLL_VOTE_RPM_ADDR
      )
      else
      (
        print "Invalid selection."
        print ""
        goto Enable_Disable_PLL
      )

      if ("&pll_on_off_choice"=="on")
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)|(&pll_sel))
      )
      else
      (
        data.set &access_mode:&vote_reg %long (data.long(&access_mode:&vote_reg)&~(&pll_sel))
      )

    )
    ; this PLL supports HW voting, but is currently in legacy mode
    else
    (
      if ("&pll_on_off_choice"=="on")
      (
        gosub Generic_PLL_Enable &mode_reg &status_reg
      )
      else
      (
        gosub Generic_PLL_Disable &mode_reg
      )
    )

    print "Turned MMPLL1_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )


  ; Non Votable PLLs

  if ("&pll_name_choice"=="MMPLL2_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL2_PLL_MODE_ADDR
    &status_reg=&HWIO_MMSS_MMPLL2_PLL_STATUS_ADDR
    &pll_type="spark_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned MMPLL2_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL3_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL3_PLL_MODE_ADDR
    &status_reg=&HWIO_MMSS_MMPLL3_PLL_STATUS_ADDR
    &pll_type="spark_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned MMPLL3_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL4_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL4_PLL_MODE_ADDR
    &status_reg=&HWIO_MMSS_MMPLL4_PLL_STATUS_ADDR
    &pll_type="brammo_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned MMPLL4_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL5_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL5_PLL_MODE_ADDR
    &status_reg=&HWIO_MMSS_MMPLL5_PLL_STATUS_ADDR
    &pll_type="spark_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned MMPLL5_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL8_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL8_PLL_MODE_ADDR
    &status_reg=&HWIO_MMSS_MMPLL8_PLL_STATUS_ADDR
    &pll_type="spark_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned MMPLL8_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="MMPLL9_PLL")
  (
    &mode_reg=&HWIO_MMSS_MMPLL9_PLL_MODE_ADDR
    &status_reg=&HWIO_MMSS_MMPLL9_PLL_STATUS_ADDR
    &pll_type="brammo_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned MMPLL9_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="SCC_PEEL_PLL")
  (
    &mode_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_MODE_ADDR
    &status_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_STATUS_ADDR
    &pll_type="peel_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned SCC_PEEL_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  if ("&pll_name_choice"=="QDSP6SS_PLL")
  (
    &mode_reg=&HWIO_SSC_QDSP6SS_PLL_MODE_ADDR
    &status_reg=&HWIO_SSC_QDSP6SS_PLL_STATUS_ADDR
    &pll_type="spark_pll"


    if ("&pll_on_off_choice"=="on")
    (
      gosub Generic_PLL_Enable &mode_reg &status_reg
    )
    else
    (
      gosub Generic_PLL_Disable &mode_reg
    )

    print "Turned QDSP6SS_PLL " "&pll_on_off_choice" "."
    print ""

    return
  )

  ; PLL name did not match
  return


;-----------------------------------------------------------------------
; Route PLL to PLLTEST_PAD 
;-----------------------------------------------------------------------

Route_PLL_To_Pad:

  local &pll_name_choice
  local &plltest_pad_field_val
  local &user_ctl_reg
  local &test_ctl_u_reg
  local &user_ctl_val
  local &test_ctl_u_val

  ; Prompt user to choose PLL if choice not passed in via commandline
  if ("&pll_name_choice"=="")
  (
    print "Available PLLs are: "

  print "  GPLL0                       GPLL1                       GPLL2                       GPLL3                       "

  print "  GPLL4                       LPASS_LPAAUDIO_PLL          LPASS_LPAAUDIO_DIG_PLL      LPASS_QDSP6SS_PLL           "

  print "  MMPLL0_PLL                  MMPLL1_PLL                  MMPLL2_PLL                  MMPLL3_PLL                  "

  print "  MMPLL4_PLL                  MMPLL5_PLL                  MMPLL8_PLL                  MMPLL9_PLL                  "

  print "  SCC_PEEL_PLL                QDSP6SS_PLL                 "

    print ""
    print "Enter PLL: "
    enter &pll_name_choice
  )

  &plltest_pad_field_val=0x0
  &user_ctl_reg=0x0
  &test_ctl_u_reg=0x0

  if ("&pll_name_choice"=="GPLL0")
  (
    &plltest_pad_field_val=0x1
    &user_ctl_reg=&HWIO_GCC_GPLL0_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_GPLL0_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="GPLL1")
  (
    &plltest_pad_field_val=0x2
    &user_ctl_reg=&HWIO_GCC_GPLL1_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_GPLL1_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="GPLL2")
  (
    &plltest_pad_field_val=0x3
    &user_ctl_reg=&HWIO_GCC_GPLL2_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_GPLL2_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="GPLL3")
  (
    &plltest_pad_field_val=0x4
    &user_ctl_reg=&HWIO_GCC_GPLL3_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_GPLL3_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="GPLL4")
  (
    &plltest_pad_field_val=0x5
    &user_ctl_reg=&HWIO_GCC_GPLL4_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_GCC_GPLL4_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

  )

  if ("&pll_name_choice"=="LPASS_LPAAUDIO_PLL")
  (
    &plltest_pad_field_val=0x6
    &user_ctl_reg=&HWIO_LPASS_LPAAUDIO_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the LPASS pll debug register
    &lpass_pllout_lv_test_sel_reg=0x903d000
    &lpass_pllout_lv_test_sel_val=data.long(&access_mode:&lpass_pllout_lv_test_sel_reg)

    ; Clear the source selection field
    &lpass_pllout_lv_test_sel_val=&lpass_pllout_lv_test_sel_val&~(0x3<<0x0)

    ; Write to the LPASS pll debug register source selection field
    &lpass_pllout_lv_test_sel_val=&lpass_pllout_lv_test_sel_val|((0x0&0x3)<<0x0)
    data.set &access_mode:&lpass_pllout_lv_test_sel_reg %long &lpass_pllout_lv_test_sel_val

  )

  if ("&pll_name_choice"=="LPASS_LPAAUDIO_DIG_PLL")
  (
    &plltest_pad_field_val=0x6
    &user_ctl_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_LPASS_LPAAUDIO_DIG_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the LPASS pll debug register
    &lpass_pllout_lv_test_sel_reg=0x903d000
    &lpass_pllout_lv_test_sel_val=data.long(&access_mode:&lpass_pllout_lv_test_sel_reg)

    ; Clear the source selection field
    &lpass_pllout_lv_test_sel_val=&lpass_pllout_lv_test_sel_val&~(0x3<<0x0)

    ; Write to the LPASS pll debug register source selection field
    &lpass_pllout_lv_test_sel_val=&lpass_pllout_lv_test_sel_val|((0x1&0x3)<<0x0)
    data.set &access_mode:&lpass_pllout_lv_test_sel_reg %long &lpass_pllout_lv_test_sel_val

  )

  if ("&pll_name_choice"=="LPASS_QDSP6SS_PLL")
  (
    &plltest_pad_field_val=0x6
    &user_ctl_reg=&HWIO_LPASS_QDSP6SS_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_LPASS_QDSP6SS_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the LPASS pll debug register
    &lpass_pllout_lv_test_sel_reg=0x903d000
    &lpass_pllout_lv_test_sel_val=data.long(&access_mode:&lpass_pllout_lv_test_sel_reg)

    ; Clear the source selection field
    &lpass_pllout_lv_test_sel_val=&lpass_pllout_lv_test_sel_val&~(0x3<<0x0)

    ; Write to the LPASS pll debug register source selection field
    &lpass_pllout_lv_test_sel_val=&lpass_pllout_lv_test_sel_val|((0x2&0x3)<<0x0)
    data.set &access_mode:&lpass_pllout_lv_test_sel_reg %long &lpass_pllout_lv_test_sel_val

  )

  if ("&pll_name_choice"=="MMPLL0_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL0_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL0_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x0&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="MMPLL1_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL1_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL1_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x1&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="MMPLL2_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL2_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL2_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x2&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="MMPLL3_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL3_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL3_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x3&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="MMPLL4_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL4_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL4_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x4&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="MMPLL5_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL5_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL5_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x5&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="MMPLL8_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL8_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL8_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x6&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="MMPLL9_PLL")
  (
    &plltest_pad_field_val=0x7
    &user_ctl_reg=&HWIO_MMSS_MMPLL9_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_MMSS_MMPLL9_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the MMSS pll debug register
    &mmss_mmss_debug_clk_ctl_reg=0x8c0900
    &mmss_mmss_debug_clk_ctl_val=data.long(&access_mode:&mmss_mmss_debug_clk_ctl_reg)

    ; Clear the source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val&~(0x7<<0x17)

    ; Write to the MMSS pll debug register source selection field
    &mmss_mmss_debug_clk_ctl_val=&mmss_mmss_debug_clk_ctl_val|((0x7&0x7)<<0x17)
    data.set &access_mode:&mmss_mmss_debug_clk_ctl_reg %long &mmss_mmss_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="SCC_PEEL_PLL")
  (
    &plltest_pad_field_val=0x9
    &user_ctl_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_SSC_SCC_SCC_PEEL_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the SSC pll debug register
    &ssc_scc_scc_debug_clk_ctl_reg=0x1e20034
    &ssc_scc_scc_debug_clk_ctl_val=data.long(&access_mode:&ssc_scc_scc_debug_clk_ctl_reg)

    ; Clear the source selection field
    &ssc_scc_scc_debug_clk_ctl_val=&ssc_scc_scc_debug_clk_ctl_val&~(0x3<<0xA)

    ; Write to the SSC pll debug register source selection field
    &ssc_scc_scc_debug_clk_ctl_val=&ssc_scc_scc_debug_clk_ctl_val|((0x0&0x3)<<0xA)
    data.set &access_mode:&ssc_scc_scc_debug_clk_ctl_reg %long &ssc_scc_scc_debug_clk_ctl_val

  )

  if ("&pll_name_choice"=="QDSP6SS_PLL")
  (
    &plltest_pad_field_val=0x9
    &user_ctl_reg=&HWIO_SSC_QDSP6SS_PLL_USER_CTL_ADDR

  &test_ctl_u_reg=&HWIO_SSC_QDSP6SS_PLL_TEST_CTL_U_ADDR
    ; Enable test output in the PLL's user control register
    &user_ctl_val=data.long(&access_mode:&user_ctl_reg)
    &user_ctl_val=&user_ctl_val|0x10
    data.set &access_mode:&user_ctl_reg %long &user_ctl_val

    ; Enable test output in the PLL's test control upper register if available
    if (&test_ctl_u_reg!=0x0)
    (
      &test_ctl_u_val=data.long(&access_mode:&test_ctl_u_reg)
      &test_ctl_u_val=&test_ctl_u_val|0x6
      data.set &access_mode:&test_ctl_u_reg %long &test_ctl_u_val
    )

    ; Get the SSC pll debug register
    &ssc_scc_scc_debug_clk_ctl_reg=0x1e20034
    &ssc_scc_scc_debug_clk_ctl_val=data.long(&access_mode:&ssc_scc_scc_debug_clk_ctl_reg)

    ; Clear the source selection field
    &ssc_scc_scc_debug_clk_ctl_val=&ssc_scc_scc_debug_clk_ctl_val&~(0x3<<0xA)

    ; Write to the SSC pll debug register source selection field
    &ssc_scc_scc_debug_clk_ctl_val=&ssc_scc_scc_debug_clk_ctl_val|((0x1&0x3)<<0xA)
    data.set &access_mode:&ssc_scc_scc_debug_clk_ctl_reg %long &ssc_scc_scc_debug_clk_ctl_val

  )

  if (&user_ctl_reg!=0x0)&&(&plltest_pad_field_val!=0x0)
  (
    ; Get the PLLTEST_PAD register
    &plltest_pad_reg=0x36200c
    &plltest_pad_val=data.long(&access_mode:&plltest_pad_reg)

    ; Clear the source selection field
    &plltest_pad_val=&plltest_pad_val&~(0x1F<<0x0)

    ; Set CORE_OE
    &plltest_pad_val=&plltest_pad_val|0x1000

    ; Write to the testpad's source selection field
    &plltest_pad_val=&plltest_pad_val|((&plltest_pad_field_val&0x1F)<<0x0)
    data.set &access_mode:&plltest_pad_reg %long &plltest_pad_val
  )
  else
  (
    print "Invalid source."
  )

  return



;=============================================================================
;
; Generic utility sub-routines:
;
;   bool    try_area_create ( string area, [int cols, int rows] )
;
;   bool    area_create_list (
;             int num, [string area, int cols, int rows], ... )
;
;   string  get_substr_ws ( string src_str, int read_idx, [flag get_idx] )
;
;   int[4]  extract_stored_win_dim ( string file_name, string window_name )
;
;   bool    save_window_settings ( string window_name, [flag print_error] )
;
;   int[4]  find_saved_window_settings ( string window_name )
;
;   bool    delete_saved_window_settings (
;             string window_name, [flag print_error] )
;
;=============================================================================

;
; bool try_area_create ( string area, [int cols, int rows] )
;
; Attempts to create an area (see 'area.create'). Returns non-zero if the 
; area is successfully created. If the 'area.create' operation fails, the
; caller may run 'area.reset' then re-try creating the area. The 'rows' and
; 'cols' arguments can be bypassed by omitting both.
;
; T32 has a maximum number of concurrent areas (only 10 at the time of
; writing this sub). Unfortunately these areas can only be deleted in bulk
; with the highly destructive 'area.reset' (although some T32 documentation
; incorrectly states that 'area.close <area_name>' destroys the area, it
; doesn't--it only closes the area's output logging).
;
; Furthermore, areas aren't destroyed automatically upon script exit, so
; if a user were to run multiple scripts with multiple areas they could
; quickly exhaust the 10-area limit and then find that subsequent script
; launches always fail, potentially with confusing error messages. This
; utility sub is intended to mitigate this risk without having to immidiately
; resort to running a global 'area.reset' during script initialization.
;
try_area_create:
(
  local &area_name
  local &cols
  local &rows

  entry &area_name &cols &rows

  ON ERROR gosub
  (
    &clk_err="try_area_create"
    return
  )

  &clk_err=""
  area.create &area_name &cols &rows

  if ("&clk_err"=="try_area_create")
  (
    return 0
  )
  else
  (
    return 1
  )
)

;
; bool area_create_list ( int num, [string area, int cols, int rows], ... )
;
; Attempts to create a list of areas. Will run the global 'area.reset' command
; upon the first failure, and return 0 upon the second failure. Otherwise
; returns non-zero upon success.
;
area_create_list:
(
  local &success
  local &already_failed
  local &area_name
  local &cols
  local &rows
  local &area_idx
  local &num
  local &input_line
  local &line_idx
  local &area_list_line_idx

  entry %LINE &input_line

  ; Get the number of areas to create.
  gosub get_substr_ws "&input_line" 0. GET_IDX
  entry &num &area_list_line_idx
  if ("&num"=="")
  (
    print %ERROR "ERROR: area_create_list() detected invalid input: '&input_line'."
    return 0
  )

  &already_failed=0

area_create_list_process_areas:

  ; Create each area.
  &area_idx=0
  &line_idx=&area_list_line_idx
  while (&area_idx<&num)
  (
    ; Read in the area information.
    gosub get_substr_ws "&input_line" &line_idx GET_IDX
    entry &area_name &line_idx
    if ("&area_name"=="")
    (
      goto area_create_list_too_few_args
    )
    gosub get_substr_ws "&input_line" &line_idx GET_IDX
    entry &cols &line_idx
    if ("&cols"=="")
    (
      goto area_create_list_too_few_args
    )
    gosub get_substr_ws "&input_line" &line_idx GET_IDX
    entry &rows &line_idx
    if ("&rows"=="")
    (
      goto area_create_list_too_few_args
    )

    ; Check if the row/col argument was bypassed.
    if (("&cols"==",")||("&rows"==","))
    (
      ; Apply a sanity check for row/col bypass.
      if (("&cols"!=",")||("&rows"!=","))
      (
        print %ERROR "ERROR: area_create_list() detected invalid row/col settings for '&area_name'."
        print %ERROR "       Row/col must both be an integer or both be ',' (got row='&row', col='&col'). "
        return 0
      )

      &cols=""
      &rows=""
    )

    ; Attempt to create the area.
    gosub try_area_create &area_name &cols &rows
    entry &success

    if (&success==0)
    (
      ; Already failed => infinite impending failures.
      if (&already_failed!=0)
      (
        print %ERROR %Decimal "ERROR: area_create_list() failed to create &num areas."
        return 0
      )

      ; Delete all areas and try creating the area list once more.
      &already_failed=1
      area.reset
      goto area_create_list_process_areas
    )

    &area_idx=&area_idx+1
  )

  return 1

area_create_list_too_few_args:

  print %ERROR "ERROR: area_create_list() detected too few arguments (num_areas='&num')."
  return 0
)

;
; string get_substr_ws ( string src_str, int read_idx, [flag get_idx] )
;
; Returns a sub-string from a source string, starting from a read index and
; ending before a ' ' whitespace terminator. If 'get_idx' flag is provided
; and the substring is found, the index of the start of the subsequent
; substring is also returned (-1 if there is no subsequent sub-string).
;
; Example: <gosub get_substr_ws "a  bc  de" 1> returns "bc" (sans quotes).
;
get_substr_ws:
(
  local &src_str
  local &src_len
  local &read_idx
  local &sub_str
  local &start_idx
  local &get_idx

  entry &src_str &read_idx &get_idx

  if (&read_idx<0)
  (
    ; Negative read index--return empty string (and no index).
    return
  )

  &src_len=string.length(&src_str)
  &search_mode="!="

  ; Find the start of non-whitespace segment.
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)!=' ')
    (
      &start_idx=&read_idx
      goto get_substr_ws_find_end_idx
    )

    &read_idx=&read_idx+1
  )

  ; No non-whitespace found--return empty string (and no index).
  return

get_substr_ws_find_end_idx:

  ; Find the end of non-whitespace segment.
  &read_idx=&read_idx+1
  while (&read_idx<&src_len)
  (
    if (string.char(&src_str, &read_idx)==' ')
    (
      ; Cut out leading and trailing whitespace
      &sub_str=string.mid(&src_str, &start_idx, &read_idx-&start_idx)

      goto get_substr_ws_return_substr
    )

    &read_idx=&read_idx+1
  )

  ; No trailing white-space found--cut out any leading whitespace.
  &sub_str=string.cut(&src_str, &start_idx)
  &read_idx=-1

get_substr_ws_return_substr:

  if ("&get_idx"=="")
  (
    return &sub_str
  )
  else
  (
    return &sub_str &read_idx
  )
)

;
; int[2] extract_stored_win_dim ( string file_name,  string window_name )
;
; Returns the settings for the given window extracted from a previously
; stored file. Returns -1 if the window settings aren't found.
;
; Returns: {x_start, y_start, x_length, y_length}
;          (all values are in row or column units).
;
extract_stored_win_dim:
(
  local &window_name
  local &file_name
  local &x_start
  local &y_start
  local &x_len
  local &y_len
  local &line_in
  local &idx

  entry &file_name &window_name

  &x_start=-1
  &y_start=-1
  &y_len=-1
  &x_start=-1

  ; Open the input file.
  (
    &clk_err=""
    ON ERROR gosub
    (
      print %ERROR "ERROR: extract_stored_win_dim() failed to open '&file_name'."
      &clk_err="extract_stored_win_dim"
      return
    )
    OPEN #1 &file_name /Read
  )

  if ("&clk_err"=="extract_stored_win_dim")
  (
    goto extract_stored_win_dim_error
  )

  ; Scan the input file for "winpos ... window_name".
  WHILE TRUE()
  (
    READ #1 %line &line_in
    if (EOF()==TRUE())
    (
      goto extract_stored_win_dim_error
    )
    &line_in=string.lower("&line_in")

    ; Search for 'winpos' line header and cut it out if found.
    &idx=string.scan("&line_in", "winpos", 0)
    if (&idx!=-1)
    (
      &line_in=string.cut("&line_in", &idx+6.)

      ; Search for the specified window name.
      if (string.scan("&line_in", "&window_name", 0)!=-1)
      (
        ; Extract the specified window's settings.
        gosub get_substr_ws "&line_in" 0. GET_IDX
        entry &x_start &idx
        if ("&x_start"=="")
        (
          goto extract_stored_win_dim_error
        )
        gosub get_substr_ws "&line_in" &idx GET_IDX
        entry &y_start &idx
        if ("&y_start"=="")
        (
          goto extract_stored_win_dim_error
        )
        gosub get_substr_ws "&line_in" &idx GET_IDX
        entry &x_len &idx
        if ("&x_len"=="")
        (
          goto extract_stored_win_dim_error
        )
        gosub get_substr_ws "&line_in" &idx GET_IDX
        entry &y_len &idx
        if ("&y_len"=="")
        (
          goto extract_stored_win_dim_error
        )

        CLOSE #1
        return &x_start &y_start &x_len &y_len
      )
    )
  )

extract_stored_win_dim_error:

  CLOSE #1
  return -1 -1 -1 -1
)

;
; bool save_window_settings ( string window_name, [flag print_error] )
;
; Saves a script's window configuration (position + size).
; See restore_window_settings() for the restore operation.
; Returns non-zero if the store operation succeeded.
;
; This is provided as a method to allow scripts to save/restore their window
; settings accross multiple script sessions. T32's "store <file> win" tool
; is insufficient to do this since it will only save/restore *all* T32 windows,
; not targeted windows.
;
save_window_settings:
(
  local &file
  local &window_name
  local &script_name
  local &print_error

  &clk_err=""
  ON ERROR gosub
  (
    &clk_err="save_window_settings"
    return
  )

  entry &window_name &print_error

  ; Store the full window configuration in a file under the temporary directory.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")

  &file=os.ptd()
  &file="&(file)\__&(script_name)_&(window_name)_dim.cmm"
  store &file win

  if ("&clk_err"=="save_window_settings")
  (
    if ("&print_error"!="")
    (
      print %ERROR "ERROR: save_window_settings() failed to store settings for '&window_name'."
    )
    return 0
  )
  else
  (
    return 1
  )
)

;
; int[4] find_saved_window_settings ( string window_name )
;
; Returns the settings for the given window extracted from a previously
; save. Returns -1 if the window settings aren't found.
;
; Returns: {x_start, y_start, x_length, y_length}
;          (all values are in row or column units).
;
; This is provided as a method to allow scripts to save/restore their window
; settings accross multiple script sessions. T32's "store <file> win" tool
; is insufficient to do this since it will only save/restore *all* T32 windows,
; not targeted windows.
;
find_saved_window_settings:
(
  local &x_start
  local &y_start
  local &x_len
  local &y_len
  local &window_name
  local &file
  local &script_name

  entry &window_name

  ; Check if the window's saved settings file exists.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")

  &file=os.ptd()
  &file="&(file)\__&(script_name)_&(window_name)_dim.cmm"
  if (os.file.access("&file", "R")==FALSE())
  (
    return -1 -1 -1 -1
  )

  ; Search for previously saved settings for this window.
  gosub extract_stored_win_dim &file &window_name
  entry &x_start &y_start &x_len &y_len

  return &x_start &y_start &x_len &y_len
)

;
; bool delete_saved_window_settings ( string window_name, [flag print_error] )
;
; Deletes a window settings file.
;
delete_saved_window_settings:
(
  local &success
  local &file
  local &script_name
  local &window_name
  local &print_error

  entry &window_name &print_error

  ; Check if the window's saved settings file exists.
  &script_name=os.ppf()
  &script_name=os.file.name("&script_name")

  &file=os.ptd()
  &file="&(file)\__&(script_name)_&(window_name)_dim.cmm"
  if (os.file.access("&file", "W")==TRUE())
  (
    ; Delete the file.
    del &file
    &success=1
  )
  else
  (
    if ("&print_error"!="")
    (
      print %ERROR "ERROR: delete_saved_window_settings() failed to delete window settings for '&window_name'."
    )
    &success=0
  )

  return &success
)

