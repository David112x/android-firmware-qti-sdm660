/*
==============================================================================

FILE:         HALclkDDRDIMWRAPPER.c

DESCRIPTION:
   This auto-generated file contains the clock HAL code for the 
   DDRDIMWRAPPER clocks.

   List of clock domains:
     - HAL_clk_mGCCBIMCDDRCPLL0ROOTClkDomain
     - HAL_clk_mGCCBIMCDDRCPLL1ROOTClkDomain


   List of power domains:



==============================================================================

$Header: //components/rel/rpm.bf/1.8/core/systemdrivers/hal/clk/hw/sdm660/src/GCC/HALclkDDRDIMWRAPPER.c#6 $

==============================================================================
            Copyright (c) 2016 QUALCOMM Technologies Incorporated.
                    All Rights Reserved.
                  QUALCOMM Proprietary/GTDR
==============================================================================
*/

/*============================================================================

                     INCLUDE FILES FOR MODULE

============================================================================*/

#include <stdlib.h>
#include <HALhwio.h>

#include "HALclkInternal.h"
#include "HALclkTest.h"
#include "HALclkGeneric.h"
#include "HALclkHWIO.h"
#include "assert.h"
#include "HALclk.h"




/*============================================================================

             DEFINITIONS AND DECLARATIONS FOR MODULE

=============================================================================*/


/* ============================================================================
**    Prototypes
** ==========================================================================*/

static void HAL_clk_DDRConfigMux( HAL_clk_ClockDomainDescType *pmClockDomainDesc, const HAL_clk_ClockMuxConfigType * );
void HAL_clk_DDRDisable( HAL_clk_ClockDescType *pmClockDesc );
void HAL_clk_DDREnable ( HAL_clk_ClockDescType *pmClockDesc );
static void HAL_clk_DDRSetConfigMux( uint32 nCmdCGRAddr, uint32 nSourceIndex, uint32 nDiv2x );

void HAL_clk_SaveBIMCPorts( const HAL_clk_ClockMuxConfigType *pmConfig );

/* ============================================================================
**    Externs
** ==========================================================================*/

extern HAL_clk_ClockDomainControlType  HAL_clk_mGCCClockDomainControl;
extern HAL_clk_ClockDomainControlType  HAL_clk_mGCCClockDomainControlRO;




/* ============================================================================
**    Data
** ==========================================================================*/

/*
 * aGCCSourceMap_1
 *
 * GCC HW source mapping
 * 
 */
static HAL_clk_SourceMapType aGCCSourceMap_1[] =
{
  { HAL_CLK_SOURCE_XO,                 0 },
  { HAL_CLK_SOURCE_GPLL0,              1 },
  { HAL_CLK_SOURCE_GPLL2,              2 },
  { HAL_CLK_SOURCE_GPLL3,              3 },
  { HAL_CLK_SOURCE_GPLL1,              4 },
  { HAL_CLK_SOURCE_GPLL4,              5 },
  { HAL_CLK_SOURCE_GPLL5,              5 },
  { HAL_CLK_SOURCE_GPLL0_DIV2,         6 },
  { HAL_CLK_SOURCE_NULL,               HAL_CLK_SOURCE_INDEX_INVALID }
};

typedef struct 
{
  uint16 nSrcIdx;
  uint16 nDiv;
} ClkRCGRType;

static ClkRCGRType cDSPPort;
static ClkRCGRType Q6Port;
static ClkRCGRType HMSSPort;
static ClkRCGRType GFXPort;
static boolean bReduceQ6Port = FALSE;
static boolean bDDRCPLL0En = FALSE;
static boolean bDDRCPLL1En = FALSE;

#define MAX_RETRY 120

/* Divider macro for detect DDR at 1804MHz level for limit BIMC GFX */
#define BIMC_1804MHZ 30

/*
 * HAL_clk_mDDRClockControl
 *
 * Functions for controlling DDR clock functions.
 */
HAL_clk_ClockControlType HAL_clk_mDDRClockControl =
{
  /* .Enable           = */ HAL_clk_DDREnable,
  /* .Disable          = */ HAL_clk_DDRDisable,
  /* .IsEnabled        = */ HAL_clk_GenericIsEnabled,
  /* .IsOn             = */ HAL_clk_GenericIsOn,
  /* .Reset            = */ HAL_clk_GenericReset,
  /* .Config           = */ NULL,
  /* .DetectConfig     = */ NULL,
  /* .ConfigDivider    = */ HAL_clk_GenericConfigDivider,
  /* .DetectDivider    = */ HAL_clk_GenericDetectDivider,
  /* .ConfigFootswitch = */ HAL_clk_GenericConfigFootswitch,
};

/*
 * HAL_clk_BIMCDDRDomainControl
 *
 * BIMC clock domain control. (Note: this is not generated by HALclkGen.)
 */
HAL_clk_ClockDomainControlType HAL_clk_BIMCDDRDomainControl =
{
  /* .ConfigMux       = */ HAL_clk_DDRConfigMux,
  /* .DetectMuxConfig = */ HAL_clk_GenericDetectMuxConfig,
  /* .pmSourceMap     = */ aGCCSourceMap_1
};


/*                           
 *  HAL_clk_mBIMCDDRCPLL0ROOTClkDomainClks
 *                  
 *  List of clocks supported by this domain.
 */
static HAL_clk_ClockDescType HAL_clk_mBIMCDDRCPLL0ROOTClkDomainClks[] =
{
  {
    /* .szClockName      = */ "gcc_bimc_ddr_cpll0_clk",
    /* .mRegisters       = */ { HWIO_OFFS(GCC_BIMC_DDR_CPLL0_CBCR), 0, {0, 0} },
    /* .pmControl        = */ &HAL_clk_mDDRClockControl,
    /* .nTestClock       = */ HAL_CLK_GCC_TEST_GCC_BIMC_DDR_CPLL0_CLK
  },
};

/*
 * HAL_clk_mGCCBIMCDDRCPLL0ROOTClkDomain
 *
 * BIMCDDRCPLL0ROOT clock domain.
 */
HAL_clk_ClockDomainDescType HAL_clk_mGCCBIMCDDRCPLL0ROOTClkDomain =
{
  /* .nCGRAddr             = */ HWIO_OFFS(GCC_BIMC_DDR_CPLL0_ROOT_CMD_RCGR),
  /* .pmClocks             = */ HAL_clk_mBIMCDDRCPLL0ROOTClkDomainClks,
  /* .nClockCount          = */ sizeof(HAL_clk_mBIMCDDRCPLL0ROOTClkDomainClks)/sizeof(HAL_clk_mBIMCDDRCPLL0ROOTClkDomainClks[0]),
  /* .pmControl            = */ &HAL_clk_BIMCDDRDomainControl,
  /* .pmNextClockDomain    = */ NULL
};


/* ===========================================================================
**  HAL_clk_DDRDisable
** ======================================================================== */
void HAL_clk_DDRDisable
(
  HAL_clk_ClockDescType *pmClockDesc
)
{
  /* 
   * Disable DDR Root clocks
   */
  if( !bDDRCPLL0En )
  {
    HWIO_OUTF( GCC_BIMC_DDR_CPLL0_CBCR, CLK_ENABLE, 0);
    HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_BIMC_DDR_CPLL0_ROOT_CMD_RCGR), 0, 0 );
  }
  if( !bDDRCPLL1En )
  {
    HWIO_OUTF( GCC_BIMC_DDR_CPLL1_CBCR, CLK_ENABLE, 0);
    HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_BIMC_DDR_CPLL1_ROOT_CMD_RCGR), 0, 0 );
  }
}

/* ===========================================================================
**  HAL_clk_DDREnable
** ======================================================================== */
void HAL_clk_DDREnable
(
  HAL_clk_ClockDescType *pmClockDesc
)
{
  /* 
   * Enable DDR Root clocks
   */
  if( bDDRCPLL0En )
  {
    HWIO_OUTF( GCC_BIMC_DDR_CPLL0_CBCR, CLK_ENABLE, 1);
  }
  else if( bDDRCPLL1En )
  {
    HWIO_OUTF( GCC_BIMC_DDR_CPLL1_CBCR, CLK_ENABLE, 1);
  }

}

/* ===========================================================================
**  HAL_clk_DDRPC
** ======================================================================== */
void HAL_clk_DDRPC
(
  boolean bCollapse
)
{
  if (bCollapse)
  {
    if( bDDRCPLL0En )
    {
      HWIO_OUTF( GCC_BIMC_DDR_CPLL0_CBCR, CLK_ENABLE, 0);
    }
    if( bDDRCPLL1En )
    {
      HWIO_OUTF( GCC_BIMC_DDR_CPLL1_CBCR, CLK_ENABLE, 0);
    }

    HAL_clk_DDRDisable(NULL);
    HWIO_OUTF( GCC_MSS_Q6_BIMC_AXI_CBCR, CLK_ENABLE, 0);
    HWIO_OUTF( GCC_BIMC_CBCR, CLK_ENABLE, 0);
    HWIO_OUTF( GCC_GPU_BIMC_GFX_CBCR, CLK_ENABLE, 0);
  }
  else
  {
    HAL_clk_DDREnable(NULL);
    HWIO_OUTF( GCC_MSS_Q6_BIMC_AXI_CBCR, CLK_ENABLE, 1);
    HWIO_OUTF( GCC_BIMC_CBCR, CLK_ENABLE, 1);
    HWIO_OUTF( GCC_GPU_BIMC_GFX_CBCR, CLK_ENABLE, 1);
  }
}

/* =========================================================================
**  Function : HAL_clk_DDRSetConfigMux
** =========================================================================*/
/*!
    Configure BIMC clock domain.

    @param 
      nCmdCGRAddr     - Clock CMD_CGR address
      nSourceIndex    - Source Index
      nDiv2x          - Divider

    @return
      None.

    @dependencies

    @sa None
*/
static void HAL_clk_DDRSetConfigMux
(
  uint32 nCmdCGRAddr,
  uint32 nSourceIndex,
  uint32 nDiv2x
)
{
  uint32 nCmdCGRVal;
  uint32 nCfgCGRAddr = (nCmdCGRAddr + HAL_CLK_CFG_REG_OFFSET);
  uint32 nCfgCGRVal  = inpdw(nCfgCGRAddr);

  /*
   * Clear the CFG_CGR fields.
   */
  nCfgCGRVal &= ~(HAL_CLK_CFG_CGR_SRC_SEL_FMSK |
                  HAL_CLK_CFG_CGR_SRC_DIV_FMSK |
                  HAL_CLK_CFG_CGR_MODE_FMSK);

  /* Convert divider to HAL format. */
  if ( nDiv2x > 0 )
    nDiv2x--;

  /* Enforce max half-integer divider of 16 (31 in HAL format). */
  if ( nDiv2x > 31 )
    nDiv2x = 31;

  /*
   * Program the source and divider values.
   */
  nCfgCGRVal |= ((nSourceIndex << HAL_CLK_CFG_CGR_SRC_SEL_SHFT) & HAL_CLK_CFG_CGR_SRC_SEL_FMSK);
  nCfgCGRVal |= ((nDiv2x << HAL_CLK_CFG_CGR_SRC_DIV_SHFT) & HAL_CLK_CFG_CGR_SRC_DIV_FMSK);

  /*
   * Write the final CFG register value.
   */
  outpdw(nCfgCGRAddr, nCfgCGRVal);

  /* Force the root ON to protect against external branch enables
   * causing failure of this next clock switch.  Roots do not handle
   * a simultaneous ENABLE and SWITCH.  It is illegal.
   */
  nCmdCGRVal = inpdw(nCmdCGRAddr);
  nCmdCGRVal |= HAL_CLK_CMD_CGR_ROOT_EN_FMSK;
  outpdw(nCmdCGRAddr, nCmdCGRVal);
  /*
   * Wait for the root to enable.
   */
  while(inpdw(nCmdCGRAddr) & HAL_CLK_CMD_CGR_ROOT_OFF_FMSK);

  /*
   * Trigger the update.
   */
  nCmdCGRVal = inpdw(nCmdCGRAddr);
  nCmdCGRVal |= HAL_CLK_CMD_CFG_UPDATE_FMSK;
  outpdw(nCmdCGRAddr, nCmdCGRVal);

  /*
   * Wait until update finishes.
   */
  while(inpdw(nCmdCGRAddr) & HAL_CLK_CMD_CFG_UPDATE_FMSK);


  /* Remove the root override */
  nCmdCGRVal = inpdw(nCmdCGRAddr);
  nCmdCGRVal &= (~HAL_CLK_CMD_CGR_ROOT_EN_FMSK);
  outpdw(nCmdCGRAddr, nCmdCGRVal);
}

                                                  /*HAL PLLx                    , sourcemap */
uint32 nPllSel[NUM_GPLLx_ASYNC_CLK_PLL_ID][2] = { {0                   , 0},
                                                  {HAL_CLK_SOURCE_GPLL0, 0},
                                                  {HAL_CLK_SOURCE_GPLL1, 0},
                                                  {HAL_CLK_SOURCE_GPLL4, 0},
                                                  {HAL_CLK_SOURCE_GPLL5, 0},
                                                };

/* =========================================================================
**  Function : HAL_clk_DDRConfigMux
** =========================================================================*/


typedef enum
{
	DEBUG_START = 0,
	DDR_AFTER_ASSERT,
	DDR_BEFORE_DDR_CPLL_CFG,
	DDR_AFTER_CLOCK_EN_GCC_MODE,
	DDR_BEFORE_GCC_BIMC_CFG,
	DDR_BEFORE_HMSS_AXI_CFG,
	DDR_BEFORE_GFX_CFG,
	DDR_BEFORE_MSS_Q6_BIMC_AXI_CFG,
	DDR_BEFORE_GCC_CDSP_CFG,
	DEBUG_END,
	DEBUG_INVALID = 0x7FFFFFF
}HAL_DDR_DEBUG_MARKER;

volatile HAL_DDR_DEBUG_MARKER hal_ddr_debug_marker = DEBUG_INVALID;

/*!
    Programs 

    @param
      pmClockDomainDesc - [IN] Clock domain structure
      pmConfig          - [IN] Clock mux config structure

    @return
      None.

    @dependencies
      None.

    @sa
      None.
*/
void HAL_clk_DDRConfigMux
(
  HAL_clk_ClockDomainDescType      *pmClockDomainDesc,
  const HAL_clk_ClockMuxConfigType *pmConfig
)
{
  uint32                 nCGRAddr, nBCRAddr;
  HAL_clk_SourceMapType *pmSourceMap;

  /*
   * Sanity check
   */
  if((pmConfig                                    == NULL) ||
     (pmClockDomainDesc                           == NULL) ||
     (pmClockDomainDesc->nCGRAddr                 == 0   ) || 
     (pmClockDomainDesc->pmControl                == NULL) ||
     (pmClockDomainDesc->pmControl->pmSourceMap   == NULL) )
  {
    return;
  }
  debug_marker(hal_ddr_debug_marker, DEBUG_START);
  /*
   * Get source index from source enum
   */
  pmSourceMap = pmClockDomainDesc->pmControl->pmSourceMap;
  nPllSel[GPLL23_GPLL0_BIMC_DDR_RCG_PLL_ID][1] = HAL_clk_GenericSourceMapToHW(pmSourceMap, pmConfig->eSource);
  nPllSel[GPLL0_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL0);
  nPllSel[GPLL1_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL1);
  nPllSel[GPLL4_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL4);
  nPllSel[GPLL5_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL5);



  /*
   * Assert if could not find matching source index
   */
  assert (nPllSel[GPLL23_GPLL0_BIMC_DDR_RCG_PLL_ID][1] != HAL_CLK_SOURCE_INDEX_INVALID);
  assert (nPllSel[GPLL0_ASYNC_CLK_PLL_ID][1] != HAL_CLK_SOURCE_INDEX_INVALID);
  assert (nPllSel[GPLL1_ASYNC_CLK_PLL_ID][1] != HAL_CLK_SOURCE_INDEX_INVALID);
  //assert (nPllSel[GPLL4_ASYNC_CLK_PLL_ID][1] != HAL_CLK_SOURCE_INDEX_INVALID);
  debug_marker(hal_ddr_debug_marker, DDR_AFTER_ASSERT);
  /*
   * Toggle between two DDR CPLLs.
   */
  if ( HWIO_INF(GCC_BIMC_DDR_CPLL0_CBCR, CLK_ENABLE) )
  {
    nCGRAddr = HWIO_ADDR(GCC_BIMC_DDR_CPLL1_ROOT_CMD_RCGR);
    nBCRAddr = HWIO_ADDR(GCC_BIMC_DDR_CPLL1_CBCR);
    bDDRCPLL0En = FALSE;
    bDDRCPLL1En = TRUE;
  }
  else if ( HWIO_INF(GCC_BIMC_DDR_CPLL1_CBCR, CLK_ENABLE) )
  {
    nCGRAddr = HWIO_ADDR(GCC_BIMC_DDR_CPLL0_ROOT_CMD_RCGR);
    nBCRAddr = HWIO_ADDR(GCC_BIMC_DDR_CPLL0_CBCR);
    bDDRCPLL0En = TRUE;
    bDDRCPLL1En = FALSE;
  }
  /*
   * Both DDR CPLLs are OFF indicating current mode is DDRCC, choose CPLL0 
   * in case we transition from DDRCC -> GCC to satisfy MCCC requirement.
   */
  else
  {
    nCGRAddr = HWIO_ADDR(GCC_BIMC_DDR_CPLL0_ROOT_CMD_RCGR);
    nBCRAddr = HWIO_ADDR(GCC_BIMC_DDR_CPLL0_CBCR);
    bDDRCPLL0En = TRUE;
    bDDRCPLL1En = FALSE;
  } 
  /*
   * Set GCC_BIMC_DDR_CPLL config.
   */
  debug_marker(hal_ddr_debug_marker, DDR_BEFORE_DDR_CPLL_CFG);
  HAL_clk_DDRSetConfigMux( nCGRAddr,
                           nPllSel[HAL_CLK_BIMC_DIV2X_DDR_GPLL0_SEL(pmConfig->nDiv2x)][1],
                           HAL_CLK_BIMC_DIV2X_DDR_DIV2X(pmConfig->nDiv2x));

  /* Enable Clock Only in GCC MODE */
  if ( !HAL_CLK_BIMC_DIV2X_DDRCC_MODE_EN (pmConfig->nDiv2x))
  {
    outpdw(nBCRAddr, HWIO_FMSK(GCC_BIMC_DDR_CPLL0_CBCR, CLK_ENABLE));
	debug_marker(hal_ddr_debug_marker, DDR_AFTER_CLOCK_EN_GCC_MODE);
  }
  /*
   * Set GCC_BIMC config.
   */
  debug_marker(hal_ddr_debug_marker, DDR_BEFORE_GCC_BIMC_CFG);
  HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_BIMC_CMD_RCGR) ,
                           nPllSel[HAL_CLK_BIMC_M_BIMC_GPLL0_SEL(pmConfig->nM)][1],
                           HAL_CLK_BIMC_M_BIMC_DIV2X(pmConfig->nM));

  HAL_clk_SaveBIMCPorts( pmConfig );

  /*
   * Set GCC_BIMC_HMSS_AXI config.
   */
  debug_marker(hal_ddr_debug_marker, DDR_BEFORE_HMSS_AXI_CFG);
  HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_BIMC_HMSS_AXI_CMD_RCGR), HMSSPort.nSrcIdx, HMSSPort.nDiv );
  
  /* Set GCC_GPU_BIMC_GFX config. */
  debug_marker(hal_ddr_debug_marker, DDR_BEFORE_GFX_CFG);
  HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_GPU_BIMC_GFX_CMD_RCGR), GFXPort.nSrcIdx, GFXPort.nDiv);

  /*
   * Set GCC_MSS_Q6_BIMC_AXI config
   */
  if ( !bReduceQ6Port )
  {
    /*
     * Set GCC_MSS_Q6_BIMC_AXI config
     */
	debug_marker(hal_ddr_debug_marker, DDR_BEFORE_MSS_Q6_BIMC_AXI_CFG);
    HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_MSS_Q6_BIMC_AXI_CMD_RCGR), Q6Port.nSrcIdx, Q6Port.nDiv );
  }

  
  /* Set GCC_cDSP config. */
  debug_marker(hal_ddr_debug_marker, DDR_BEFORE_GCC_CDSP_CFG);
  HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_CDSP_BIMC_CMD_RCGR), cDSPPort.nSrcIdx, cDSPPort.nDiv );
  debug_marker(hal_ddr_debug_marker, DEBUG_END);

} /* HAL_clk_BIMCConfigMux */

void HAL_clk_SPMAPPSEnableBIMCPorts( boolean bEnable )
{
  HWIO_OUTF( GCC_GPU_BIMC_GFX_CBCR, CLK_ENABLE, bEnable);
  if(bEnable)
  {
    HWIO_OUTF(GCC_HMSS_GPLL0_CFG_RCGR, SRC_SEL, 1);
  }
  else
  {
    HWIO_OUTF(GCC_HMSS_GPLL0_CFG_RCGR, SRC_SEL, 0);
  }
   HWIO_OUTF(GCC_HMSS_GPLL0_CMD_RCGR, UPDATE, 1);
  while(HWIO_INF(GCC_HMSS_GPLL0_CMD_RCGR, UPDATE));
}

void HAL_clk_EnableQ6BIMCPorts( boolean bEnable )
{
  HWIO_OUTF( GCC_MSS_Q6_BIMC_AXI_CBCR, CLK_ENABLE, bEnable);
}
void HAL_clk_ReduceQ6BIMCPorts( boolean bReduce )
{
  if ( bReduce == bReduceQ6Port )
  { 
    return;
  }
  if ( bReduce )
  {
    /* Reduce to lowest speed */
    HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_MSS_Q6_BIMC_AXI_CMD_RCGR), 0, 2 ); // let DCD do Div16
  }
  else
  {
    /* Resume to previous speed */
    HAL_clk_DDRSetConfigMux( HWIO_ADDR(GCC_MSS_Q6_BIMC_AXI_CMD_RCGR), Q6Port.nSrcIdx, Q6Port.nDiv );
  }
  bReduceQ6Port = bReduce;
}

/* Save the BIMC port states for restoring later if they are minimized.  Also 
 * may be of use in debugging. */
void HAL_clk_SaveBIMCPorts( const HAL_clk_ClockMuxConfigType *pmConfig )
{
  HAL_clk_ClockDomainDescType      *pmClockDomainDesc = &HAL_clk_mGCCBIMCDDRCPLL0ROOTClkDomain;
  HAL_clk_SourceMapType *pmSourceMap;
  pmSourceMap = pmClockDomainDesc->pmControl->pmSourceMap;
  nPllSel[GPLL23_GPLL0_BIMC_DDR_RCG_PLL_ID][1] = HAL_clk_GenericSourceMapToHW(pmSourceMap, pmConfig->eSource);
  nPllSel[GPLL0_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL0);
  nPllSel[GPLL1_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL1);
  nPllSel[GPLL4_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL4);
  nPllSel[GPLL5_ASYNC_CLK_PLL_ID][1]           = HAL_clk_GenericSourceMapToHW(pmSourceMap, HAL_CLK_SOURCE_GPLL5);



  /*
   * Assert if could not find matching source index
   */
  assert (nPllSel[GPLL23_GPLL0_BIMC_DDR_RCG_PLL_ID][1] != HAL_CLK_SOURCE_INDEX_INVALID);
  assert (nPllSel[GPLL0_ASYNC_CLK_PLL_ID][1] != HAL_CLK_SOURCE_INDEX_INVALID);
  assert (nPllSel[GPLL1_ASYNC_CLK_PLL_ID][1] != HAL_CLK_SOURCE_INDEX_INVALID);

  /* Save HMSS/GFX/Q6 ports for restore */
  HMSSPort.nSrcIdx = nPllSel[HAL_CLK_BIMC_M_HMSS_GPLL0_SEL(pmConfig->nM)][1];
  HMSSPort.nDiv = HAL_CLK_BIMC_M_HMSS_DIV2X(pmConfig->nM);

  GFXPort.nSrcIdx = nPllSel[HAL_CLK_BIMC_N_GFX_GPLL0_SEL(pmConfig->nN)][1];
  GFXPort.nDiv = HAL_CLK_BIMC_N_GFX_DIV2X(pmConfig->nN);

  Q6Port.nSrcIdx = nPllSel[HAL_CLK_BIMC_N_MPSS_GPLL0_SEL(pmConfig->nN)][1];
  Q6Port.nDiv = HAL_CLK_BIMC_N_MPSS_DIV2X(pmConfig->nN);


  cDSPPort.nSrcIdx = nPllSel[HAL_CLK_BIMC_DIV2X_CDSP_GPLL0_SEL(pmConfig->nDiv2x)][1];
  cDSPPort.nDiv = HAL_CLK_BIMC_DIV2X_CDSP_DIV2X(pmConfig->nDiv2x);
  
}


/*
 * HAL_clk_mGCCDDRDIMWRAPPERPowerDomain
 *
 * DDR_DIM_WRAPPER power domain.
 */
HAL_clk_PowerDomainDescType HAL_clk_mGCCDDRDIMWRAPPERPowerDomain =
{
  /* .szPowerDomainName       = */ "VDD_DDR_DIM_WRAPPER",
  /* .nGDSCRAddr              = */ HWIO_OFFS(GCC_DDR_DIM_WRAPPER_GDSCR),
  /* .pmControl               = */ &HAL_clk_mGenericPowerDomainControl,
  /* .pmNextPowerDomain       = */ NULL
};
